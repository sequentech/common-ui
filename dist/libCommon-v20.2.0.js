if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");

function uiUploader($log) {
    "use strict";
    var self = this;
    function startUpload(options) {
        self.options = options;
        for (var i = 0; i < self.files.length && self.activeUploads != self.options.concurrency; i++) self.files[i].active || function(file, url) {
            var xhr, formData;
            self.activeUploads += 1, file.active = !0, xhr = new window.XMLHttpRequest(), formData = new window.FormData(), 
            xhr.open("POST", url), xhr.upload.onloadstart = function() {}, xhr.upload.onprogress = function(i) {
                var bytes;
                i.lengthComputable && (file.loaded = i.loaded, file.humanSize = (bytes = i.loaded, 
                i = +Math.floor(Math.log(bytes) / Math.log(1024)), (bytes / Math.pow(1024, i)).toFixed(i ? 1 : 0) + " " + [ "n/a", "bytes", "KiB", "MiB", "GiB", "TB", "PB", "EiB", "ZiB", "YiB" ][isNaN(bytes) ? 0 : 1 + i]), 
                self.options.onProgress(file));
            }, xhr.onload = function() {
                --self.activeUploads, startUpload(self.options), self.options.onCompleted(file, xhr.responseText);
            }, xhr.onerror = function() {}, formData.append("file", file, file.name), xhr.send(formData);
        }(self.files[i], self.options.url);
    }
    return self.files = [], self.options = {}, self.activeUploads = 0, $log.info("uiUploader loaded"), 
    {
        addFiles: function(files) {
            for (var i = 0; i < files.length; i++) self.files.push(files[i]);
        },
        getFiles: function() {
            return self.files;
        },
        files: self.files,
        startUpload: startUpload,
        removeFile: function(file) {
            self.files.splice(self.files.indexOf(file), 1);
        },
        removeAll: function() {
            self.files.splice(0, self.files.length);
        }
    };
}

var mod;

function RC4(seed) {
    this.s = new Array(256), this.i = 0;
    for (var i = this.j = 0; i < 256; i++) this.s[i] = i;
    seed && this.mix(seed);
}

function RNG(seed) {
    null == seed ? seed = (Math.random() + Date.now()).toString() : "function" == typeof seed ? (this.uniform = seed, 
    this.nextByte = function() {
        return ~~(256 * this.uniform());
    }, seed = null) : "[object String]" !== Object.prototype.toString.call(seed) && (seed = JSON.stringify(seed)), 
    this._normal = null, this._state = seed ? new RC4(seed) : null;
}

!function() {
    "use strict";
    var version = jQuery.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || 1 == version[0] && 9 == version[1] && version[2] < 1 || 3 < version[0]) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4");
}(), function($) {
    "use strict";
    $.fn.emulateTransitionEnd = function(duration) {
        var called = !1, $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = !0;
        });
        return setTimeout(function() {
            called || $($el).trigger($.support.transition.end);
        }, duration), this;
    }, $(function() {
        $.support.transition = function() {
            var name, el = document.createElement("bootstrap"), transEndEventNames = {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd otransitionend",
                transition: "transitionend"
            };
            for (name in transEndEventNames) if (void 0 !== el.style[name]) return {
                end: transEndEventNames[name]
            };
            return !1;
        }(), $.support.transition && ($.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        });
    });
}(jQuery), function($) {
    "use strict";
    function Alert(el) {
        $(el).on("click", dismiss, this.close);
    }
    var dismiss = '[data-dismiss="alert"]';
    Alert.VERSION = "3.4.1", Alert.TRANSITION_DURATION = 150, Alert.prototype.close = function(e) {
        var $this = $(this), selector = $this.attr("data-target");
        selector = "#" === (selector = selector || (selector = $this.attr("href")) && selector.replace(/.*(?=#[^\s]*$)/, "")) ? [] : selector;
        var $parent = $(document).find(selector);
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove();
        }
        e && e.preventDefault(), ($parent = !$parent.length ? $this.closest(".alert") : $parent).trigger(e = $.Event("close.bs.alert")), 
        e.isDefaultPrevented() || ($parent.removeClass("in"), $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement());
    };
    var old = $.fn.alert;
    $.fn.alert = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.alert");
            data || $this.data("bs.alert", data = new Alert(this)), "string" == typeof option && data[option].call($this);
        });
    }, $.fn.alert.Constructor = Alert, $.fn.alert.noConflict = function() {
        return $.fn.alert = old, this;
    }, $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery), function($) {
    "use strict";
    var Button = function(element, options) {
        this.$element = $(element), this.options = $.extend({}, Button.DEFAULTS, options), 
        this.isLoading = !1;
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.button"), options = "object" == typeof option && option;
            data || $this.data("bs.button", data = new Button(this, options)), "toggle" == option ? data.toggle() : option && data.setState(option);
        });
    }
    Button.VERSION = "3.4.1", Button.DEFAULTS = {
        loadingText: "loading..."
    }, Button.prototype.setState = function(state) {
        var d = "disabled", $el = this.$element, val = $el.is("input") ? "val" : "html", data = $el.data();
        state += "Text", null == data.resetText && $el.data("resetText", $el[val]()), setTimeout($.proxy(function() {
            $el[val]((null == data[state] ? this.options : data)[state]), "loadingText" == state ? (this.isLoading = !0, 
            $el.addClass(d).attr(d, d).prop(d, !0)) : this.isLoading && (this.isLoading = !1, 
            $el.removeClass(d).removeAttr(d).prop(d, !1));
        }, this), 0);
    }, Button.prototype.toggle = function() {
        var $input, changed = !0, $parent = this.$element.closest('[data-toggle="buttons"]');
        $parent.length ? ("radio" == ($input = this.$element.find("input")).prop("type") ? ($input.prop("checked") && (changed = !1), 
        $parent.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == $input.prop("type") && ($input.prop("checked") !== this.$element.hasClass("active") && (changed = !1), 
        this.$element.toggleClass("active")), $input.prop("checked", this.$element.hasClass("active")), 
        changed && $input.trigger("change")) : (this.$element.attr("aria-pressed", !this.$element.hasClass("active")), 
        this.$element.toggleClass("active"));
    };
    var old = $.fn.button;
    $.fn.button = Plugin, $.fn.button.Constructor = Button, $.fn.button.noConflict = function() {
        return $.fn.button = old, this;
    }, $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle"), $(e.target).is('input[type="radio"], input[type="checkbox"]') || (e.preventDefault(), 
        ($btn.is("input,button") ? $btn : $btn.find("input:visible,button:visible").first()).trigger("focus"));
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery), function($) {
    "use strict";
    function Carousel(element, options) {
        this.$element = $(element), this.$indicators = this.$element.find(".carousel-indicators"), 
        this.options = options, this.paused = null, this.sliding = null, this.interval = null, 
        this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this)), 
        "hover" != this.options.pause || "ontouchstart" in document.documentElement || this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.carousel"), options = $.extend({}, Carousel.DEFAULTS, $this.data(), "object" == typeof option && option), action = "string" == typeof option ? option : options.slide;
            data || $this.data("bs.carousel", data = new Carousel(this, options)), "number" == typeof option ? data.to(option) : action ? data[action]() : options.interval && data.pause().cycle();
        });
    }
    Carousel.VERSION = "3.4.1", Carousel.TRANSITION_DURATION = 600, Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, Carousel.prototype.keydown = function(e) {
        if (!/input|textarea/i.test(e.target.tagName)) {
            switch (e.which) {
              case 37:
                this.prev();
                break;

              case 39:
                this.next();
                break;

              default:
                return;
            }
            e.preventDefault();
        }
    }, Carousel.prototype.cycle = function(e) {
        return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval)), 
        this;
    }, Carousel.prototype.getItemIndex = function(item) {
        return this.$items = item.parent().children(".item"), this.$items.index(item || this.$active);
    }, Carousel.prototype.getItemForDirection = function(itemIndex, active) {
        var activeIndex = this.getItemIndex(active);
        if (("prev" == itemIndex && 0 === activeIndex || "next" == itemIndex && activeIndex == this.$items.length - 1) && !this.options.wrap) return active;
        itemIndex = (activeIndex + ("prev" == itemIndex ? -1 : 1)) % this.$items.length;
        return this.$items.eq(itemIndex);
    }, Carousel.prototype.to = function(pos) {
        var that = this, activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (!(pos > this.$items.length - 1 || pos < 0)) return this.sliding ? this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        }) : activeIndex == pos ? this.pause().cycle() : this.slide(activeIndex < pos ? "next" : "prev", this.$items.eq(pos));
    }, Carousel.prototype.pause = function(e) {
        return e || (this.paused = !0), this.$element.find(".next, .prev").length && $.support.transition && (this.$element.trigger($.support.transition.end), 
        this.cycle(!0)), this.interval = clearInterval(this.interval), this;
    }, Carousel.prototype.next = function() {
        if (!this.sliding) return this.slide("next");
    }, Carousel.prototype.prev = function() {
        if (!this.sliding) return this.slide("prev");
    }, Carousel.prototype.slide = function(type, $nextIndicator) {
        var $active = this.$element.find(".item.active"), $next = $nextIndicator || this.getItemForDirection(type, $active), isCycling = this.interval, direction = "next" == type ? "left" : "right", that = this;
        if ($next.hasClass("active")) return this.sliding = !1;
        var relatedTarget = $next[0], $nextIndicator = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if (this.$element.trigger($nextIndicator), !$nextIndicator.isDefaultPrevented()) {
            this.sliding = !0, isCycling && this.pause(), this.$indicators.length && (this.$indicators.find(".active").removeClass("active"), 
            ($nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])) && $nextIndicator.addClass("active"));
            var slidEvent = $.Event("slid.bs.carousel", {
                relatedTarget: relatedTarget,
                direction: direction
            });
            return $.support.transition && this.$element.hasClass("slide") ? ($next.addClass(type), 
            "object" == typeof $next && $next.length && $next[0].offsetWidth, $active.addClass(direction), 
            $next.addClass(direction), $active.one("bsTransitionEnd", function() {
                $next.removeClass([ type, direction ].join(" ")).addClass("active"), $active.removeClass([ "active", direction ].join(" ")), 
                that.sliding = !1, setTimeout(function() {
                    that.$element.trigger(slidEvent);
                }, 0);
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION)) : ($active.removeClass("active"), 
            $next.addClass("active"), this.sliding = !1, this.$element.trigger(slidEvent)), 
            isCycling && this.cycle(), this;
        }
    };
    var old = $.fn.carousel;
    function clickHandler(e) {
        var slideIndex = $(this), $target = ($target = slideIndex.attr("href")) && $target.replace(/.*(?=#[^\s]+$)/, ""), options = slideIndex.attr("data-target") || $target;
        ($target = $(document).find(options)).hasClass("carousel") && (options = $.extend({}, $target.data(), slideIndex.data()), 
        (slideIndex = slideIndex.attr("data-slide-to")) && (options.interval = !1), Plugin.call($target, options), 
        slideIndex && $target.data("bs.carousel").to(slideIndex), e.preventDefault());
    }
    $.fn.carousel = Plugin, $.fn.carousel.Constructor = Carousel, $.fn.carousel.noConflict = function() {
        return $.fn.carousel = old, this;
    }, $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler), 
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data());
        });
    });
}(jQuery), function($) {
    "use strict";
    var Collapse = function(element, options) {
        this.$element = $(element), this.options = $.extend({}, Collapse.DEFAULTS, options), 
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],[data-toggle="collapse"][data-target="#' + element.id + '"]'), 
        this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), 
        this.options.toggle && this.toggle();
    };
    function getTargetFromTrigger($trigger) {
        var target = $trigger.attr("data-target") || (target = $trigger.attr("href")) && target.replace(/.*(?=#[^\s]+$)/, "");
        return $(document).find(target);
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.collapse"), options = $.extend({}, Collapse.DEFAULTS, $this.data(), "object" == typeof option && option);
            !data && options.toggle && /show|hide/.test(option) && (options.toggle = !1), data || $this.data("bs.collapse", data = new Collapse(this, options)), 
            "string" == typeof option && data[option]();
        });
    }
    Collapse.VERSION = "3.4.1", Collapse.TRANSITION_DURATION = 350, Collapse.DEFAULTS = {
        toggle: !0
    }, Collapse.prototype.dimension = function() {
        return this.$element.hasClass("width") ? "width" : "height";
    }, Collapse.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var scrollSize = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(scrollSize && scrollSize.length && (complete = scrollSize.data("bs.collapse")) && complete.transitioning)) {
                var startEvent = $.Event("show.bs.collapse");
                if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                    scrollSize && scrollSize.length && (Plugin.call(scrollSize, "hide"), complete || scrollSize.data("bs.collapse", null));
                    var dimension = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", !0), 
                    this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var complete = function() {
                        this.$element.removeClass("collapsing").addClass("collapse in")[dimension](""), 
                        this.transitioning = 0, this.$element.trigger("shown.bs.collapse");
                    };
                    if (!$.support.transition) return complete.call(this);
                    scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
                    this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
                }
            }
        }
    }, Collapse.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var complete = $.Event("hide.bs.collapse");
            if (this.$element.trigger(complete), !complete.isDefaultPrevented()) {
                var dimension = this.dimension();
                this.$element[dimension](this.$element[dimension]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), 
                this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                complete = function() {
                    this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
                };
                if (!$.support.transition) return complete.call(this);
                this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
            }
        }
    }, Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    }, Collapse.prototype.getParent = function() {
        return $(document).find(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, $element) {
            $element = $($element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    }, Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen), $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    var old = $.fn.collapse;
    $.fn.collapse = Plugin, $.fn.collapse.Constructor = Collapse, $.fn.collapse.noConflict = function() {
        return $.fn.collapse = old, this;
    }, $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function($target) {
        var option = $(this);
        option.attr("data-target") || $target.preventDefault();
        $target = getTargetFromTrigger(option), option = $target.data("bs.collapse") ? "toggle" : option.data();
        Plugin.call($target, option);
    });
}(jQuery), function($) {
    "use strict";
    function Dropdown(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    }
    var toggle = '[data-toggle="dropdown"]';
    function getParent($this) {
        var $parent = $this.attr("data-target"), $parent = "#" !== ($parent = $parent || ($parent = $this.attr("href")) && /#[A-Za-z]/.test($parent) && $parent.replace(/.*(?=#[^\s]*$)/, "")) ? $(document).find($parent) : null;
        return $parent && $parent.length ? $parent : $this.parent();
    }
    function clearMenus(e) {
        e && 3 === e.which || ($(".dropdown-backdrop").remove(), $(toggle).each(function() {
            var $this = $(this), $parent = getParent($this), relatedTarget = {
                relatedTarget: this
            };
            $parent.hasClass("open") && (e && "click" == e.type && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target) || ($parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget)), 
            e.isDefaultPrevented() || ($this.attr("aria-expanded", "false"), $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget)))));
        }));
    }
    Dropdown.VERSION = "3.4.1", Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if (!$this.is(".disabled, :disabled")) {
            var $parent = getParent($this), relatedTarget = $parent.hasClass("open");
            if (clearMenus(), !relatedTarget) {
                "ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length && $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
                relatedTarget = {
                    relatedTarget: this
                };
                if ($parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget)), e.isDefaultPrevented()) return;
                $this.trigger("focus").attr("aria-expanded", "true"), $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget));
            }
            return !1;
        }
    }, Dropdown.prototype.keydown = function(e) {
        if (/(38|40|27|32)/.test(e.which) && !/input|textarea/i.test(e.target.tagName)) {
            var $items = $(this);
            if (e.preventDefault(), e.stopPropagation(), !$items.is(".disabled, :disabled")) {
                var index = getParent($items), isActive = index.hasClass("open");
                if (!isActive && 27 != e.which || isActive && 27 == e.which) return 27 == e.which && index.find(toggle).trigger("focus"), 
                $items.trigger("click");
                $items = index.find(".dropdown-menu li:not(.disabled):visible a");
                $items.length && (index = $items.index(e.target), 38 == e.which && 0 < index && index--, 
                40 == e.which && index < $items.length - 1 && index++, ~index || (index = 0), $items.eq(index).trigger("focus"));
            }
        }
    };
    var old = $.fn.dropdown;
    $.fn.dropdown = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.dropdown");
            data || $this.data("bs.dropdown", data = new Dropdown(this)), "string" == typeof option && data[option].call($this);
        });
    }, $.fn.dropdown.Constructor = Dropdown, $.fn.dropdown.noConflict = function() {
        return $.fn.dropdown = old, this;
    }, $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown);
}(jQuery), function($) {
    "use strict";
    function Modal(element, options) {
        this.options = options, this.$body = $(document.body), this.$element = $(element), 
        this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, 
        this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, 
        this.fixedContent = ".navbar-fixed-top, .navbar-fixed-bottom", this.options.remote && this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
            this.$element.trigger("loaded.bs.modal");
        }, this));
    }
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.modal"), options = $.extend({}, Modal.DEFAULTS, $this.data(), "object" == typeof option && option);
            data || $this.data("bs.modal", data = new Modal(this, options)), "string" == typeof option ? data[option](_relatedTarget) : options.show && data.show(_relatedTarget);
        });
    }
    Modal.VERSION = "3.4.1", Modal.TRANSITION_DURATION = 300, Modal.BACKDROP_TRANSITION_DURATION = 150, 
    Modal.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    }, Modal.prototype.show = function(_relatedTarget) {
        var that = this, e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, 
        this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), 
        this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this)), 
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                $(e.target).is(that.$element) && (that.ignoreBackdropClick = !0);
            });
        }), this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            that.$element.parent().length || that.$element.appendTo(that.$body), that.$element.show().scrollTop(0), 
            that.adjustDialog(), transition && that.$element[0].offsetWidth, that.$element.addClass("in"), 
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        }));
    }, Modal.prototype.hide = function(e) {
        e && e.preventDefault(), e = $.Event("hide.bs.modal"), this.$element.trigger(e), 
        this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), 
        $(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), 
        this.$dialog.off("mousedown.dismiss.bs.modal"), $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal());
    }, Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            document === e.target || this.$element[0] === e.target || this.$element.has(e.target).length || this.$element.trigger("focus");
        }, this));
    }, Modal.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
            27 == e.which && this.hide();
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal");
    }, Modal.prototype.resize = function() {
        this.isShown ? $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this)) : $(window).off("resize.bs.modal");
    }, Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide(), this.backdrop(function() {
            that.$body.removeClass("modal-open"), that.resetAdjustments(), that.resetScrollbar(), 
            that.$element.trigger("hidden.bs.modal");
        });
    }, Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
    }, Modal.prototype.backdrop = function(callback) {
        var callbackRemove, that = this, animate = this.$element.hasClass("fade") ? "fade" : "";
        this.isShown && this.options.backdrop ? (callbackRemove = $.support.transition && animate, 
        this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body), 
        this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
            this.ignoreBackdropClick ? this.ignoreBackdropClick = !1 : e.target === e.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide());
        }, this)), callbackRemove && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), 
        callback && (callbackRemove ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback())) : !this.isShown && this.$backdrop ? (this.$backdrop.removeClass("in"), 
        callbackRemove = function() {
            that.removeBackdrop(), callback && callback();
        }, $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove()) : callback && callback();
    }, Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
    }, Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    }, Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    }, Modal.prototype.checkScrollbar = function() {
        var documentElementRect, fullWindowWidth = window.innerWidth;
        fullWindowWidth || (fullWindowWidth = (documentElementRect = document.documentElement.getBoundingClientRect()).right - Math.abs(documentElementRect.left)), 
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth, this.scrollbarWidth = this.measureScrollbar();
    }, Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "";
        var scrollbarWidth = this.scrollbarWidth;
        this.bodyIsOverflowing && (this.$body.css("padding-right", bodyPad + scrollbarWidth), 
        $(this.fixedContent).each(function(index, element) {
            var actualPadding = element.style.paddingRight, calculatedPadding = $(element).css("padding-right");
            $(element).data("padding-right", actualPadding).css("padding-right", parseFloat(calculatedPadding) + scrollbarWidth + "px");
        }));
    }, Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad), $(this.fixedContent).each(function(index, element) {
            var padding = $(element).data("padding-right");
            $(element).removeData("padding-right"), element.style.paddingRight = padding || "";
        });
    }, Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure", this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        return this.$body[0].removeChild(scrollDiv), scrollbarWidth;
    };
    var old = $.fn.modal;
    $.fn.modal = Plugin, $.fn.modal.Constructor = Modal, $.fn.modal.noConflict = function() {
        return $.fn.modal = old, this;
    }, $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this), option = $this.attr("href"), target = $this.attr("data-target") || option && option.replace(/.*(?=#[^\s]+$)/, ""), $target = $(document).find(target), option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(option) && option
        }, $target.data(), $this.data());
        $this.is("a") && e.preventDefault(), $target.one("show.bs.modal", function(showEvent) {
            showEvent.isDefaultPrevented() || $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        }), Plugin.call($target, option, this);
    });
}(jQuery), function($) {
    "use strict";
    var DISALLOWED_ATTRIBUTES = [ "sanitize", "whiteList", "sanitizeFn" ], uriAttrs = [ "background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href" ], DefaultWhitelist = {
        "*": [ "class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i ],
        a: [ "target", "href", "title", "rel" ],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: [ "src", "alt", "title", "width", "height" ],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    }, SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;
    function sanitizeHtml(unsafeHtml, whiteList, createdDocument) {
        if (0 === unsafeHtml.length) return unsafeHtml;
        if (createdDocument && "function" == typeof createdDocument) return createdDocument(unsafeHtml);
        if (!document.implementation || !document.implementation.createHTMLDocument) return unsafeHtml;
        createdDocument = document.implementation.createHTMLDocument("sanitization");
        createdDocument.body.innerHTML = unsafeHtml;
        for (var whitelistKeys = $.map(whiteList, function(el, i) {
            return i;
        }), elements = $(createdDocument.body).find("*"), i = 0, len = elements.length; i < len; i++) {
            var el = elements[i], elName = el.nodeName.toLowerCase();
            if (-1 !== $.inArray(elName, whitelistKeys)) for (var attributeList = $.map(el.attributes, function(el) {
                return el;
            }), whitelistedAttributes = [].concat(whiteList["*"] || [], whiteList[elName] || []), j = 0, len2 = attributeList.length; j < len2; j++) !function(attr, allowedAttributeList) {
                var attrName = attr.nodeName.toLowerCase();
                if (-1 !== $.inArray(attrName, allowedAttributeList)) return -1 === $.inArray(attrName, uriAttrs) || Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
                for (var regExp = $(allowedAttributeList).filter(function(index, value) {
                    return value instanceof RegExp;
                }), i = 0, l = regExp.length; i < l; i++) if (attrName.match(regExp[i])) return 1;
            }(attributeList[j], whitelistedAttributes) && el.removeAttribute(attributeList[j].nodeName); else el.parentNode.removeChild(el);
        }
        return createdDocument.body.innerHTML;
    }
    function Tooltip(element, options) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, 
        this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", element, options);
    }
    Tooltip.VERSION = "3.4.1", Tooltip.TRANSITION_DURATION = 150, Tooltip.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {
            selector: "body",
            padding: 0
        },
        sanitize: !0,
        sanitizeFn: null,
        whiteList: DefaultWhitelist
    }, Tooltip.prototype.init = function(type, element, options) {
        if (this.enabled = !0, this.type = type, this.$element = $(element), this.options = this.getOptions(options), 
        this.$viewport = this.options.viewport && $(document).find($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), 
        this.inState = {
            click: !1,
            hover: !1,
            focus: !1
        }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var triggers = this.options.trigger.split(" "), i = triggers.length; i--; ) {
            var eventIn, eventOut = triggers[i];
            "click" == eventOut ? this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this)) : "manual" != eventOut && (eventIn = "hover" == eventOut ? "mouseenter" : "focusin", 
            eventOut = "hover" == eventOut ? "mouseleave" : "focusout", this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this)), 
            this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this)));
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    }, Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    }, Tooltip.prototype.getOptions = function(options) {
        var dataAttr, dataAttributes = this.$element.data();
        for (dataAttr in dataAttributes) dataAttributes.hasOwnProperty(dataAttr) && -1 !== $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) && delete dataAttributes[dataAttr];
        return (options = $.extend({}, this.getDefaults(), dataAttributes, options)).delay && "number" == typeof options.delay && (options.delay = {
            show: options.delay,
            hide: options.delay
        }), options.sanitize && (options.template = sanitizeHtml(options.template, options.whiteList, options.sanitizeFn)), 
        options;
    }, Tooltip.prototype.getDelegateOptions = function() {
        var options = {}, defaults = this.getDefaults();
        return this._options && $.each(this._options, function(key, value) {
            defaults[key] != value && (options[key] = value);
        }), options;
    }, Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (self || (self = new this.constructor(obj.currentTarget, this.getDelegateOptions()), 
        $(obj.currentTarget).data("bs." + this.type, self)), obj instanceof $.Event && (self.inState["focusin" == obj.type ? "focus" : "hover"] = !0), 
        self.tip().hasClass("in") || "in" == self.hoverState) self.hoverState = "in"; else {
            if (clearTimeout(self.timeout), self.hoverState = "in", !self.options.delay || !self.options.delay.show) return self.show();
            self.timeout = setTimeout(function() {
                "in" == self.hoverState && self.show();
            }, self.options.delay.show);
        }
    }, Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) if (this.inState[key]) return !0;
        return !1;
    }, Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (self || (self = new this.constructor(obj.currentTarget, this.getDelegateOptions()), 
        $(obj.currentTarget).data("bs." + this.type, self)), obj instanceof $.Event && (self.inState["focusout" == obj.type ? "focus" : "hover"] = !1), 
        !self.isInStateTrue()) {
            if (clearTimeout(self.timeout), self.hoverState = "out", !self.options.delay || !self.options.delay.hide) return self.hide();
            self.timeout = setTimeout(function() {
                "out" == self.hoverState && self.hide();
            }, self.options.delay.hide);
        }
    }, Tooltip.prototype.show = function() {
        var that, $tip, actualWidth, orgPlacement, viewportDim, calculatedOffset, complete, pos = $.Event("show.bs." + this.type);
        this.hasContent() && this.enabled && (this.$element.trigger(pos), actualWidth = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]), 
        !pos.isDefaultPrevented() && actualWidth && ($tip = (that = this).tip(), calculatedOffset = this.getUID(this.type), 
        this.setContent(), $tip.attr("id", calculatedOffset), this.$element.attr("aria-describedby", calculatedOffset), 
        this.options.animation && $tip.addClass("fade"), complete = "function" == typeof this.options.placement ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement, 
        (viewportDim = (orgPlacement = /\s?auto?\s?/i).test(complete)) && (complete = complete.replace(orgPlacement, "") || "top"), 
        $tip.detach().css({
            top: 0,
            left: 0,
            display: "block"
        }).addClass(complete).data("bs." + this.type, this), this.options.container ? $tip.appendTo($(document).find(this.options.container)) : $tip.insertAfter(this.$element), 
        this.$element.trigger("inserted.bs." + this.type), pos = this.getPosition(), actualWidth = $tip[0].offsetWidth, 
        calculatedOffset = $tip[0].offsetHeight, viewportDim && (orgPlacement = complete, 
        viewportDim = this.getPosition(this.$viewport), complete = "bottom" == complete && pos.bottom + calculatedOffset > viewportDim.bottom ? "top" : "top" == complete && pos.top - calculatedOffset < viewportDim.top ? "bottom" : "right" == complete && pos.right + actualWidth > viewportDim.width ? "left" : "left" == complete && pos.left - actualWidth < viewportDim.left ? "right" : complete, 
        $tip.removeClass(orgPlacement).addClass(complete)), calculatedOffset = this.getCalculatedOffset(complete, pos, actualWidth, calculatedOffset), 
        this.applyPlacement(calculatedOffset, complete), complete = function() {
            var prevHoverState = that.hoverState;
            that.$element.trigger("shown.bs." + that.type), that.hoverState = null, "out" == prevHoverState && that.leave(that);
        }, $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete()));
    }, Tooltip.prototype.applyPlacement = function(offset, isVertical) {
        var $tip = this.tip(), width = $tip[0].offsetWidth, arrowDelta = $tip[0].offsetHeight, arrowOffsetPosition = parseInt($tip.css("margin-top"), 10), delta = parseInt($tip.css("margin-left"), 10);
        isNaN(arrowOffsetPosition) && (arrowOffsetPosition = 0), isNaN(delta) && (delta = 0), 
        offset.top += arrowOffsetPosition, offset.left += delta, $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0), $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth, arrowOffsetPosition = $tip[0].offsetHeight;
        "top" == isVertical && arrowOffsetPosition != arrowDelta && (offset.top = offset.top + arrowDelta - arrowOffsetPosition);
        delta = this.getViewportAdjustedDelta(isVertical, offset, actualWidth, arrowOffsetPosition);
        delta.left ? offset.left += delta.left : offset.top += delta.top;
        isVertical = /top|bottom/.test(isVertical), arrowDelta = isVertical ? 2 * delta.left - width + actualWidth : 2 * delta.top - arrowDelta + arrowOffsetPosition, 
        arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset), this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    }, Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "");
    }, Tooltip.prototype.setContent = function() {
        var $tip = this.tip(), title = this.getTitle();
        this.options.html ? (this.options.sanitize && (title = sanitizeHtml(title, this.options.whiteList, this.options.sanitizeFn)), 
        $tip.find(".tooltip-inner").html(title)) : $tip.find(".tooltip-inner").text(title), 
        $tip.removeClass("fade in top bottom left right");
    }, Tooltip.prototype.hide = function(callback) {
        var that = this, $tip = $(this.$tip), e = $.Event("hide.bs." + this.type);
        function complete() {
            "in" != that.hoverState && $tip.detach(), that.$element && that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type), 
            callback && callback();
        }
        if (this.$element.trigger(e), !e.isDefaultPrevented()) return $tip.removeClass("in"), 
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete(), 
        this.hoverState = null, this;
    }, Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        !$e.attr("title") && "string" == typeof $e.attr("data-original-title") || $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
    }, Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    }, Tooltip.prototype.getPosition = function(scroll) {
        var elOffset = (scroll = scroll || this.$element)[0], outerDims = "BODY" == elOffset.tagName, elRect = elOffset.getBoundingClientRect();
        null == elRect.width && (elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
        }));
        elOffset = window.SVGElement && elOffset instanceof window.SVGElement, elOffset = outerDims ? {
            top: 0,
            left: 0
        } : elOffset ? null : scroll.offset(), scroll = {
            scroll: outerDims ? document.documentElement.scrollTop || document.body.scrollTop : scroll.scrollTop()
        }, outerDims = outerDims ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    }, Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return "bottom" == placement ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "top" == placement ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "left" == placement ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    }, Tooltip.prototype.getViewportAdjustedDelta = function(topEdgeOffset, pos, rightEdgeOffset, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var leftEdgeOffset, viewportPadding = this.options.viewport && this.options.viewport.padding || 0, viewportDimensions = this.getPosition(this.$viewport);
        return /right|left/.test(topEdgeOffset) ? (topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll, 
        leftEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight, 
        topEdgeOffset < viewportDimensions.top ? delta.top = viewportDimensions.top - topEdgeOffset : leftEdgeOffset > viewportDimensions.top + viewportDimensions.height && (delta.top = viewportDimensions.top + viewportDimensions.height - leftEdgeOffset)) : (leftEdgeOffset = pos.left - viewportPadding, 
        rightEdgeOffset = pos.left + viewportPadding + rightEdgeOffset, leftEdgeOffset < viewportDimensions.left ? delta.left = viewportDimensions.left - leftEdgeOffset : rightEdgeOffset > viewportDimensions.right && (delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset)), 
        delta;
    }, Tooltip.prototype.getTitle = function() {
        var $e = this.$element, o = this.options;
        return $e.attr("data-original-title") || ("function" == typeof o.title ? o.title.call($e[0]) : o.title);
    }, Tooltip.prototype.getUID = function(prefix) {
        for (;prefix += ~~(1e6 * Math.random()), document.getElementById(prefix); ) ;
        return prefix;
    }, Tooltip.prototype.tip = function() {
        if (!this.$tip && (this.$tip = $(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip;
    }, Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    }, Tooltip.prototype.enable = function() {
        this.enabled = !0;
    }, Tooltip.prototype.disable = function() {
        this.enabled = !1;
    }, Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    }, Tooltip.prototype.toggle = function(e) {
        var self = this;
        e && ((self = $(e.currentTarget).data("bs." + this.type)) || (self = new this.constructor(e.currentTarget, this.getDelegateOptions()), 
        $(e.currentTarget).data("bs." + this.type, self))), e ? (self.inState.click = !self.inState.click, 
        self.isInStateTrue() ? self.enter(self) : self.leave(self)) : self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
    }, Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout), this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type), that.$tip && that.$tip.detach(), 
            that.$tip = null, that.$arrow = null, that.$viewport = null, that.$element = null;
        });
    }, Tooltip.prototype.sanitizeHtml = function(unsafeHtml) {
        return sanitizeHtml(unsafeHtml, this.options.whiteList, this.options.sanitizeFn);
    };
    var old = $.fn.tooltip;
    $.fn.tooltip = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.tooltip"), options = "object" == typeof option && option;
            !data && /destroy|hide/.test(option) || (data || $this.data("bs.tooltip", data = new Tooltip(this, options)), 
            "string" == typeof option && data[option]());
        });
    }, $.fn.tooltip.Constructor = Tooltip, $.fn.tooltip.noConflict = function() {
        return $.fn.tooltip = old, this;
    };
}(jQuery), function($) {
    "use strict";
    function Popover(element, options) {
        this.init("popover", element, options);
    }
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.4.1", Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), ((Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)).constructor = Popover).prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    }, Popover.prototype.setContent = function() {
        var typeContent, $tip = this.tip(), title = this.getTitle(), content = this.getContent();
        this.options.html ? (typeContent = typeof content, this.options.sanitize && (title = this.sanitizeHtml(title), 
        "string" == typeContent && (content = this.sanitizeHtml(content))), $tip.find(".popover-title").html(title), 
        $tip.find(".popover-content").children().detach().end()["string" == typeContent ? "html" : "append"](content)) : ($tip.find(".popover-title").text(title), 
        $tip.find(".popover-content").children().detach().end().text(content)), $tip.removeClass("fade top bottom left right in"), 
        $tip.find(".popover-title").html() || $tip.find(".popover-title").hide();
    }, Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    }, Popover.prototype.getContent = function() {
        var $e = this.$element, o = this.options;
        return $e.attr("data-content") || ("function" == typeof o.content ? o.content.call($e[0]) : o.content);
    }, Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    var old = $.fn.popover;
    $.fn.popover = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.popover"), options = "object" == typeof option && option;
            !data && /destroy|hide/.test(option) || (data || $this.data("bs.popover", data = new Popover(this, options)), 
            "string" == typeof option && data[option]());
        });
    }, $.fn.popover.Constructor = Popover, $.fn.popover.noConflict = function() {
        return $.fn.popover = old, this;
    };
}(jQuery), function($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body), this.$scrollElement = $(element).is(document.body) ? $(window) : $(element), 
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options), this.selector = (this.options.target || "") + " .nav li > a", 
        this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, 
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this)), this.refresh(), 
        this.process();
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.scrollspy"), options = "object" == typeof option && option;
            data || $this.data("bs.scrollspy", data = new ScrollSpy(this, options)), "string" == typeof option && data[option]();
        });
    }
    ScrollSpy.VERSION = "3.4.1", ScrollSpy.DEFAULTS = {
        offset: 10
    }, ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
    }, ScrollSpy.prototype.refresh = function() {
        var that = this, offsetMethod = "offset", offsetBase = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), 
        $.isWindow(this.$scrollElement[0]) || (offsetMethod = "position", offsetBase = this.$scrollElement.scrollTop()), 
        this.$body.find(this.selector).map(function() {
            var $href = $(this), href = $href.data("target") || $href.attr("href"), $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") ? [ [ $href[offsetMethod]().top + offsetBase, href ] ] : null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            that.offsets.push(this[0]), that.targets.push(this[1]);
        });
    }, ScrollSpy.prototype.process = function() {
        var i, scrollTop = this.$scrollElement.scrollTop() + this.options.offset, scrollHeight = this.getScrollHeight(), maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height(), offsets = this.offsets, targets = this.targets, activeTarget = this.activeTarget;
        if (this.scrollHeight != scrollHeight && this.refresh(), maxScroll <= scrollTop) return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        if (activeTarget && scrollTop < offsets[0]) return this.activeTarget = null, this.clear();
        for (i = offsets.length; i--; ) activeTarget != targets[i] && scrollTop >= offsets[i] && (void 0 === offsets[i + 1] || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
    }, ScrollSpy.prototype.activate = function(active) {
        this.activeTarget = active, this.clear();
        active = this.selector + '[data-target="' + active + '"],' + this.selector + '[href="' + active + '"]', 
        active = $(active).parents("li").addClass("active");
        (active = active.parent(".dropdown-menu").length ? active.closest("li.dropdown").addClass("active") : active).trigger("activate.bs.scrollspy");
    }, ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
    };
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin, $.fn.scrollspy.Constructor = ScrollSpy, $.fn.scrollspy.noConflict = function() {
        return $.fn.scrollspy = old, this;
    }, $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data());
        });
    });
}(jQuery), function($) {
    "use strict";
    function Tab(element) {
        this.element = $(element);
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.tab");
            data || $this.data("bs.tab", data = new Tab(this)), "string" == typeof option && data[option]();
        });
    }
    Tab.VERSION = "3.4.1", Tab.TRANSITION_DURATION = 150, Tab.prototype.show = function() {
        var $previous, hideEvent, showEvent, $this = this.element, $ul = $this.closest("ul:not(.dropdown-menu)"), $target = ($target = $this.data("target")) || ($target = $this.attr("href")) && $target.replace(/.*(?=#[^\s]*$)/, "");
        $this.parent("li").hasClass("active") || ($previous = $ul.find(".active:last a"), 
        hideEvent = $.Event("hide.bs.tab", {
            relatedTarget: $this[0]
        }), showEvent = $.Event("show.bs.tab", {
            relatedTarget: $previous[0]
        }), $previous.trigger(hideEvent), $this.trigger(showEvent), showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented() || ($target = $(document).find($target), 
        this.activate($this.closest("li"), $ul), this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: "hidden.bs.tab",
                relatedTarget: $this[0]
            }), $this.trigger({
                type: "shown.bs.tab",
                relatedTarget: $previous[0]
            });
        })));
    }, Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find("> .active"), transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), 
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), 
            transition ? (element[0].offsetWidth, element.addClass("in")) : element.removeClass("fade"), 
            element.parent(".dropdown-menu").length && element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), 
            callback && callback();
        }
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next(), 
        $active.removeClass("in");
    };
    var old = $.fn.tab;
    function clickHandler(e) {
        e.preventDefault(), Plugin.call($(this), "show");
    }
    $.fn.tab = Plugin, $.fn.tab.Constructor = Tab, $.fn.tab.noConflict = function() {
        return $.fn.tab = old, this;
    }, $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery), function($) {
    "use strict";
    var Affix = function(element, target) {
        this.options = $.extend({}, Affix.DEFAULTS, target);
        target = this.options.target === Affix.DEFAULTS.target ? $(this.options.target) : $(document).find(this.options.target);
        this.$target = target.on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this)), 
        this.$element = $(element), this.affixed = null, this.unpin = null, this.pinnedOffset = null, 
        this.checkPosition();
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.affix"), options = "object" == typeof option && option;
            data || $this.data("bs.affix", data = new Affix(this, options)), "string" == typeof option && data[option]();
        });
    }
    Affix.VERSION = "3.4.1", Affix.RESET = "affix affix-top affix-bottom", Affix.DEFAULTS = {
        offset: 0,
        target: window
    }, Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop(), colliderTop = this.$element.offset(), targetHeight = this.$target.height();
        if (null != offsetTop && "top" == this.affixed) return scrollTop < offsetTop && "top";
        if ("bottom" == this.affixed) return null != offsetTop ? !(scrollTop + this.unpin <= colliderTop.top) && "bottom" : !(scrollTop + targetHeight <= scrollHeight - offsetBottom) && "bottom";
        var initializing = null == this.affixed, colliderTop = initializing ? scrollTop : colliderTop.top;
        return null != offsetTop && scrollTop <= offsetTop ? "top" : null != offsetBottom && scrollHeight - offsetBottom <= colliderTop + (initializing ? targetHeight : height) && "bottom";
    }, Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop(), position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    }, Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    }, Affix.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var height = this.$element.height(), affixType = this.options.offset, e = affixType.top, offsetBottom = affixType.bottom, scrollHeight = Math.max($(document).height(), $(document.body).height());
            "object" != typeof affixType && (offsetBottom = e = affixType), "function" == typeof e && (e = affixType.top(this.$element)), 
            "function" == typeof offsetBottom && (offsetBottom = affixType.bottom(this.$element));
            var affix = this.getState(scrollHeight, height, e, offsetBottom);
            if (this.affixed != affix) {
                null != this.unpin && this.$element.css("top", "");
                affixType = "affix" + (affix ? "-" + affix : ""), e = $.Event(affixType + ".bs.affix");
                if (this.$element.trigger(e), e.isDefaultPrevented()) return;
                this.affixed = affix, this.unpin = "bottom" == affix ? this.getPinnedOffset() : null, 
                this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
            }
            "bottom" == affix && this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    var old = $.fn.affix;
    $.fn.affix = Plugin, $.fn.affix.Constructor = Affix, $.fn.affix.noConflict = function() {
        return $.fn.affix = old, this;
    }, $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this), data = $spy.data();
            data.offset = data.offset || {}, null != data.offsetBottom && (data.offset.bottom = data.offsetBottom), 
            null != data.offsetTop && (data.offset.top = data.offsetTop), Plugin.call($spy, data);
        });
    });
}(jQuery), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define("underscore", factory) : (global = global || self, 
    function() {
        var current = global._, exports = global._ = factory();
        exports.noConflict = function() {
            return global._ = current, exports;
        };
    }());
}(this, function() {
    var once = "object" == typeof self && self.self === self && self || "object" == typeof global && global.global === global && global || Function("return this")() || {}, ArrayProto = Array.prototype, ObjProto = Object.prototype, SymbolProto = "undefined" != typeof Symbol ? Symbol.prototype : null, push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty, indexBy = "undefined" != typeof ArrayBuffer, reduce = "undefined" != typeof DataView, groupBy = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = indexBy && ArrayBuffer.isView, _isNaN = isNaN, _isFinite = isFinite, hasEnumBug = !{
        toString: null
    }.propertyIsEnumerable("toString"), nonEnumerableProps = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ], MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    function restArguments(func, startIndex) {
        return startIndex = null == startIndex ? func.length - 1 : +startIndex, function() {
            for (var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0; index < length; index++) rest[index] = arguments[index + startIndex];
            switch (startIndex) {
              case 0:
                return func.call(this, rest);

              case 1:
                return func.call(this, arguments[0], rest);

              case 2:
                return func.call(this, arguments[0], arguments[1], rest);
            }
            for (var args = Array(startIndex + 1), index = 0; index < startIndex; index++) args[index] = arguments[index];
            return args[startIndex] = rest, func.apply(this, args);
        };
    }
    function isObject(obj) {
        var type = typeof obj;
        return "function" == type || "object" == type && !!obj;
    }
    function isUndefined(obj) {
        return void 0 === obj;
    }
    function isBoolean(obj) {
        return !0 === obj || !1 === obj || "[object Boolean]" === toString.call(obj);
    }
    function tagTester(name) {
        var tag = "[object " + name + "]";
        return function(obj) {
            return toString.call(obj) === tag;
        };
    }
    var isString = tagTester("String"), isNumber = tagTester("Number"), isDate = tagTester("Date"), isRegExp = tagTester("RegExp"), isError = tagTester("Error"), isSymbol = tagTester("Symbol"), isArrayBuffer = tagTester("ArrayBuffer"), lastIndexOf = tagTester("Function"), findLastIndex = once.document && once.document.childNodes, isFunction$1 = lastIndexOf = "function" != typeof /./ && "object" != typeof Int8Array && "function" != typeof findLastIndex ? function(obj) {
        return "function" == typeof obj || !1;
    } : lastIndexOf, reduceRight = tagTester("Object"), hasStringTagBug = reduce && reduceRight(new DataView(new ArrayBuffer(8))), without = "undefined" != typeof Map && reduceRight(new Map()), invoke = tagTester("DataView");
    var isDataView$1 = hasStringTagBug ? function(obj) {
        return null != obj && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
    } : invoke, isArray = groupBy || tagTester("Array");
    function has(obj, key) {
        return null != obj && hasOwnProperty.call(obj, key);
    }
    var isArguments = tagTester("Arguments");
    !function() {
        isArguments(arguments) || (isArguments = function(obj) {
            return has(obj, "callee");
        });
    }();
    var isArguments$1 = isArguments;
    function isNaN$1(obj) {
        return isNumber(obj) && _isNaN(obj);
    }
    function constant(value) {
        return function() {
            return value;
        };
    }
    function createSizePropertyCheck(getSizeProperty) {
        return function(sizeProperty) {
            sizeProperty = getSizeProperty(sizeProperty);
            return "number" == typeof sizeProperty && 0 <= sizeProperty && sizeProperty <= MAX_ARRAY_INDEX;
        };
    }
    function shallowProperty(key) {
        return function(obj) {
            return null == obj ? void 0 : obj[key];
        };
    }
    var getByteLength = shallowProperty("byteLength"), isBufferLike = createSizePropertyCheck(getByteLength), typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    var isTypedArray$1 = indexBy ? function(obj) {
        return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
    } : constant(!1), getLength = shallowProperty("length");
    function collectNonEnumProps(obj, keys) {
        keys = function(keys) {
            for (var hash = {}, l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = !0;
            return {
                contains: function(key) {
                    return hash[key];
                },
                push: function(key) {
                    return hash[key] = !0, keys.push(key);
                }
            };
        }(keys);
        var nonEnumIdx = nonEnumerableProps.length, constructor = obj.constructor, proto = isFunction$1(constructor) && constructor.prototype || ObjProto, prop = "constructor";
        for (has(obj, prop) && !keys.contains(prop) && keys.push(prop); nonEnumIdx--; ) (prop = nonEnumerableProps[nonEnumIdx]) in obj && obj[prop] !== proto[prop] && !keys.contains(prop) && keys.push(prop);
    }
    function keys(obj) {
        if (!isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var key, keys = [];
        for (key in obj) has(obj, key) && keys.push(key);
        return hasEnumBug && collectNonEnumProps(obj, keys), keys;
    }
    function isMatch(object, attrs) {
        var _keys = keys(attrs), length = _keys.length;
        if (null == object) return !length;
        for (var obj = Object(object), i = 0; i < length; i++) {
            var key = _keys[i];
            if (attrs[key] !== obj[key] || !(key in obj)) return !1;
        }
        return !0;
    }
    function _(obj) {
        return obj instanceof _ ? obj : this instanceof _ ? void (this._wrapped = obj) : new _(obj);
    }
    function toBufferView(bufferSource) {
        return new Uint8Array(bufferSource.buffer || bufferSource, bufferSource.byteOffset || 0, getByteLength(bufferSource));
    }
    _.VERSION = "1.12.1", _.prototype.valueOf = _.prototype.toJSON = _.prototype.value = function() {
        return this._wrapped;
    }, _.prototype.toString = function() {
        return String(this._wrapped);
    };
    var tagDataView = "[object DataView]";
    function eq(a, b, aStack, bStack) {
        if (a === b) return 0 !== a || 1 / a == 1 / b;
        if (null == a || null == b) return !1;
        if (a != a) return b != b;
        var type = typeof a;
        return ("function" == type || "object" == type || "object" == typeof b) && function deepEq(a, b, aStack, bStack) {
            a instanceof _ && (a = a._wrapped);
            b instanceof _ && (b = b._wrapped);
            var aCtor = toString.call(a);
            if (aCtor !== toString.call(b)) return !1;
            if (hasStringTagBug && "[object Object]" == aCtor && isDataView$1(a)) {
                if (!isDataView$1(b)) return !1;
                aCtor = tagDataView;
            }
            switch (aCtor) {
              case "[object RegExp]":
              case "[object String]":
                return "" + a == "" + b;

              case "[object Number]":
                return +a != +a ? +b != +b : 0 == +a ? 1 / +a == 1 / b : +a == +b;

              case "[object Date]":
              case "[object Boolean]":
                return +a == +b;

              case "[object Symbol]":
                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);

              case "[object ArrayBuffer]":
              case tagDataView:
                return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
            }
            var areArrays = "[object Array]" === aCtor;
            if (!areArrays && isTypedArray$1(a)) {
                var bCtor = getByteLength(a);
                if (bCtor !== getByteLength(b)) return !1;
                if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return !0;
                areArrays = !0;
            }
            if (!areArrays) {
                if ("object" != typeof a || "object" != typeof b) return !1;
                var aCtor = a.constructor, bCtor = b.constructor;
                if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) return !1;
            }
            aStack = aStack || [];
            bStack = bStack || [];
            var length = aStack.length;
            for (;length--; ) if (aStack[length] === a) return bStack[length] === b;
            aStack.push(a);
            bStack.push(b);
            if (areArrays) {
                if ((length = a.length) !== b.length) return !1;
                for (;length--; ) if (!eq(a[length], b[length], aStack, bStack)) return !1;
            } else {
                var key, _keys = keys(a);
                if (length = _keys.length, keys(b).length !== length) return !1;
                for (;length--; ) if (key = _keys[length], !has(b, key) || !eq(a[key], b[key], aStack, bStack)) return !1;
            }
            aStack.pop();
            bStack.pop();
            return !0;
        }(a, b, aStack, bStack);
    }
    function allKeys(obj) {
        if (!isObject(obj)) return [];
        var key, keys = [];
        for (key in obj) keys.push(key);
        return hasEnumBug && collectNonEnumProps(obj, keys), keys;
    }
    function ie11fingerprint(methods) {
        var length = getLength(methods);
        return function(obj) {
            if (null == obj) return !1;
            var keys = allKeys(obj);
            if (getLength(keys)) return !1;
            for (var i = 0; i < length; i++) if (!isFunction$1(obj[methods[i]])) return !1;
            return methods !== weakMapMethods || !isFunction$1(obj.forEach);
        };
    }
    var partition = [ "clear", "delete" ], countBy = [ "get", "has", "set" ], omit = partition.concat("forEach", countBy), weakMapMethods = partition.concat(countBy), union = [ "add" ].concat(partition, "forEach", "has"), isMap = without ? ie11fingerprint(omit) : tagTester("Map"), isWeakMap = without ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap"), isSet = without ? ie11fingerprint(union) : tagTester("Set"), isWeakSet = tagTester("WeakSet");
    function values(obj) {
        for (var _keys = keys(obj), length = _keys.length, values = Array(length), i = 0; i < length; i++) values[i] = obj[_keys[i]];
        return values;
    }
    function invert(obj) {
        for (var result = {}, _keys = keys(obj), i = 0, length = _keys.length; i < length; i++) result[obj[_keys[i]]] = _keys[i];
        return result;
    }
    function functions(obj) {
        var key, names = [];
        for (key in obj) isFunction$1(obj[key]) && names.push(key);
        return names.sort();
    }
    function createAssigner(keysFunc, defaults) {
        return function(obj) {
            var length = arguments.length;
            if (defaults && (obj = Object(obj)), length < 2 || null == obj) return obj;
            for (var index = 1; index < length; index++) for (var source = arguments[index], keys = keysFunc(source), l = keys.length, i = 0; i < l; i++) {
                var key = keys[i];
                defaults && void 0 !== obj[key] || (obj[key] = source[key]);
            }
            return obj;
        };
    }
    var extend = createAssigner(allKeys), extendOwn = createAssigner(keys), defaults = createAssigner(allKeys, !0);
    function baseCreate(result) {
        if (!isObject(result)) return {};
        if (nativeCreate) return nativeCreate(result);
        var Ctor = function() {};
        Ctor.prototype = result;
        result = new Ctor();
        return Ctor.prototype = null, result;
    }
    function clone(obj) {
        return isObject(obj) ? isArray(obj) ? obj.slice() : extend({}, obj) : obj;
    }
    function toPath(path) {
        return isArray(path) ? path : [ path ];
    }
    function toPath$1(path) {
        return _.toPath(path);
    }
    function deepGet(obj, path) {
        for (var length = path.length, i = 0; i < length; i++) {
            if (null == obj) return;
            obj = obj[path[i]];
        }
        return length ? obj : void 0;
    }
    function get(object, value, defaultValue) {
        value = deepGet(object, toPath$1(value));
        return void 0 === value ? defaultValue : value;
    }
    function identity(value) {
        return value;
    }
    function matcher(attrs) {
        return attrs = extendOwn({}, attrs), function(obj) {
            return isMatch(obj, attrs);
        };
    }
    function property(path) {
        return path = toPath$1(path), function(obj) {
            return deepGet(obj, path);
        };
    }
    function optimizeCb(func, context, argCount) {
        if (void 0 === context) return func;
        switch (null == argCount ? 3 : argCount) {
          case 1:
            return function(value) {
                return func.call(context, value);
            };

          case 3:
            return function(value, index, collection) {
                return func.call(context, value, index, collection);
            };

          case 4:
            return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
            };
        }
        return function() {
            return func.apply(context, arguments);
        };
    }
    function baseIteratee(value, context, argCount) {
        return null == value ? identity : isFunction$1(value) ? optimizeCb(value, context, argCount) : (isObject(value) && !isArray(value) ? matcher : property)(value);
    }
    function iteratee(value, context) {
        return baseIteratee(value, context, 1 / 0);
    }
    function cb(value, context, argCount) {
        return _.iteratee !== iteratee ? _.iteratee(value, context) : baseIteratee(value, context, argCount);
    }
    function noop() {}
    function random(min, max) {
        return null == max && (max = min, min = 0), min + Math.floor(Math.random() * (max - min + 1));
    }
    _.toPath = toPath, _.iteratee = iteratee;
    var now = Date.now || function() {
        return new Date().getTime();
    };
    function createEscaper(map) {
        function escaper(match) {
            return map[match];
        }
        var source = "(?:" + keys(map).join("|") + ")", testRegexp = RegExp(source), replaceRegexp = RegExp(source, "g");
        return function(string) {
            return string = null == string ? "" : "" + string, testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
    }
    var _$1 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, _escape = createEscaper(_$1), _unescape = createEscaper(invert(_$1)), templateSettings = _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    }, noMatch = /(.)^/, escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    function escapeChar(match) {
        return "\\" + escapes[match];
    }
    var bareIdentifier = /^\s*(\w|\$)+\s*$/;
    var idCounter = 0;
    function executeBound(sourceFunc, boundFunc, self, callingContext, result) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(self, result);
        self = baseCreate(sourceFunc.prototype), result = sourceFunc.apply(self, result);
        return isObject(result) ? result : self;
    }
    var partial = restArguments(function(func, boundArgs) {
        var placeholder = partial.placeholder, bound = function() {
            for (var position = 0, length = boundArgs.length, args = Array(length), i = 0; i < length; i++) args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
            for (;position < arguments.length; ) args.push(arguments[position++]);
            return executeBound(func, bound, this, this, args);
        };
        return bound;
    });
    partial.placeholder = _;
    var bind = restArguments(function(func, context, args) {
        if (!isFunction$1(func)) throw new TypeError("Bind must be called on a function");
        var bound = restArguments(function(callArgs) {
            return executeBound(func, bound, context, this, args.concat(callArgs));
        });
        return bound;
    }), isArrayLike = createSizePropertyCheck(getLength);
    function flatten(input, depth, strict, output) {
        if (output = output || [], depth || 0 === depth) {
            if (depth <= 0) return output.concat(input);
        } else depth = 1 / 0;
        for (var idx = output.length, i = 0, length = getLength(input); i < length; i++) {
            var value = input[i];
            if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) if (1 < depth) flatten(value, depth - 1, strict, output), 
            idx = output.length; else for (var j = 0, len = value.length; j < len; ) output[idx++] = value[j++]; else strict || (output[idx++] = value);
        }
        return output;
    }
    var bindAll = restArguments(function(obj, keys) {
        var index = (keys = flatten(keys, !1, !1)).length;
        if (index < 1) throw new Error("bindAll must be passed function names");
        for (;index--; ) {
            var key = keys[index];
            obj[key] = bind(obj[key], obj);
        }
        return obj;
    });
    var delay = restArguments(function(func, wait, args) {
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    }), defer = partial(delay, _, 1);
    function negate(predicate) {
        return function() {
            return !predicate.apply(this, arguments);
        };
    }
    function before(times, func) {
        var memo;
        return function() {
            return 0 < --times && (memo = func.apply(this, arguments)), times <= 1 && (func = null), 
            memo;
        };
    }
    once = partial(before, 2);
    function findKey(obj, predicate, context) {
        predicate = cb(predicate, context);
        for (var key, _keys = keys(obj), i = 0, length = _keys.length; i < length; i++) if (predicate(obj[key = _keys[i]], key, obj)) return key;
    }
    function createPredicateIndexFinder(dir) {
        return function(array, predicate, context) {
            predicate = cb(predicate, context);
            for (var length = getLength(array), index = 0 < dir ? 0 : length - 1; 0 <= index && index < length; index += dir) if (predicate(array[index], index, array)) return index;
            return -1;
        };
    }
    var findIndex = createPredicateIndexFinder(1), findLastIndex = createPredicateIndexFinder(-1);
    function sortedIndex(array, obj, iteratee, context) {
        for (var value = (iteratee = cb(iteratee, context, 1))(obj), low = 0, high = getLength(array); low < high; ) {
            var mid = Math.floor((low + high) / 2);
            iteratee(array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
    }
    function createIndexFinder(dir, predicateFind, sortedIndex) {
        return function(array, item, idx) {
            var i = 0, length = getLength(array);
            if ("number" == typeof idx) 0 < dir ? i = 0 <= idx ? idx : Math.max(idx + length, i) : length = 0 <= idx ? Math.min(idx + 1, length) : idx + length + 1; else if (sortedIndex && idx && length) return array[idx = sortedIndex(array, item)] === item ? idx : -1;
            if (item != item) return 0 <= (idx = predicateFind(slice.call(array, i, length), isNaN$1)) ? idx + i : -1;
            for (idx = 0 < dir ? i : length - 1; 0 <= idx && idx < length; idx += dir) if (array[idx] === item) return idx;
            return -1;
        };
    }
    var indexOf = createIndexFinder(1, findIndex, sortedIndex), lastIndexOf = createIndexFinder(-1, findLastIndex);
    function find(obj, predicate, key) {
        key = (isArrayLike(obj) ? findIndex : findKey)(obj, predicate, key);
        if (void 0 !== key && -1 !== key) return obj[key];
    }
    function each(obj, iteratee, context) {
        if (iteratee = optimizeCb(iteratee, context), isArrayLike(obj)) for (i = 0, length = obj.length; i < length; i++) iteratee(obj[i], i, obj); else for (var _keys = keys(obj), i = 0, length = _keys.length; i < length; i++) iteratee(obj[_keys[i]], _keys[i], obj);
        return obj;
    }
    function map(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        for (var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, results = Array(length), index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
    }
    function createReduce(dir) {
        return function(obj, iteratee, memo, context) {
            var initial = 3 <= arguments.length;
            return function(obj, iteratee, memo, initial) {
                var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index = 0 < dir ? 0 : length - 1;
                for (initial || (memo = obj[_keys ? _keys[index] : index], index += dir); 0 <= index && index < length; index += dir) {
                    var currentKey = _keys ? _keys[index] : index;
                    memo = iteratee(memo, obj[currentKey], currentKey, obj);
                }
                return memo;
            }(obj, optimizeCb(iteratee, context, 4), memo, initial);
        };
    }
    reduce = createReduce(1), reduceRight = createReduce(-1);
    function filter(obj, predicate, context) {
        var results = [];
        return predicate = cb(predicate, context), each(obj, function(value, index, list) {
            predicate(value, index, list) && results.push(value);
        }), results;
    }
    function every(obj, predicate, context) {
        predicate = cb(predicate, context);
        for (var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj)) return !1;
        }
        return !0;
    }
    function some(obj, predicate, context) {
        predicate = cb(predicate, context);
        for (var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj)) return !0;
        }
        return !1;
    }
    function contains(obj, item, fromIndex, guard) {
        return isArrayLike(obj) || (obj = values(obj)), 0 <= indexOf(obj, item, fromIndex = "number" != typeof fromIndex || guard ? 0 : fromIndex);
    }
    invoke = restArguments(function(obj, path, args) {
        var contextPath, func;
        return isFunction$1(path) ? func = path : (path = toPath$1(path), contextPath = path.slice(0, -1), 
        path = path[path.length - 1]), map(obj, function(context) {
            var method = func;
            if (!method) {
                if (null == (context = contextPath && contextPath.length ? deepGet(context, contextPath) : context)) return;
                method = context[path];
            }
            return null == method ? method : method.apply(context, args);
        });
    });
    function pluck(obj, key) {
        return map(obj, property(key));
    }
    function max(obj, iteratee, context) {
        var value, computed, result = -1 / 0, lastComputed = -1 / 0;
        if (null == iteratee || "number" == typeof iteratee && "object" != typeof obj[0] && null != obj) for (var i = 0, length = (obj = isArrayLike(obj) ? obj : values(obj)).length; i < length; i++) null != (value = obj[i]) && result < value && (result = value); else iteratee = cb(iteratee, context), 
        each(obj, function(v, index, list) {
            computed = iteratee(v, index, list), (lastComputed < computed || computed === -1 / 0 && result === -1 / 0) && (result = v, 
            lastComputed = computed);
        });
        return result;
    }
    function sample(length, n, guard) {
        if (null == n || guard) return (length = !isArrayLike(length) ? values(length) : length)[random(length.length - 1)];
        var sample = (isArrayLike(length) ? clone : values)(length), length = getLength(sample);
        n = Math.max(Math.min(n, length), 0);
        for (var last = length - 1, index = 0; index < n; index++) {
            var rand = random(index, last), temp = sample[index];
            sample[index] = sample[rand], sample[rand] = temp;
        }
        return sample.slice(0, n);
    }
    function group(behavior, partition) {
        return function(obj, iteratee, context) {
            var result = partition ? [ [], [] ] : {};
            return iteratee = cb(iteratee, context), each(obj, function(value, key) {
                key = iteratee(value, key, obj);
                behavior(result, value, key);
            }), result;
        };
    }
    var groupBy = group(function(result, value, key) {
        has(result, key) ? result[key].push(value) : result[key] = [ value ];
    }), indexBy = group(function(result, value, key) {
        result[key] = value;
    }), countBy = group(function(result, value, key) {
        has(result, key) ? result[key]++ : result[key] = 1;
    }), partition = group(function(result, value, pass) {
        result[pass ? 0 : 1].push(value);
    }, !0), reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    function keyInObj(value, key, obj) {
        return key in obj;
    }
    var pick = restArguments(function(obj, keys) {
        var result = {}, iteratee = keys[0];
        if (null == obj) return result;
        isFunction$1(iteratee) ? (1 < keys.length && (iteratee = optimizeCb(iteratee, keys[1])), 
        keys = allKeys(obj)) : (iteratee = keyInObj, keys = flatten(keys, !1, !1), obj = Object(obj));
        for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i], value = obj[key];
            iteratee(value, key, obj) && (result[key] = value);
        }
        return result;
    }), omit = restArguments(function(obj, keys) {
        var context, iteratee = keys[0];
        return isFunction$1(iteratee) ? (iteratee = negate(iteratee), 1 < keys.length && (context = keys[1])) : (keys = map(flatten(keys, !1, !1), String), 
        iteratee = function(value, key) {
            return !contains(keys, key);
        }), pick(obj, iteratee, context);
    });
    function initial(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (null == n || guard ? 1 : n)));
    }
    function first(array, n, guard) {
        return null == array || array.length < 1 ? null == n || guard ? void 0 : [] : null == n || guard ? array[0] : initial(array, array.length - n);
    }
    function rest(array, n, guard) {
        return slice.call(array, null == n || guard ? 1 : n);
    }
    var difference = restArguments(function(array, rest) {
        return rest = flatten(rest, !0, !0), filter(array, function(value) {
            return !contains(rest, value);
        });
    }), without = restArguments(function(array, otherArrays) {
        return difference(array, otherArrays);
    });
    function uniq(array, isSorted, iteratee, context) {
        isBoolean(isSorted) || (context = iteratee, iteratee = isSorted, isSorted = !1), 
        null != iteratee && (iteratee = cb(iteratee, context));
        for (var result = [], seen = [], i = 0, length = getLength(array); i < length; i++) {
            var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
            isSorted && !iteratee ? (i && seen === computed || result.push(value), seen = computed) : iteratee ? contains(seen, computed) || (seen.push(computed), 
            result.push(value)) : contains(result, value) || result.push(value);
        }
        return result;
    }
    union = restArguments(function(arrays) {
        return uniq(flatten(arrays, !0, !0));
    });
    function unzip(array) {
        for (var length = array && max(array, getLength).length || 0, result = Array(length), index = 0; index < length; index++) result[index] = pluck(array, index);
        return result;
    }
    _$1 = restArguments(unzip);
    function chainResult(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
    }
    function mixin(obj) {
        return each(functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [ this._wrapped ];
                return push.apply(args, arguments), chainResult(this, func.apply(_, args));
            };
        }), _;
    }
    each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            return null != obj && (method.apply(obj, arguments), "shift" !== name && "splice" !== name || 0 !== obj.length || delete obj[0]), 
            chainResult(this, obj);
        };
    }), each([ "concat", "join", "slice" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            return chainResult(this, obj = null != obj ? method.apply(obj, arguments) : obj);
        };
    });
    _$1 = mixin({
        __proto__: null,
        VERSION: "1.12.1",
        restArguments: restArguments,
        isObject: isObject,
        isNull: function(obj) {
            return null === obj;
        },
        isUndefined: isUndefined,
        isBoolean: isBoolean,
        isElement: function(obj) {
            return !(!obj || 1 !== obj.nodeType);
        },
        isString: isString,
        isNumber: isNumber,
        isDate: isDate,
        isRegExp: isRegExp,
        isError: isError,
        isSymbol: isSymbol,
        isArrayBuffer: isArrayBuffer,
        isDataView: isDataView$1,
        isArray: isArray,
        isFunction: isFunction$1,
        isArguments: isArguments$1,
        isFinite: function(obj) {
            return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
        },
        isNaN: isNaN$1,
        isTypedArray: isTypedArray$1,
        isEmpty: function(obj) {
            if (null == obj) return !0;
            var length = getLength(obj);
            return "number" == typeof length && (isArray(obj) || isString(obj) || isArguments$1(obj)) ? 0 === length : 0 === getLength(keys(obj));
        },
        isMatch: isMatch,
        isEqual: function(a, b) {
            return eq(a, b);
        },
        isMap: isMap,
        isWeakMap: isWeakMap,
        isSet: isSet,
        isWeakSet: isWeakSet,
        keys: keys,
        allKeys: allKeys,
        values: values,
        pairs: function(obj) {
            for (var _keys = keys(obj), length = _keys.length, pairs = Array(length), i = 0; i < length; i++) pairs[i] = [ _keys[i], obj[_keys[i]] ];
            return pairs;
        },
        invert: invert,
        functions: functions,
        methods: functions,
        extend: extend,
        extendOwn: extendOwn,
        assign: extendOwn,
        defaults: defaults,
        create: function(result, props) {
            return result = baseCreate(result), props && extendOwn(result, props), result;
        },
        clone: clone,
        tap: function(obj, interceptor) {
            return interceptor(obj), obj;
        },
        get: get,
        has: function(obj, path) {
            for (var length = (path = toPath$1(path)).length, i = 0; i < length; i++) {
                var key = path[i];
                if (!has(obj, key)) return !1;
                obj = obj[key];
            }
            return !!length;
        },
        mapObject: function(obj, iteratee, context) {
            iteratee = cb(iteratee, context);
            for (var _keys = keys(obj), length = _keys.length, results = {}, index = 0; index < length; index++) {
                var currentKey = _keys[index];
                results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
            }
            return results;
        },
        identity: identity,
        constant: constant,
        noop: noop,
        toPath: toPath,
        property: property,
        propertyOf: function(obj) {
            return null == obj ? noop : function(path) {
                return get(obj, path);
            };
        },
        matcher: matcher,
        matches: matcher,
        times: function(n, iteratee, context) {
            var accum = Array(Math.max(0, n));
            iteratee = optimizeCb(iteratee, context, 1);
            for (var i = 0; i < n; i++) accum[i] = iteratee(i);
            return accum;
        },
        random: random,
        now: now,
        escape: _escape,
        unescape: _unescape,
        templateSettings: templateSettings,
        template: function(text, template, matcher) {
            template = defaults({}, template = !template && matcher ? matcher : template, _.templateSettings);
            var matcher = RegExp([ (template.escape || noMatch).source, (template.interpolate || noMatch).source, (template.evaluate || noMatch).source ].join("|") + "|$", "g"), index = 0, source = "__p+='";
            text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                return source += text.slice(index, offset).replace(escapeRegExp, escapeChar), index = offset + match.length, 
                escape ? source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" : interpolate ? source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" : evaluate && (source += "';\n" + evaluate + "\n__p+='"), 
                match;
            }), source += "';\n";
            var render, argument = template.variable;
            if (argument) {
                if (!bareIdentifier.test(argument)) throw new Error(argument);
            } else source = "with(obj||{}){\n" + source + "}\n", argument = "obj";
            source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
            try {
                render = new Function(argument, "_", source);
            } catch (e) {
                throw e.source = source, e;
            }
            return (template = function(data) {
                return render.call(this, data, _);
            }).source = "function(" + argument + "){\n" + source + "}", template;
        },
        result: function(obj, path, fallback) {
            var length = (path = toPath$1(path)).length;
            if (!length) return isFunction$1(fallback) ? fallback.call(obj) : fallback;
            for (var i = 0; i < length; i++) {
                var prop = null == obj ? void 0 : obj[path[i]];
                void 0 === prop && (prop = fallback, i = length), obj = isFunction$1(prop) ? prop.call(obj) : prop;
            }
            return obj;
        },
        uniqueId: function(prefix) {
            var id = ++idCounter + "";
            return prefix ? prefix + id : id;
        },
        chain: function(instance) {
            return (instance = _(instance))._chain = !0, instance;
        },
        iteratee: iteratee,
        partial: partial,
        bind: bind,
        bindAll: bindAll,
        memoize: function(func, hasher) {
            var memoize = function(key) {
                var cache = memoize.cache, address = "" + (hasher ? hasher.apply(this, arguments) : key);
                return has(cache, address) || (cache[address] = func.apply(this, arguments)), cache[address];
            };
            return memoize.cache = {}, memoize;
        },
        delay: delay,
        defer: defer,
        throttle: function(func, wait, options) {
            var timeout, context, args, result, previous = 0;
            function later() {
                previous = !1 === options.leading ? 0 : now(), timeout = null, result = func.apply(context, args), 
                timeout || (context = args = null);
            }
            function throttled() {
                var _now = now();
                previous || !1 !== options.leading || (previous = _now);
                var remaining = wait - (_now - previous);
                return context = this, args = arguments, remaining <= 0 || wait < remaining ? (timeout && (clearTimeout(timeout), 
                timeout = null), previous = _now, result = func.apply(context, args), timeout || (context = args = null)) : timeout || !1 === options.trailing || (timeout = setTimeout(later, remaining)), 
                result;
            }
            return options = options || {}, throttled.cancel = function() {
                clearTimeout(timeout), previous = 0, timeout = context = args = null;
            }, throttled;
        },
        debounce: function(func, wait, immediate) {
            var timeout, previous, args, result, context, later = function() {
                var passed = now() - previous;
                passed < wait ? timeout = setTimeout(later, wait - passed) : (timeout = null, immediate || (result = func.apply(context, args)), 
                timeout || (args = context = null));
            }, debounced = restArguments(function(_args) {
                return context = this, args = _args, previous = now(), timeout || (timeout = setTimeout(later, wait), 
                immediate && (result = func.apply(context, args))), result;
            });
            return debounced.cancel = function() {
                clearTimeout(timeout), timeout = args = context = null;
            }, debounced;
        },
        wrap: function(func, wrapper) {
            return partial(wrapper, func);
        },
        negate: negate,
        compose: function() {
            var args = arguments, start = args.length - 1;
            return function() {
                for (var i = start, result = args[start].apply(this, arguments); i--; ) result = args[i].call(this, result);
                return result;
            };
        },
        after: function(times, func) {
            return function() {
                if (--times < 1) return func.apply(this, arguments);
            };
        },
        before: before,
        once: once,
        findKey: findKey,
        findIndex: findIndex,
        findLastIndex: findLastIndex,
        sortedIndex: sortedIndex,
        indexOf: indexOf,
        lastIndexOf: lastIndexOf,
        find: find,
        detect: find,
        findWhere: function(obj, attrs) {
            return find(obj, matcher(attrs));
        },
        each: each,
        forEach: each,
        map: map,
        collect: map,
        reduce: reduce,
        foldl: reduce,
        inject: reduce,
        reduceRight: reduceRight,
        foldr: reduceRight,
        filter: filter,
        select: filter,
        reject: function(obj, predicate, context) {
            return filter(obj, negate(cb(predicate)), context);
        },
        every: every,
        all: every,
        some: some,
        any: some,
        contains: contains,
        includes: contains,
        include: contains,
        invoke: invoke,
        pluck: pluck,
        where: function(obj, attrs) {
            return filter(obj, matcher(attrs));
        },
        max: max,
        min: function(obj, iteratee, context) {
            var value, computed, result = 1 / 0, lastComputed = 1 / 0;
            if (null == iteratee || "number" == typeof iteratee && "object" != typeof obj[0] && null != obj) for (var i = 0, length = (obj = isArrayLike(obj) ? obj : values(obj)).length; i < length; i++) null != (value = obj[i]) && value < result && (result = value); else iteratee = cb(iteratee, context), 
            each(obj, function(v, index, list) {
                ((computed = iteratee(v, index, list)) < lastComputed || computed === 1 / 0 && result === 1 / 0) && (result = v, 
                lastComputed = computed);
            });
            return result;
        },
        shuffle: function(obj) {
            return sample(obj, 1 / 0);
        },
        sample: sample,
        sortBy: function(obj, iteratee, context) {
            var index = 0;
            return iteratee = cb(iteratee, context), pluck(map(obj, function(value, key, list) {
                return {
                    value: value,
                    index: index++,
                    criteria: iteratee(value, key, list)
                };
            }).sort(function(left, right) {
                var a = left.criteria, b = right.criteria;
                if (a !== b) {
                    if (b < a || void 0 === a) return 1;
                    if (a < b || void 0 === b) return -1;
                }
                return left.index - right.index;
            }), "value");
        },
        groupBy: groupBy,
        indexBy: indexBy,
        countBy: countBy,
        partition: partition,
        toArray: function(obj) {
            return obj ? isArray(obj) ? slice.call(obj) : isString(obj) ? obj.match(reStrSymbol) : isArrayLike(obj) ? map(obj, identity) : values(obj) : [];
        },
        size: function(obj) {
            return null == obj ? 0 : (isArrayLike(obj) ? obj : keys(obj)).length;
        },
        pick: pick,
        omit: omit,
        first: first,
        head: first,
        take: first,
        initial: initial,
        last: function(array, n, guard) {
            return null == array || array.length < 1 ? null == n || guard ? void 0 : [] : null == n || guard ? array[array.length - 1] : rest(array, Math.max(0, array.length - n));
        },
        rest: rest,
        tail: rest,
        drop: rest,
        compact: function(array) {
            return filter(array, Boolean);
        },
        flatten: function(array, depth) {
            return flatten(array, depth, !1);
        },
        without: without,
        uniq: uniq,
        unique: uniq,
        union: union,
        intersection: function(array) {
            for (var result = [], argsLength = arguments.length, i = 0, length = getLength(array); i < length; i++) {
                var item = array[i];
                if (!contains(result, item)) {
                    for (var j = 1; j < argsLength && contains(arguments[j], item); j++) ;
                    j === argsLength && result.push(item);
                }
            }
            return result;
        },
        difference: difference,
        unzip: unzip,
        transpose: unzip,
        zip: _$1,
        object: function(list, values) {
            for (var result = {}, i = 0, length = getLength(list); i < length; i++) values ? result[list[i]] = values[i] : result[list[i][0]] = list[i][1];
            return result;
        },
        range: function(start, stop, step) {
            null == stop && (stop = start || 0, start = 0), step = step || (stop < start ? -1 : 1);
            for (var length = Math.max(Math.ceil((stop - start) / step), 0), range = Array(length), idx = 0; idx < length; idx++, 
            start += step) range[idx] = start;
            return range;
        },
        chunk: function(array, count) {
            if (null == count || count < 1) return [];
            for (var result = [], i = 0, length = array.length; i < length; ) result.push(slice.call(array, i, i += count));
            return result;
        },
        mixin: mixin,
        default: _
    });
    return _$1._ = _$1;
}), function(window) {
    "use strict";
    var minErrConfig = {
        objectMaxDepth: 5,
        urlErrorParamsEnabled: !0
    };
    function errorHandlingConfig(config) {
        if (!isObject(config)) return minErrConfig;
        void 0 !== config.objectMaxDepth && (minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN), 
        void 0 !== config.urlErrorParamsEnabled && isBoolean(config.urlErrorParamsEnabled) && (minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled);
    }
    function isValidObjectMaxDepth(maxDepth) {
        return isNumber(maxDepth) && 0 < maxDepth;
    }
    function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        var url = "https://errors.angularjs.org/1.8.2/", regex = url.replace(".", "\\.") + "[\\s\\S]*", errRegExp = new RegExp(regex, "g");
        return function() {
            var paramPrefix, i, code = arguments[0], template = arguments[1], message = "[" + (module ? module + ":" : "") + code + "] ", templateArgs = sliceArgs(arguments, 2).map(function(arg) {
                return toDebugString(arg, minErrConfig.objectMaxDepth);
            });
            if (message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1);
                return index < templateArgs.length ? templateArgs[index].replace(errRegExp, "") : match;
            }), message += "\n" + url + (module ? module + "/" : "") + code, minErrConfig.urlErrorParamsEnabled) for (i = 0, 
            paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
            return new ErrorConstructor(message);
        };
    }
    var msie, jqLite, angularModule, REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", hasOwnProperty = Object.prototype.hasOwnProperty, lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, slice = [].slice, splice = [].splice, jQuery = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    function isArrayLike(obj) {
        if (null != obj && !isWindow(obj)) {
            if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return 1;
            var length = "length" in Object(obj) && obj.length;
            return isNumber(length) && (0 <= length && length - 1 in obj || "function" == typeof obj.item);
        }
    }
    function forEach(obj, iterator, context) {
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" !== key && "length" !== key && "name" !== key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) for (var isPrimitive = "object" != typeof obj, key = 0, length = obj.length; key < length; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj); else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj)) for (key in obj) iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty) for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function baseExtend(dst, objs, deep) {
        for (var h = dst.$$hashKey, i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (isObject(obj) || isFunction(obj)) for (var keys = Object.keys(obj), j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j], src = obj[key];
                deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : "__proto__" !== key && (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), 
                baseExtend(dst[key], [ src ], !0)) : dst[key] = src;
            }
        }
        return setHashKey(dst, h), dst;
    }
    function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !1);
    }
    function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !0);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    msie = window.document.documentMode;
    var isNumberNaN = Number.isNaN || function(num) {
        return num != num;
    };
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
    }
    function isUndefined(value) {
        return void 0 === value;
    }
    function isDefined(value) {
        return void 0 !== value;
    }
    function isObject(value) {
        return null !== value && "object" == typeof value;
    }
    function isBlankObject(value) {
        return null !== value && "object" == typeof value && !getPrototypeOf(value);
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isArray(arr) {
        return Array.isArray(arr) || arr instanceof Array;
    }
    function isError(value) {
        switch (toString.call(value)) {
          case "[object Error]":
          case "[object Exception]":
          case "[object DOMException]":
            return 1;

          default:
            return value instanceof Error;
        }
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isBoolean(value) {
        return "boolean" == typeof value;
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    noop.$inject = [], identity.$inject = [];
    var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/, trim = function(value) {
        return isString(value) ? value.trim() : value;
    }, escapeForRegexp = function(s) {
        return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    };
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return -1 !== Array.prototype.indexOf.call(array, obj);
    }
    function arrayRemove(array, index) {
        index = array.indexOf(index);
        return 0 <= index && array.splice(index, 1), index;
    }
    function copy(source, destination, maxDepth) {
        var obj, stackSource = [], stackDest = [];
        if (maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN, destination) {
            if ((obj = destination) && isNumber(obj.length) && TYPED_ARRAY_REGEXP.test(toString.call(obj)) || (obj = destination, 
            "[object ArrayBuffer]" === toString.call(obj))) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            return isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                "$$hashKey" !== key && delete destination[key];
            }), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination, maxDepth);
        }
        return copyElement(source, maxDepth);
        function copyRecurse(source, destination, maxDepth) {
            if (--maxDepth < 0) return "...";
            var key, h = destination.$$hashKey;
            if (isArray(source)) for (var i = 0, ii = source.length; i < ii; i++) destination.push(copyElement(source[i], maxDepth)); else if (isBlankObject(source)) for (key in source) destination[key] = copyElement(source[key], maxDepth); else if (source && "function" == typeof source.hasOwnProperty) for (key in source) source.hasOwnProperty(key) && (destination[key] = copyElement(source[key], maxDepth)); else for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key], maxDepth));
            return setHashKey(destination, h), destination;
        }
        function copyElement(source, maxDepth) {
            if (!isObject(source)) return source;
            var destination = stackSource.indexOf(source);
            if (-1 !== destination) return stackDest[destination];
            if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
            var needsRecurse = !1, destination = function(source) {
                switch (toString.call(source)) {
                  case "[object Int8Array]":
                  case "[object Int16Array]":
                  case "[object Int32Array]":
                  case "[object Float32Array]":
                  case "[object Float64Array]":
                  case "[object Uint8Array]":
                  case "[object Uint8ClampedArray]":
                  case "[object Uint16Array]":
                  case "[object Uint32Array]":
                    return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

                  case "[object ArrayBuffer]":
                    if (source.slice) return source.slice(0);
                    var re = new ArrayBuffer(source.byteLength);
                    return new Uint8Array(re).set(new Uint8Array(source)), re;

                  case "[object Boolean]":
                  case "[object Number]":
                  case "[object String]":
                  case "[object Date]":
                    return new source.constructor(source.valueOf());

                  case "[object RegExp]":
                    re = new RegExp(source.source, source.toString().match(/[^/]*$/)[0]);
                    return re.lastIndex = source.lastIndex, re;

                  case "[object Blob]":
                    return new source.constructor([ source ], {
                        type: source.type
                    });
                }
                if (isFunction(source.cloneNode)) return source.cloneNode(!0);
            }(source);
            return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)), 
            needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
        }
    }
    function simpleCompare(a, b) {
        return a === b || a != a && b != b;
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 != o1 && o2 != o2) return !0;
        var length, key, keySet, t1 = typeof o1;
        if (t1 == typeof o2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return !!isDate(o2) && simpleCompare(o1.getTime(), o2.getTime());
                if (isRegExp(o1)) return !!isRegExp(o2) && o1.toString() === o2.toString();
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                for (key in keySet = createMap(), o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!(key in keySet || "$" === key.charAt(0) || void 0 === o2[key] || isFunction(o2[key]))) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) === o2.length) {
                for (key = 0; key < length; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    var csp = function() {
        var ngCspAttribute;
        return void 0 === csp.rules && ((ngCspAttribute = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]")) ? (ngCspAttribute = ngCspAttribute.getAttribute("ng-csp") || ngCspAttribute.getAttribute("data-ng-csp"), 
        csp.rules = {
            noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
            noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
        }) : csp.rules = {
            noUnsafeEval: function() {
                try {
                    return new Function(""), !1;
                } catch (e) {
                    return !0;
                }
            }(),
            noInlineStyle: !1
        }), csp.rules;
    }, jq = function() {
        if (void 0 !== jq.name_) return jq.name_;
        for (var el, prefix, name, ii = ngAttrPrefixes.length, i = 0; i < ii; ++i) if (prefix = ngAttrPrefixes[i], 
        el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
            name = el.getAttribute(prefix + "jq");
            break;
        }
        return jq.name_ = name;
    };
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = 2 < arguments.length ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        if (void 0 !== obj) return isNumber(pretty) || (pretty = pretty ? 2 : null), JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    var ALL_COLONS = /:/g;
    function timezoneToOffset(requestedTimezoneOffset, fallback) {
        requestedTimezoneOffset = requestedTimezoneOffset.replace(ALL_COLONS, "");
        requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + requestedTimezoneOffset) / 6e4;
        return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return (date = new Date(date.getTime())).setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        return addDateMinutes(date, reverse * (timezoneToOffset(timezone, dateTimezoneOffset) - dateTimezoneOffset));
    }
    function startingTag(element) {
        element = jqLite(element).clone().empty();
        var elemHtml = jqLite("<div></div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            var splitPoint, key, val;
            keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), -1 !== (splitPoint = keyValue.indexOf("=")) && (key = keyValue.substring(0, splitPoint), 
            val = keyValue.substring(splitPoint + 1)), void 0 !== (key = tryDecodeURIComponent(key)) && (val = void 0 === val || tryDecodeURIComponent(val), 
            hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val));
        }), obj;
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    var document, ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ], isAutoBootstrapAllowed = (document = window.document, 
    !(DATETIMELOCAL_REGEXP = document.currentScript) || (DATETIMELOCAL_REGEXP instanceof window.HTMLScriptElement || DATETIMELOCAL_REGEXP instanceof window.SVGScriptElement) && [ (DATETIMELOCAL_REGEXP = DATETIMELOCAL_REGEXP.attributes).getNamedItem("src"), DATETIMELOCAL_REGEXP.getNamedItem("href"), DATETIMELOCAL_REGEXP.getNamedItem("xlink:href") ].every(function(src) {
        if (!src) return !0;
        if (!src.value) return !1;
        var link = document.createElement("a");
        if (link.href = src.value, document.location.origin === link.origin) return !0;
        switch (link.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "blob:":
          case "file:":
          case "data:":
            return !0;

          default:
            return !1;
        }
    }));
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(name) {
            name += "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (module = (appElement = element).getAttribute(name));
        }), forEach(ngAttrPrefixes, function(name) {
            var candidate, name = name + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (module = (appElement = candidate).getAttribute(name));
        }), appElement && (isAutoBootstrapAllowed ? (config.strictDi = null !== function(element, ngAttr) {
            for (var attr, ii = ngAttrPrefixes.length, i = 0; i < ii; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, 
            isString(attr = element.getAttribute(attr))) return attr;
            return null;
        }(appElement, "strict-di"), bootstrap(appElement, module ? [ module ] : [], config)) : window.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match."));
    }
    function bootstrap(element, modules, config) {
        config = extend({
            strictDi: !1
        }, config = !isObject(config) ? {} : config);
        function doBootstrap() {
            if ((element = jqLite(element)).injector()) {
                var injector = element[0] === window.document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", injector.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            return (modules = modules || []).unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(!0);
            } ]), modules.unshift("ng"), (injector = createInjector(modules, config.strictDi)).invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, 
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name)) return doBootstrap();
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), angular.resumeBootstrap = function(extraModules) {
            return forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }, isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap();
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
    }
    function getTestability(injector) {
        injector = angular.element(injector).injector();
        if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
        return injector.get("$$testability");
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var bindJQueryFired = !1;
    function UNSAFE_restoreLegacyJqLiteXHTMLReplacement() {
        JQLite.legacyXHTMLReplacement = !0;
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return assertArg(isFunction(arg = acceptArrayAnnotation && isArray(arg) ? arg[arg.length - 1] : arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getBlockNodes(nodes) {
        for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++) !blockNodes && nodes[i] === node || (blockNodes = blockNodes || jqLite(slice.call(nodes, 0, i))).push(node);
        return blockNodes || nodes;
    }
    function createMap() {
        return Object.create(null);
    }
    function stringify(value) {
        if (null == value) return "";
        switch (typeof value) {
          case "string":
            break;

          case "number":
            value = "" + value;
            break;

          default:
            value = !hasCustomToString(value) || isArray(value) || isDate(value) ? toJson(value) : value.toString();
        }
        return value;
    }
    var NODE_TYPE_ELEMENT = 1, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    function setupModuleLoader(angular) {
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng");
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        angular = ensure(angular, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var info = {};
                return function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                }(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        info: function(value) {
                            if (void 0 === value) return info;
                            if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                            return info = value, this;
                        },
                        requires: requires,
                        name: name,
                        provider: invokeLaterAndSetModuleName("$provide", "provider"),
                        factory: invokeLaterAndSetModuleName("$provide", "factory"),
                        service: invokeLaterAndSetModuleName("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                        animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                        filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                        controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                        directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                        component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue = queue || invokeQueue, function() {
                            return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    function invokeLaterAndSetModuleName(provider, method, queue) {
                        return queue = queue || invokeQueue, function(recipeName, factoryFunction) {
                            return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), 
                            queue.push([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                });
            };
        });
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) dst[i] = src[i];
        } else if (isObject(src)) for (var key in dst = dst || {}, src) "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
        return dst || src;
    }
    function toDebugString(obj, maxDepth) {
        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : void 0 === obj ? "undefined" : "string" != typeof obj ? function(obj, maxDepth) {
            var seen = [];
            return isValidObjectMaxDepth(maxDepth) && (obj = angular.copy(obj, null, maxDepth)), 
            JSON.stringify(obj, function(key, val) {
                if (isObject(val = toJsonReplacer(key, val))) {
                    if (0 <= seen.indexOf(val)) return "...";
                    seen.push(val);
                }
                return val;
            });
        }(obj, maxDepth) : obj;
    }
    var version = {
        full: "1.8.2",
        major: 1,
        minor: 8,
        dot: 2,
        codeName: "meteoric-mining"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1;
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    var DASH_LOWERCASE_REGEXP = /-([a-z])/g, MS_HACK_REGEXP = /^-ms-/, MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, jqLiteMinErr = minErr("jqLite");
    function fnCamelCaseReplace(all, letter) {
        return letter.toUpperCase();
    }
    function kebabToCamel(name) {
        return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:-]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wrapMap = {
        thead: [ "table" ],
        col: [ "colgroup", "table" ],
        tr: [ "tbody", "table" ],
        td: [ "tr", "tbody", "table" ]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var key, wrapMapIE9 = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        _default: [ 0, "", "" ]
    };
    for (key in wrapMap) {
        var wrapMapValueClosing = wrapMap[key], wrapMapValue = wrapMapValueClosing.slice().reverse();
        wrapMapIE9[key] = [ wrapMapValue.length, "<" + wrapMapValue.join("><") + ">", "</" + wrapMapValueClosing.join("></") + ">" ];
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(nodeType) {
        nodeType = nodeType.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteBuildFragment(finalHtml, tag) {
        var tmp, wrap, i, fragment = tag.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(finalHtml)) nodes.push(tag.createTextNode(finalHtml)); else {
            if (tmp = fragment.appendChild(tag.createElement("div")), tag = (TAG_NAME_REGEXP.exec(finalHtml) || [ "", "" ])[1].toLowerCase(), 
            finalHtml = JQLite.legacyXHTMLReplacement ? finalHtml.replace(XHTML_TAG_REGEXP, "<$1></$2>") : finalHtml, 
            msie < 10) for (wrap = wrapMapIE9[tag] || wrapMapIE9._default, tmp.innerHTML = wrap[1] + finalHtml + wrap[2], 
            i = wrap[0]; i--; ) tmp = tmp.firstChild; else {
                for (i = (wrap = wrapMap[tag] || []).length; -1 < --i; ) tmp.appendChild(window.document.createElement(wrap[i])), 
                tmp = tmp.firstChild;
                tmp.innerHTML = finalHtml;
            }
            nodes = concat(nodes, tmp.childNodes), (tmp = fragment.firstChild).textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
            fragment.appendChild(node);
        }), fragment;
    }
    wrapMapIE9.optgroup = wrapMapIE9.option;
    var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(16 & this.compareDocumentPosition(arg));
    };
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        var html, context, parsed;
        if (isString(element) && (element = trim(element), parsed = !0), !(this instanceof JQLite)) {
            if (parsed && "<" !== element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        parsed ? jqLiteAddNodes(this, (html = element, context = context || window.document, 
        (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [])) : isFunction(element) ? jqLiteReady(element) : jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        !onlyDescendants && jqLiteAcceptsData(element) && jqLite.cleanData([ element ]), 
        element.querySelectorAll && jqLite.cleanData(element.querySelectorAll("*"));
    }
    function isEmptyObject(obj) {
        for (var name in obj) return;
        return 1;
    }
    function removeIfEmptyData(element) {
        var expandoId = element.ng339, data = expandoId && jqCache[expandoId], events = data && data.events, data = data && data.data;
        data && !isEmptyObject(data) || events && !isEmptyObject(events) || (delete jqCache[expandoId], 
        element.ng339 = void 0);
    }
    function jqLiteOff(element, type, fn, expandoStore) {
        if (void 0 !== expandoStore) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
        if (handle) {
            if (type) {
                var removeHandler = function(type) {
                    var listenerFns = events[type];
                    void 0 !== fn && arrayRemove(listenerFns || [], fn), void 0 !== fn && listenerFns && 0 < listenerFns.length || (element.removeEventListener(type, handle), 
                    delete events[type]);
                };
                forEach(type.split(" "), function(type) {
                    removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type]);
                });
            } else for (type in events) "$destroy" !== type && element.removeEventListener(type, handle), 
            delete events[type];
            removeIfEmptyData(element);
        }
    }
    function jqLiteRemoveData(element, name) {
        var expandoStore = element.ng339, expandoStore = expandoStore && jqCache[expandoStore];
        expandoStore && (name ? delete expandoStore.data[name] : expandoStore.data = {}, 
        removeIfEmptyData(element));
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = ++jqId, 
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: void 0
        }), expandoStore;
    }
    function jqLiteData(expandoStore, key, value) {
        if (jqLiteAcceptsData(expandoStore)) {
            var prop, isSimpleSetter = void 0 !== value, isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(expandoStore, !isSimpleGetter), data = expandoStore && expandoStore.data;
            if (isSimpleSetter) data[kebabToCamel(key)] = value; else {
                if (massGetter) return data;
                if (isSimpleGetter) return data && data[kebabToCamel(key)];
                for (prop in key) data[kebabToCamel(prop)] = key[prop];
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return !!element.getAttribute && -1 < (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ");
    }
    function jqLiteRemoveClass(element, cssClasses) {
        var existingClasses, newClasses;
        cssClasses && element.setAttribute && (existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), 
        newClasses = existingClasses, forEach(cssClasses.split(" "), function(cssClass) {
            cssClass = trim(cssClass), newClasses = newClasses.replace(" " + cssClass + " ", " ");
        }), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses)));
    }
    function jqLiteAddClass(element, cssClasses) {
        var existingClasses, newClasses;
        cssClasses && element.setAttribute && (existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), 
        newClasses = existingClasses, forEach(cssClasses.split(" "), function(cssClass) {
            cssClass = trim(cssClass), -1 === newClasses.indexOf(" " + cssClass + " ") && (newClasses += cssClass + " ");
        }), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses)));
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) if (elements.nodeType) root[root.length++] = elements; else {
            var length = elements.length;
            if ("number" == typeof length && elements.window !== elements) {
                if (length) for (var i = 0; i < length; i++) root[root.length++] = elements[i];
            } else root[root.length++] = elements;
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType === NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [ name ]; element; ) {
            for (var i = 0, ii = names.length; i < ii; i++) if (void 0 !== (value = jqLite.data(element, names[i]))) return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
    }
    function jqLiteRemove(element, parent) {
        parent || jqLiteDealoc(element);
        parent = element.parentNode;
        parent && parent.removeChild(element);
    }
    function jqLiteReady(fn) {
        function trigger() {
            window.document.removeEventListener("DOMContentLoaded", trigger), window.removeEventListener("load", trigger), 
            fn();
        }
        "complete" === window.document.readyState ? window.setTimeout(fn) : (window.document.addEventListener("DOMContentLoaded", trigger), 
        window.addEventListener("load", trigger));
    }
    var JQLitePrototype = JQLite.prototype = {
        ready: jqLiteReady,
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(0 <= index ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: jQuery,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = !0;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern",
        ngStep: "step"
    };
    function getBooleanAttrName(element, booleanAttr) {
        booleanAttr = BOOLEAN_ATTR[booleanAttr.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getText(element, value) {
        if (void 0 === value) {
            var nodeType = element.nodeType;
            return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
        }
        element.textContent = value;
    }
    function createEventHandler(element, events) {
        function eventHandler(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var originalStopImmediatePropagation, eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                void 0 === event.immediatePropagationStopped && (originalStopImmediatePropagation = event.stopImmediatePropagation, 
                event.stopImmediatePropagation = function() {
                    event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), 
                    originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                }), event.isImmediatePropagationStopped = function() {
                    return !0 === event.immediatePropagationStopped;
                };
                var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                1 < eventFnsLength && (eventFns = shallowCopy(eventFns));
                for (var i = 0; i < eventFnsLength; i++) event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i]);
            }
        }
        return eventHandler.elem = element, eventHandler;
    }
    function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
    }
    function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        related && (related === target || jqLiteContains.call(target, related)) || handler.call(target, event);
    }
    function $$jqLiteProvider() {
        this.$get = function() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    return jqLiteHasClass(node = node.attr ? node[0] : node, classes);
                },
                addClass: function(node, classes) {
                    return jqLiteAddClass(node = node.attr ? node[0] : node, classes);
                },
                removeClass: function(node, classes) {
                    return jqLiteRemoveClass(node = node.attr ? node[0] : node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) return key = "function" == typeof key ? obj.$$hashKey() : key;
        var objType = typeof obj;
        return key = "function" == objType || "object" == objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
    }
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: function(node) {
            for (var key in jqCache[node.ng339]) return !0;
            return !1;
        },
        cleanData: function(nodes) {
            for (var i = 0, ii = nodes.length; i < ii; i++) jqLiteRemoveData(nodes[i]), jqLiteOff(nodes[i]);
        }
    }, function(fn, name) {
        JQLite[name] = fn;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            if (name = function(name) {
                return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
            }(name), void 0 === value) return element.style[name];
            element.style[name] = value;
        },
        attr: function(element, name, value) {
            var ret = element.nodeType;
            if (ret !== NODE_TYPE_TEXT && 2 !== ret && ret !== NODE_TYPE_COMMENT && element.getAttribute) {
                var lowercasedName = lowercase(name), isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                if (void 0 === value) return ret = element.getAttribute(name), null === (ret = isBooleanAttr && null !== ret ? lowercasedName : ret) ? void 0 : ret;
                null === value || !1 === value && isBooleanAttr ? element.removeAttribute(name) : element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
            }
        },
        prop: function(element, name, value) {
            if (void 0 === value) return element[name];
            element[name] = value;
        },
        text: (getText.$dv = "", getText),
        val: function(element, value) {
            if (void 0 === value) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (void 0 === value) return element.innerHTML;
            jqLiteDealoc(element, !0), element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && void 0 === (2 === fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var jj = void 0 === (value = fn.$dv) ? Math.min(nodeCount, 1) : nodeCount, j = 0; j < jj; j++) var nodeValue = fn(this[j], arg1, arg2), value = value ? value + nodeValue : nodeValue;
                return value;
            }
            for (i = 0; i < nodeCount; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        on: function(element, type, fn, expandoStore) {
            if (void 0 !== expandoStore) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) for (var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = (handle = expandoStore.handle) || (expandoStore.handle = createEventHandler(element, events)), types = 0 <= type.indexOf(" ") ? type.split(" ") : [ type ], i = types.length, addHandler = function(type, specialHandlerWrapper, noEventListener) {
                var eventFns = events[type];
                eventFns || ((eventFns = events[type] = []).specialHandlerWrapper = specialHandlerWrapper, 
                "$destroy" === type || noEventListener || element.addEventListener(type, handle)), 
                eventFns.push(fn);
            }; i--; ) type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper), 
            addHandler(type, void 0, !0)) : addHandler(type);
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            (element = jqLite(element)).on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) for (var i = 0, ii = (node = new JQLite(node)).length; i < ii; i++) {
                var child = node[i];
                element.appendChild(child);
            }
        },
        prepend: function(element, node) {
            var index;
            element.nodeType === NODE_TYPE_ELEMENT && (index = element.firstChild, forEach(new JQLite(node), function(child) {
                element.insertBefore(child, index);
            }));
        },
        wrap: function(wrapper, parent) {
            var node;
            node = wrapper, wrapper = jqLite(parent).eq(0).clone()[0], (parent = node.parentNode) && parent.replaceChild(wrapper, node), 
            wrapper.appendChild(node);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, !0);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            if (parent) for (var i = 0, ii = (newElement = new JQLite(newElement)).length; i < ii; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling), index = node;
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                ((classCondition = void 0 === classCondition ? !jqLiteHasClass(element, className) : classCondition) ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(parent) {
            parent = parent.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, handlerArgs, eventName = event.type || event, eventFnsCopy = jqLiteExpandoStore(element), eventFnsCopy = eventFnsCopy && eventFnsCopy.events, eventFnsCopy = eventFnsCopy && eventFnsCopy[eventName];
            eventFnsCopy && (dummyEvent = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return !0 === this.defaultPrevented;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return !0 === this.immediatePropagationStopped;
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFnsCopy), 
            handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ], 
            forEach(eventFnsCopy, function(fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
            }));
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; i < ii; i++) void 0 === value ? void 0 !== (value = fn(this[i], arg1, arg2, arg3)) && (value = jqLite(value)) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return void 0 !== value ? value : this;
        };
    }), JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
    var nanKey = Object.create(null);
    function NgMapShim() {
        this._keys = [], this._values = [], this._lastKey = NaN, this._lastIndex = -1;
    }
    NgMapShim.prototype = {
        _idx: function(key) {
            return key !== this._lastKey && (this._lastKey = key, this._lastIndex = this._keys.indexOf(key)), 
            this._lastIndex;
        },
        _transformKey: function(key) {
            return isNumberNaN(key) ? nanKey : key;
        },
        get: function(idx) {
            idx = this._transformKey(idx);
            idx = this._idx(idx);
            if (-1 !== idx) return this._values[idx];
        },
        has: function(key) {
            return key = this._transformKey(key), -1 !== this._idx(key);
        },
        set: function(key, value) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            -1 === idx && (idx = this._lastIndex = this._keys.length), this._keys[idx] = key, 
            this._values[idx] = value;
        },
        delete: function(idx) {
            idx = this._transformKey(idx);
            idx = this._idx(idx);
            return -1 !== idx && (this._keys.splice(idx, 1), this._values.splice(idx, 1), this._lastKey = NaN, 
            this._lastIndex = -1, !0);
        }
    };
    var NgMap = NgMapShim, $$MapProvider = [ function() {
        this.$get = [ function() {
            return NgMap;
        } ];
    } ], ARROW_ARG = /^([^(]+?)=>/, FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
    function stringifyFn(fn) {
        return Function.prototype.toString.call(fn);
    }
    function extractArgs(fnText) {
        fnText = stringifyFn(fnText).replace(STRIP_COMMENTS, "");
        return fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
    }
    function createInjector(runBlocks, strictDi) {
        strictDi = !0 === strictDi;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new NgMap(), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(function(name, constructor) {
                    return factory(name, [ "$injector", function($injector) {
                        return $injector.instantiate(constructor);
                    } ]);
                }),
                value: supportObject(function(name, val) {
                    return factory(name, valueFn(val), !1);
                }),
                constant: supportObject(function(name, value) {
                    assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
                }),
                decorator: function(serviceName, decorFn) {
                    var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
                    origProvider.$get = function() {
                        var origInstance = instanceInjector.invoke(orig$get, origProvider);
                        return instanceInjector.invoke(decorFn, null, {
                            $delegate: origInstance
                        });
                    };
                }
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, provider) {
            provider = providerInjector.get(serviceName + providerSuffix, provider);
            return instanceInjector.invoke(provider.$get, provider, void 0, serviceName);
        }), instanceInjector = protoInstanceInjector;
        providerCache["$injector" + providerSuffix] = {
            $get: valueFn(protoInstanceInjector)
        }, instanceInjector.modules = providerInjector.modules = createMap();
        runBlocks = loadModules(runBlocks);
        return (instanceInjector = protoInstanceInjector.get("$injector")).strictDi = strictDi, 
        forEach(runBlocks, function(fn) {
            fn && instanceInjector.invoke(fn);
        }), instanceInjector.loadNewModules = function(mods) {
            forEach(loadModules(mods), function(fn) {
                fn && instanceInjector.invoke(fn);
            });
        }, instanceInjector;
        function supportObject(delegate) {
            return function(key, value) {
                if (!isObject(key)) return delegate(key, value);
                forEach(key, reverseParams(delegate));
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), !(provider_ = isFunction(provider_) || isArray(provider_) ? providerInjector.instantiate(provider_) : provider_).$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: !1 !== enforce ? function(name, factory) {
                    return function() {
                        var result = instanceInjector.invoke(factory, this);
                        if (void 0 === result) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                        return result;
                    };
                }(name, factoryFn) : factoryFn
            });
        }
        function loadModules(modulesToLoad) {
            assertArg(void 0 === modulesToLoad || isArray(modulesToLoad), "modulesToLoad", "not an array");
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                if (!loadedModules.get(module)) {
                    loadedModules.set(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module), instanceInjector.modules[module] = moduleFn, 
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) || isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
                function runInvokeQueue(queue) {
                    for (var i = 0, ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller), 
                    cache[serviceName];
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function injectionArgs(fn, locals, serviceName) {
                for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; i < length; i++) {
                    var key = $inject[i];
                    if ("string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                return args;
            }
            return {
                invoke: function(fn, self, locals, args) {
                    return "string" == typeof locals && (args = locals, locals = null), args = injectionArgs(fn, locals, args), 
                    function(func) {
                        if (!msie && "function" == typeof func) {
                            var result = func.$$ngIsClass;
                            return result = !isBoolean(result) ? func.$$ngIsClass = /^class\b/.test(stringifyFn(func)) : result;
                        }
                    }(fn = isArray(fn) ? fn[fn.length - 1] : fn) ? (args.unshift(null), new (Function.prototype.bind.apply(fn, args))()) : fn.apply(self, args);
                },
                instantiate: function(Type, locals, args) {
                    var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
                    return (args = injectionArgs(Type, locals, args)).unshift(null), new (Function.prototype.bind.apply(ctor, args))();
                },
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document = $window.document;
            function scrollTo(elemTop) {
                var offset;
                elemTop ? (elemTop.scrollIntoView(), (offset = function() {
                    var elem, offset = scroll.yOffset;
                    return isFunction(offset) ? offset = offset() : isElement(offset) ? (elem = offset[0], 
                    offset = "fixed" !== $window.getComputedStyle(elem).position ? 0 : elem.getBoundingClientRect().bottom) : isNumber(offset) || (offset = 0), 
                    offset;
                }()) && (elemTop = elemTop.getBoundingClientRect().top, $window.scrollBy(0, elemTop - offset))) : $window.scrollTo(0, 0);
            }
            function scroll(hash) {
                var elm, list, result;
                (hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash()) ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (list = document.getElementsByName(hash), 
                result = null, Array.prototype.some.call(list, function(element) {
                    if ("a" === nodeName_(element)) return result = element, !0;
                }), (elm = result) ? scrollTo(elm) : "top" === hash && scrollTo(null)) : scrollTo(null);
            }
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function(action, oldVal) {
                var win;
                action === oldVal && "" === action || (action = function() {
                    $rootScope.$evalAsync(scroll);
                }, "complete" === (win = win || window).document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action));
            }), scroll;
        } ];
    }
    createInjector.$$annotate = function(fn, args, last) {
        var $inject;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [], fn.length) {
                    if (args) throw isString(last) && last || (last = fn.name || ((args = extractArgs(args = fn)) ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn")), 
                    $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", last);
                    forEach(extractArgs(fn)[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else isArray(fn) ? (assertArgFn(fn[last = fn.length - 1], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject;
    };
    var $animateMinErr = minErr("$animate"), ELEMENT_NODE = 1;
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (a = isArray(a) ? a.join(" ") : a) + " " + (b = isArray(b) ? b.join(" ") : b) : a : b : "";
    }
    function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
    }
    function $$CoreAnimateJsProvider() {
        this.$get = noop;
    }
    function $$CoreAnimateQueueProvider() {
        var postDigestQueue = new NgMap(), postDigestElements = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function(element, event, runner, domOperation) {
                    domOperation && domOperation(), (runner = runner || {}).from && element.css(runner.from), 
                    runner.to && element.css(runner.to), (runner.addClass || runner.removeClass) && function(element, classesAdded, classesRemoved) {
                        var data = postDigestQueue.get(element) || {}, classesAdded = updateData(data, classesAdded, !0), classesRemoved = updateData(data, classesRemoved, !1);
                        (classesAdded || classesRemoved) && (postDigestQueue.set(element, data), postDigestElements.push(element), 
                        1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges));
                    }(element, runner.addClass, runner.removeClass);
                    runner = new $$AnimateRunner();
                    return runner.complete(), runner;
                }
            };
            function updateData(data, classes, value) {
                var changed = !1;
                return classes && forEach(classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], function(className) {
                    className && (changed = !0, data[className] = value);
                }), changed;
            }
            function handleCSSClassChanges() {
                forEach(postDigestElements, function(element) {
                    var existing, toAdd, toRemove, data = postDigestQueue.get(element);
                    data && (existing = function(classes) {
                        isString(classes) && (classes = classes.split(" "));
                        var obj = createMap();
                        return forEach(classes, function(klass) {
                            klass.length && (obj[klass] = !0);
                        }), obj;
                    }(element.attr("class")), toRemove = toAdd = "", forEach(data, function(status, className) {
                        status !== !!existing[className] && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className);
                    }), forEach(element, function(elm) {
                        toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove);
                    }), postDigestQueue.delete(element));
                }), postDigestElements.length = 0;
            }
        } ];
    }
    function $$AnimateAsyncRunFactoryProvider() {
        this.$get = [ "$$rAF", function($$rAF) {
            var waitQueue = [];
            function waitForTick(fn) {
                waitQueue.push(fn), 1 < waitQueue.length || $$rAF(function() {
                    for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                    waitQueue = [];
                });
            }
            return function() {
                var passed = !1;
                return waitForTick(function() {
                    passed = !0;
                }), function(callback) {
                    passed ? callback() : waitForTick(callback);
                };
            };
        } ];
    }
    function $$AnimateRunnerFactoryProvider() {
        this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
            function AnimateRunner(host) {
                this.setHost(host);
                var rafTick = $$animateAsyncRun();
                this._doneCallbacks = [], this._tick = function(fn) {
                    ($$isDocumentHidden() ? function(fn) {
                        $timeout(fn, 0, !1);
                    } : rafTick)(fn);
                }, this._state = 0;
            }
            return AnimateRunner.chain = function(chain, callback) {
                var index = 0;
                !function next() {
                    if (index === chain.length) return void callback(!0);
                    chain[index](function(response) {
                        !1 !== response ? (index++, next()) : callback(!1);
                    });
                }();
            }, AnimateRunner.all = function(runners, callback) {
                var count = 0, status = !0;
                function onProgress(response) {
                    status = status && response, ++count === runners.length && callback(status);
                }
                forEach(runners, function(runner) {
                    runner.done(onProgress);
                });
            }, AnimateRunner.prototype = {
                setHost: function(host) {
                    this.host = host || {};
                },
                done: function(fn) {
                    2 === this._state ? fn() : this._doneCallbacks.push(fn);
                },
                progress: noop,
                getPromise: function() {
                    var self;
                    return this.promise || ((self = this).promise = $q(function(resolve, reject) {
                        self.done(function(status) {
                            (!1 === status ? reject : resolve)();
                        });
                    })), this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                    return this.getPromise().then(resolveHandler, rejectHandler);
                },
                catch: function(handler) {
                    return this.getPromise().catch(handler);
                },
                finally: function(handler) {
                    return this.getPromise().finally(handler);
                },
                pause: function() {
                    this.host.pause && this.host.pause();
                },
                resume: function() {
                    this.host.resume && this.host.resume();
                },
                end: function() {
                    this.host.end && this.host.end(), this._resolve(!0);
                },
                cancel: function() {
                    this.host.cancel && this.host.cancel(), this._resolve(!1);
                },
                complete: function(response) {
                    var self = this;
                    0 === self._state && (self._state = 1, self._tick(function() {
                        self._resolve(response);
                    }));
                },
                _resolve: function(response) {
                    2 !== this._state && (forEach(this._doneCallbacks, function(fn) {
                        fn(response);
                    }), this._doneCallbacks.length = 0, this._state = 2);
                }
            }, AnimateRunner;
        } ];
    }
    function $CoreAnimateCssProvider() {
        this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
            return function(element, initialOptions) {
                var options = initialOptions || {};
                (options = !options.$$prepared ? copy(options) : options).cleanupStyles && (options.from = options.to = null), 
                options.from && (element.css(options.from), options.from = null);
                var closed, runner = new $$AnimateRunner();
                return {
                    start: run,
                    end: run
                };
                function run() {
                    return $$rAF(function() {
                        options.addClass && (element.addClass(options.addClass), options.addClass = null), 
                        options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null), 
                        options.to && (element.css(options.to), options.to = null), closed || runner.complete(), 
                        closed = !0;
                    }), runner;
                }
            };
        } ];
    }
    var $AnimateProvider = [ "$provide", function($provide) {
        var provider = this, classNameFilter = null, customFilter = null;
        this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
            if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            var key = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.customFilter = function(filterFn) {
            return customFilter = 1 === arguments.length ? isFunction(filterFn) ? filterFn : null : customFilter;
        }, this.classNameFilter = function(expression) {
            if (1 === arguments.length && (classNameFilter = expression instanceof RegExp ? expression : null, 
            classNameFilter && new RegExp("[(\\s|\\/)]ng-animate[(\\s|\\/)]").test(classNameFilter.toString()))) throw classNameFilter = null, 
            $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', "ng-animate");
            return classNameFilter;
        }, this.$get = [ "$$animateQueue", function($$animateQueue) {
            function domInsert(element, parentElement, afterElement) {
                var afterNode;
                afterElement && (!(afterNode = function(element) {
                    for (var i = 0; i < element.length; i++) {
                        var elm = element[i];
                        if (elm.nodeType === ELEMENT_NODE) return elm;
                    }
                }(afterElement)) || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null)), 
                afterElement ? afterElement.after(element) : parentElement.prepend(element);
            }
            return {
                on: $$animateQueue.on,
                off: $$animateQueue.off,
                pin: $$animateQueue.pin,
                enabled: $$animateQueue.enabled,
                cancel: function(runner) {
                    runner.cancel && runner.cancel();
                },
                enter: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), domInsert(element, parent = parent || after.parent(), after), 
                    $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                },
                move: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), domInsert(element, parent = parent || after.parent(), after), 
                    $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                },
                leave: function(element, options) {
                    return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                        element.remove();
                    });
                },
                addClass: function(element, className, options) {
                    return (options = prepareAnimateOptions(options)).addClass = mergeClasses(options.addclass, className), 
                    $$animateQueue.push(element, "addClass", options);
                },
                removeClass: function(element, className, options) {
                    return (options = prepareAnimateOptions(options)).removeClass = mergeClasses(options.removeClass, className), 
                    $$animateQueue.push(element, "removeClass", options);
                },
                setClass: function(element, add, remove, options) {
                    return (options = prepareAnimateOptions(options)).addClass = mergeClasses(options.addClass, add), 
                    options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options);
                },
                animate: function(element, from, to, className, options) {
                    return (options = prepareAnimateOptions(options)).from = options.from ? extend(options.from, from) : from, 
                    options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", 
                    options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options);
                }
            };
        } ];
    } ];
    function Browser(window, document, $log, $sniffer, $$taskTrackerFactory) {
        var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {}, taskTracker = $$taskTrackerFactory($log);
        self.isMock = !1, self.$$completeOutstandingRequest = taskTracker.completeTask, 
        self.$$incOutstandingRequestCount = taskTracker.incTaskCount, self.notifyWhenNoOutstandingRequests = taskTracker.notifyWhenNoPendingTasks;
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = $sniffer.history ? function() {
            try {
                return history.state;
            } catch (e) {}
        } : noop;
        cacheState(), self.url = function(url, replace, state) {
            if (void 0 === state && (state = null), location !== window.location && (location = window.location), 
            history !== window.history && (history = window.history), url) {
                var sameState = lastHistoryState === state;
                if (url = urlResolve(url).href, lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url), 
                replace ? location.replace(url) : sameBase ? location.hash = function(url) {
                    var index = url.indexOf("#");
                    return -1 === index ? "" : url.substr(index);
                }(url) : location.href = url, location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), 
                cacheState()), pendingLocation = pendingLocation && url, self;
            }
            return (pendingLocation || location.href).replace(/#$/, "");
        }, self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = !1;
        function cacheStateAndFireUrlChange() {
            pendingLocation = null, fireStateOrUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
            equals(cachedState = void 0 === (cachedState = getCurrentState()) ? null : cachedState, lastCachedState) && (cachedState = lastCachedState), 
            lastHistoryState = lastCachedState = cachedState;
        }
        function fireStateOrUrlChange() {
            var prevLastHistoryState = lastHistoryState;
            cacheState(), lastBrowserUrl === self.url() && prevLastHistoryState === cachedState || (lastBrowserUrl = self.url(), 
            lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            }));
        }
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), 
            jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), 
            urlChangeListeners.push(callback), callback;
        }, self.$$applicationDestroyed = function() {
            jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
        }, self.$$checkUrlChange = fireStateOrUrlChange, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : "";
        }, self.defer = function(fn, delay, taskType) {
            var timeoutId;
            return delay = delay || 0, taskType = taskType || taskTracker.DEFAULT_TASK_TYPE, 
            taskTracker.incTaskCount(taskType), timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], taskTracker.completeTask(fn, taskType);
            }, delay), pendingDeferIds[timeoutId] = taskType, timeoutId;
        }, self.defer.cancel = function(deferId) {
            if (pendingDeferIds.hasOwnProperty(deferId)) {
                var taskType = pendingDeferIds[deferId];
                return delete pendingDeferIds[deferId], clearTimeout(deferId), taskTracker.completeTask(noop, taskType), 
                !0;
            }
            return !1;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", "$$taskTrackerFactory", function($window, $log, $sniffer, $document, $$taskTrackerFactory) {
            return new Browser($window, $document, $log, $sniffer, $$taskTrackerFactory);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (void 0 !== value) return capacity < Number.MAX_VALUE && refresh(lruHash[key] || (lruHash[key] = {
                            key: key
                        })), key in data || size++, data[key] = value, capacity < size && this.remove(staleEnd.key), 
                        value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry === freshEnd && (freshEnd = lruEntry.p), lruEntry === staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        key in data && (delete data[key], size--);
                    },
                    removeAll: function() {
                        data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        lruHash = stats = data = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
                function refresh(entry) {
                    entry !== freshEnd && (staleEnd ? staleEnd === entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), (freshEnd = entry).n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry !== prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
            }
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    var $compileMinErr = minErr("$compile"), _UNINITIALIZED_VALUE = new function() {}();
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = function(str) {
            for (var obj = {}, items = str.split(","), i = 0; i < items.length; i++) obj[items[i]] = !0;
            return obj;
        }("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/, bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/, bindings = createMap();
            return forEach(scope, function(definition, scopeName) {
                if ((definition = definition.trim()) in bindingCache) bindings[scopeName] = bindingCache[definition]; else {
                    var match = definition.match(LOCAL_REGEXP);
                    if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                    bindings[scopeName] = {
                        mode: match[1][0],
                        collection: "*" === match[2],
                        optional: "?" === match[3],
                        attrName: match[4] || scopeName
                    }, match[4] && (bindingCache[definition] = bindings[scopeName]);
                }
            }), bindings;
        }
        this.directive = function registerDirective(name, directiveFactory) {
            return assertArg(name, "name"), assertNotHasOwnProperty(name, "directive"), isString(name) ? (function(name) {
                var letter = name.charAt(0);
                if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
                if (name !== name.trim()) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
            }(name), assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], 
            $provide.factory(name + "Directive", [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = function(directive) {
                            var require = directive.require || directive.controller && directive.name;
                            return !isArray(require) && isObject(require) && forEach(require, function(value, key) {
                                var match = value.match(REQUIRE_PREFIX_REGEXP);
                                value.substring(match[0].length) || (require[key] = match[0] + key);
                            }), require;
                        }(directive), directive.restrict = function(restrict, name) {
                            if (restrict && (!isString(restrict) || !/[EACM]/.test(restrict))) throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
                            return restrict || "EA";
                        }(directive.restrict, name), directive.$$moduleName = directiveFactory.$$moduleName, 
                        directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.component = function registerComponent(name, options) {
            if (!isString(name)) return forEach(name, reverseParams(bind(this, registerComponent))), 
            this;
            var controller = options.controller || function() {};
            function factory($injector) {
                function makeInjectable(fn) {
                    return isFunction(fn) || isArray(fn) ? function(tElement, tAttrs) {
                        return $injector.invoke(fn, this, {
                            $element: tElement,
                            $attrs: tAttrs
                        });
                    } : fn;
                }
                var template = options.template || options.templateUrl ? options.template : "", ddo = {
                    controller: controller,
                    controllerAs: function(match, ident) {
                        if (ident && isString(ident)) return ident;
                        if (isString(match)) {
                            match = CNTRL_REG.exec(match);
                            if (match) return match[3];
                        }
                    }(options.controller) || options.controllerAs || "$ctrl",
                    template: makeInjectable(template),
                    templateUrl: makeInjectable(options.templateUrl),
                    transclude: options.transclude,
                    scope: {},
                    bindToController: options.bindings || {},
                    restrict: "E",
                    require: options.require
                };
                return forEach(options, function(val, key) {
                    "$" === key.charAt(0) && (ddo[key] = val);
                }), ddo;
            }
            return forEach(options, function(val, key) {
                "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val));
            }), factory.$inject = [ "$injector" ], this.directive(name, factory);
        }, this.aHrefSanitizationTrustedUrlList = function(regexp) {
            return void 0 !== regexp ? ($$sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList();
        }, Object.defineProperty(this, "aHrefSanitizationWhitelist", {
            get: function() {
                return this.aHrefSanitizationTrustedUrlList;
            },
            set: function(value) {
                this.aHrefSanitizationTrustedUrlList = value;
            }
        }), this.imgSrcSanitizationTrustedUrlList = function(regexp) {
            return void 0 !== regexp ? ($$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList();
        }, Object.defineProperty(this, "imgSrcSanitizationWhitelist", {
            get: function() {
                return this.imgSrcSanitizationTrustedUrlList;
            },
            set: function(value) {
                this.imgSrcSanitizationTrustedUrlList = value;
            }
        });
        var debugInfoEnabled = !0, strictComponentBindingsEnabled = !(this.debugInfoEnabled = function(enabled) {
            return void 0 !== enabled ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
        });
        this.strictComponentBindingsEnabled = function(enabled) {
            return void 0 !== enabled ? (strictComponentBindingsEnabled = enabled, this) : strictComponentBindingsEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
            return arguments.length ? (TTL = value, this) : TTL;
        };
        var commentDirectivesEnabledConfig = !0;
        this.commentDirectivesEnabled = function(value) {
            return arguments.length ? (commentDirectivesEnabledConfig = value, this) : commentDirectivesEnabledConfig;
        };
        var cssClassDirectivesEnabledConfig = !0;
        this.cssClassDirectivesEnabled = function(value) {
            return arguments.length ? (cssClassDirectivesEnabledConfig = value, this) : cssClassDirectivesEnabledConfig;
        };
        var PROP_CONTEXTS = createMap();
        function registerContext(ctx, values) {
            forEach(values, function(v) {
                PROP_CONTEXTS[v.toLowerCase()] = ctx;
            });
        }
        this.addPropertySecurityContext = function(elementName, propertyName, ctx) {
            var key = elementName.toLowerCase() + "|" + propertyName.toLowerCase();
            if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) throw $compileMinErr("ctxoverride", "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.", elementName, propertyName, PROP_CONTEXTS[key], ctx);
            return PROP_CONTEXTS[key] = ctx, this;
        }, registerContext(SCE_CONTEXTS.HTML, [ "iframe|srcdoc", "*|innerHTML", "*|outerHTML" ]), 
        registerContext(SCE_CONTEXTS.CSS, [ "*|style" ]), registerContext(SCE_CONTEXTS.URL, [ "area|href", "area|ping", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "input|src", "ins|cite", "q|cite" ]), 
        registerContext(SCE_CONTEXTS.MEDIA_URL, [ "audio|src", "img|src", "img|srcset", "source|src", "source|srcset", "track|src", "video|src", "video|poster" ]), 
        registerContext(SCE_CONTEXTS.RESOURCE_URL, [ "*|formAction", "applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "form|action", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src" ]), 
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
            var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/, specialAttrHolder = window.document.createElement("div"), commentDirectivesEnabled = commentDirectivesEnabledConfig, cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig, onChangesTtl = TTL;
            function flushOnChangesQueue() {
                try {
                    if (!--onChangesTtl) throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                    $rootScope.$apply(function() {
                        for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) try {
                            onChangesQueue[i]();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        onChangesQueue = void 0;
                    });
                } finally {
                    onChangesTtl++;
                }
            }
            function sanitizeSrcset(lastTuple, trimmedSrcset) {
                if (!lastTuple) return lastTuple;
                if (!isString(lastTuple)) throw $compileMinErr("srcset", 'Can\'t pass trusted values to `{0}`: "{1}"', trimmedSrcset, lastTuple.toString());
                for (var result = "", trimmedSrcset = trim(lastTuple), lastTuple = /\s/.test(trimmedSrcset) ? /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/ : /(,)/, rawUris = trimmedSrcset.split(lastTuple), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; i < nbrUrisWith2parts; i++) {
                    var innerIdx = 2 * i;
                    result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx])), result += " " + trim(rawUris[1 + innerIdx]);
                }
                lastTuple = trim(rawUris[2 * i]).split(/\s/);
                return result += $sce.getTrustedMediaUrl(trim(lastTuple[0])), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), 
                result;
            }
            function Attributes(element, attributesToCopy) {
                if (attributesToCopy) for (var key, keys = Object.keys(attributesToCopy), i = 0, l = keys.length; i < l; i++) this[key = keys[i]] = attributesToCopy[key]; else this.$attr = {};
                this.$$element = element;
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && 0 < classVal.length && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && 0 < classVal.length && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(toRemove, oldClasses) {
                    var toAdd = tokenDifference(toRemove, oldClasses);
                    toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                    toRemove = tokenDifference(oldClasses, toRemove);
                    toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                },
                $set: function(key, value, writeAttr, $$observers) {
                    var booleanKey = getBooleanAttrName(this.$$element[0], key), aliasedKey = ALIASED_ATTR[key], observer = key;
                    booleanKey ? (this.$$element.prop(key, value), $$observers = booleanKey) : aliasedKey && (this[aliasedKey] = value, 
                    observer = aliasedKey), this[key] = value, $$observers ? this.$attr[key] = $$observers : ($$observers = this.$attr[key]) || (this.$attr[key] = $$observers = snake_case(key, "-")), 
                    "img" === nodeName_(this.$$element) && "srcset" === key && (this[key] = value = sanitizeSrcset(value, "$set('srcset', value)")), 
                    !1 !== writeAttr && (null == value ? this.$$element.removeAttr($$observers) : SIMPLE_ATTR_NAME.test($$observers) ? booleanKey && !1 === value ? this.$$element.removeAttr($$observers) : this.$$element.attr($$observers, value) : function(element, attribute, value) {
                        specialAttrHolder.innerHTML = "<span " + attribute + ">";
                        var attributes = specialAttrHolder.firstChild.attributes, attribute = attributes[0];
                        attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute);
                    }(this.$$element[0], $$observers, value));
                    $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        !listeners.$$inter && attrs.hasOwnProperty(key) && void 0 !== attrs[key] && fn(attrs[key]);
                    }), function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" === startSymbol && "}}" === endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_PREFIX_BINDING = /^ng(Attr|Prop|On)([A-Z].*)$/, MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
            return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                var bindings = $element.data("$binding") || [];
                isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), 
                $element.data("$binding", bindings);
            } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                safeAddClass($element, "ng-binding");
            } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, dataName) {
                dataName = isolated ? dataName ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop, compile.$$createComment = function(directiveName, comment) {
                var content = "";
                return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")), 
                window.document.createComment(content);
            }, compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compositeLinkFn = compileNodes($compileNodes = !($compileNodes instanceof jqLite) ? jqLite($compileNodes) : $compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function(scope, cloneConnectFn, futureParentElement) {
                    if (!$compileNodes) throw $compileMinErr("multilink", "This element has already been linked.");
                    assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new());
                    var $linkNode, parentBoundTranscludeFn = (futureParentElement = futureParentElement || {}).parentBoundTranscludeFn, transcludeControllers = futureParentElement.transcludeControllers, futureParentElement = futureParentElement.futureParentElement;
                    if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), 
                    $linkNode = "html" !== (namespace = namespace || function(node) {
                        node = node && node[0];
                        return node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html";
                    }(futureParentElement)) ? jqLite(wrapTemplate(namespace, jqLite("<div></div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, 
                    transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), 
                    compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    cloneConnectFn || ($compileNodes = compositeLinkFn = null), $linkNode;
                };
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                for (var nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, i = 0; i < nodeList.length; i++) childLinkFn = new Attributes(), 
                11 === msie && function(nodeList, idx, notLiveList) {
                    var sibling, node = nodeList[idx], parent = node.parentNode;
                    if (node.nodeType === NODE_TYPE_TEXT) for (;(sibling = parent ? node.nextSibling : nodeList[idx + 1]) && sibling.nodeType === NODE_TYPE_TEXT; ) node.nodeValue = node.nodeValue + sibling.nodeValue, 
                    sibling.parentNode && sibling.parentNode.removeChild(sibling), notLiveList && sibling === nodeList[idx + 1] && nodeList.splice(idx + 1, 1);
                }(nodeList, i, notLiveList), (nodeLinkFn = (nodeLinkFn = collectDirectives(nodeList[i], [], childLinkFn, 0 === i ? maxPriority : void 0, ignoreDirective)).length ? applyDirectivesToNode(nodeLinkFn, nodeList[i], childLinkFn, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null) && nodeLinkFn.scope && compile.$$addScopeClass(childLinkFn.$$element), 
                childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, 
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                return linkFnFound ? function(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], 
                        stableNodeList[idx] = nodeList[idx];
                    } else stableNodeList = nodeList;
                    for (i = 0, ii = linkFns.length; i < ii; ) node = stableNodeList[linkFns[i++]], 
                    nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
                    compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn);
                } : null;
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    return transcludedScope || ((transcludedScope = scope.$new(!1, containingScope)).$$transcluded = !0), 
                    transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                }
                var slotName, boundSlots = boundTranscludeFn.$$slots = createMap();
                for (slotName in transcludeFn.$$slots) transcludeFn.$$slots[slotName] ? boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : boundSlots[slotName] = null;
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, nodeName, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName = nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var multiElementMatch, attr, nName, attrStartName = !1, attrEndName = !1, isNgAttr = !1, isNgProp = !1, isNgEvent = !1, name = (attr = nAttrs[j]).name, value = attr.value;
                        (multiElementMatch = (nName = directiveNormalize(name.toLowerCase())).match(NG_PREFIX_BINDING)) ? (isNgAttr = "Attr" === multiElementMatch[1], 
                        isNgProp = "Prop" === multiElementMatch[1], isNgEvent = "On" === multiElementMatch[1], 
                        name = name.replace(PREFIX_REGEXP, "").toLowerCase().substr(4 + multiElementMatch[1].length).replace(/_(.)/g, function(match, letter) {
                            return letter.toUpperCase();
                        })) : (multiElementMatch = nName.match(MULTI_ELEMENT_DIR_RE)) && function(name) {
                            if (hasDirectives.hasOwnProperty(name)) for (var directives = $injector.get(name + "Directive"), i = 0, ii = directives.length; i < ii; i++) if (directives[i].multiElement) return !0;
                            return !1;
                        }(multiElementMatch[1]) && (attrEndName = (attrStartName = name).substr(0, name.length - 5) + "end", 
                        name = name.substr(0, name.length - 6)), isNgProp || isNgEvent ? (attrs[nName] = value, 
                        attrsMap[nName] = attr.name, isNgProp ? function(trustedContext, directives, attrName, propName) {
                            if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) throw $compileMinErr("nodomevents", "Property bindings for HTML DOM event properties are disallowed");
                            var nodeName = nodeName_(trustedContext), trustedContext = function(nodeName, prop) {
                                prop = prop.toLowerCase();
                                return PROP_CONTEXTS[nodeName + "|" + prop] || PROP_CONTEXTS["*|" + prop];
                            }(nodeName, propName), sanitizer = identity;
                            "srcset" !== propName || "img" !== nodeName && "source" !== nodeName ? trustedContext && (sanitizer = $sce.getTrusted.bind($sce, trustedContext)) : sanitizer = sanitizeSrcsetPropertyValue, 
                            directives.push({
                                priority: 100,
                                compile: function(_, attr) {
                                    var ngPropGetter = $parse(attr[attrName]), ngPropWatch = $parse(attr[attrName], function(val) {
                                        return $sce.valueOf(val);
                                    });
                                    return {
                                        pre: function(scope, $element) {
                                            function applyPropValue() {
                                                var propValue = ngPropGetter(scope);
                                                $element[0][propName] = sanitizer(propValue);
                                            }
                                            applyPropValue(), scope.$watch(ngPropWatch, applyPropValue);
                                        }
                                    };
                                }
                            });
                        }(node, directives, nName, name) : function(directives) {
                            directives.push(createEventDirective($parse, $rootScope, $exceptionHandler, nName, name, !1));
                        }(directives)) : (attrsMap[nName = directiveNormalize(name.toLowerCase())] = name, 
                        !isNgAttr && attrs.hasOwnProperty(nName) || (attrs[nName] = value, getBooleanAttrName(node, nName) && (attrs[nName] = !0)), 
                        function(node, directives, value, name, isNgAttr) {
                            var nodeName = nodeName_(node), trustedContext = function(nodeName, attrNormalizedName) {
                                if ("srcdoc" === attrNormalizedName) return $sce.HTML;
                                return "src" === attrNormalizedName || "ngSrc" === attrNormalizedName ? -1 === [ "img", "video", "audio", "source", "track" ].indexOf(nodeName) ? $sce.RESOURCE_URL : $sce.MEDIA_URL : "xlinkHref" === attrNormalizedName ? "image" === nodeName ? $sce.MEDIA_URL : "a" === nodeName ? $sce.URL : $sce.RESOURCE_URL : "form" === nodeName && "action" === attrNormalizedName || "base" === nodeName && "href" === attrNormalizedName || "link" === nodeName && "href" === attrNormalizedName ? $sce.RESOURCE_URL : "a" !== nodeName || "href" !== attrNormalizedName && "ngHref" !== attrNormalizedName ? void 0 : $sce.URL;
                            }(nodeName, name), mustHaveExpression = !isNgAttr, allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr, interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                            if (interpolateFn) {
                                if ("multiple" === name && "select" === nodeName) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed");
                                directives.push({
                                    priority: 100,
                                    compile: function() {
                                        return {
                                            pre: function(scope, element, attr) {
                                                var $$observers = attr.$$observers || (attr.$$observers = createMap()), newValue = attr[name];
                                                newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), 
                                                value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, 
                                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                                    "class" === name && newValue !== oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                                }));
                                            }
                                        };
                                    }
                                });
                            }
                        }(node, directives, value, nName, isNgAttr), addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName));
                    }
                    if ("input" === nodeName && "hidden" === node.getAttribute("type") && node.setAttribute("autocomplete", "off"), 
                    !cssClassDirectivesEnabled) break;
                    if (isString(className = isObject(className = node.className) ? className.animVal : className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) addDirective(directives, nName = directiveNormalize(match[2]), "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case NODE_TYPE_TEXT:
                    !function(directives, text) {
                        var interpolateFn = $interpolate(text, !0);
                        interpolateFn && directives.push({
                            priority: 0,
                            compile: function(templateNodeParent) {
                                var templateNodeParent = templateNodeParent.parent(), hasCompileParent = !!templateNodeParent.length;
                                return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                                    var parent = node.parent();
                                    hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), 
                                    scope.$watch(interpolateFn, function(value) {
                                        node[0].nodeValue = value;
                                    });
                                };
                            }
                        });
                    }(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    if (!commentDirectivesEnabled) break;
                    !function(node, directives, attrs, maxPriority, ignoreDirective) {
                        try {
                            var nName, match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                            match && (nName = directiveNormalize(match[1]), addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])));
                        } catch (e) {}
                    }(node, directives, attrs, maxPriority, ignoreDirective);
                }
                return directives.sort(byPriority), directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                    } while (node.nodeType === NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, 
                    node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling, 
                    0 < depth);
                } else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function() {
                    return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext), 
                    $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; i < ii; i++) {
                    var attrStart = (directive = directives[i]).$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0, 
                    terminalPriority > directive.priority) break;
                    if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), 
                    newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), 
                    newScopeDirective = newScopeDirective || directive), directiveName = directive.name, 
                    !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                        for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                            mightHaveMultipleTransclusionError = !0;
                            break;
                        }
                        didScanForMultipleTransclusion = !0;
                    }
                    if (!directive.templateUrl && directive.controller && (controllerDirectives = controllerDirectives || createMap(), 
                    assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), directiveValue = directive.transclude) if (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" === directiveValue) hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                    childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }); else {
                        var slots = createMap();
                        if (isObject(directiveValue)) {
                            $template = window.document.createDocumentFragment();
                            var slotName, slotCompileNodes, slotMap = createMap(), filledSlots = createMap();
                            for (slotName in forEach(directiveValue, function(elementSelector, slotName) {
                                var optional = "?" === elementSelector.charAt(0);
                                elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName, 
                                slots[slotName] = null, filledSlots[slotName] = optional;
                            }), forEach($compileNode.contents(), function(node) {
                                var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || window.document.createDocumentFragment(), 
                                slots[slotName].appendChild(node)) : $template.appendChild(node);
                            }), forEach(filledSlots, function(filled, slotName) {
                                if (!filled) throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                            }), slots) slots[slotName] && (slotCompileNodes = jqLite(slots[slotName].childNodes), 
                            slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slotCompileNodes, transcludeFn));
                            $template = jqLite($template.childNodes);
                        } else $template = jqLite(jqLiteClone(compileNode)).contents();
                        $compileNode.empty(), (childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {
                            needsNewScope: directive.$$isolateScope || directive.$$newScope
                        })).$$slots = slots;
                    }
                    if (directive.template) if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    directiveValue = isFunction((templateDirective = directive).template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), 
                        compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective), 
                        directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    (templateDirective = directive).replace && (replaceDirective = directive), nodeLinkFn = function(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                            templateUrl: null,
                            transclude: null,
                            replace: null,
                            $$originalDirective: origAsyncDirective
                        }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                        return $compileNode.empty(), $templateRequest(templateUrl).then(function(content) {
                            var compileNode, tempTemplateAttrs;
                            if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                                if (templateDirectives = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), 
                                compileNode = templateDirectives[0], 1 !== templateDirectives.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                tempTemplateAttrs = {
                                    $attr: {}
                                }, replaceWith($rootElement, $compileNode, compileNode);
                                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0), 
                                directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                            } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                            for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                            forEach($rootElement, function(node, i) {
                                node === compileNode && ($rootElement[i] = $compileNode[0]);
                            }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                                var oldClasses, scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), childBoundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                                scope.$$destroyed || (beforeTemplateLinkNode !== beforeTemplateCompileNode && (oldClasses = beforeTemplateLinkNode.className, 
                                previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses)), 
                                childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, childBoundTranscludeFn) : childBoundTranscludeFn, 
                                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn));
                            }
                            linkQueue = null;
                        }).catch(function(error) {
                            isError(error) && $exceptionHandler(error);
                        }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                            var childBoundTranscludeFn = boundTranscludeFn;
                            scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)));
                        };
                    }(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                        var context = directive.$$originalDirective || directive;
                        isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && !0 === newScopeDirective.scope, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && ((pre = attrStart ? groupElementsLinkFnWrapper(pre, attrStart, attrEnd) : pre).require = directive.require, 
                    pre.directiveName = directiveName, newIsolateScopeDirective !== directive && !directive.$$isolateScope || (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && ((post = attrStart ? groupElementsLinkFnWrapper(post, attrStart, attrEnd) : post).require = directive.require, 
                    post.directiveName = directiveName, newIsolateScopeDirective !== directive && !directive.$$isolateScope || (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo, name;
                    for (name in compileNode === linkNode ? $element = (attrs = templateAttrs).$$element : attrs = new Attributes($element = jqLite(linkNode), templateAttrs), 
                    controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent), 
                    boundTranscludeFn && ((transcludeFn = function(scope, cloneAttachFn, futureParentElement, slotName) {
                        var transcludeControllers;
                        isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn, 
                        cloneAttachFn = scope, scope = void 0);
                        hasElementTranscludeDirective && (transcludeControllers = elementControllers);
                        futureParentElement = futureParentElement || (hasElementTranscludeDirective ? $element.parent() : $element);
                        {
                            if (!slotName) return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                            if (slotTranscludeFn) return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            if (void 0 === slotTranscludeFn) throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element));
                        }
                    }).$$boundTransclude = boundTranscludeFn, transcludeFn.isSlotFilled = function(slotName) {
                        return !!boundTranscludeFn.$$slots[slotName];
                    }), controllerDirectives && (elementControllers = function($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                        var controllerKey, elementControllers = createMap();
                        for (controllerKey in controllerDirectives) {
                            var directive = controllerDirectives[controllerKey], controllerInstance = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            }, controller = directive.controller;
                            "@" === controller && (controller = attrs[directive.name]);
                            controllerInstance = $controller(controller, controllerInstance, !0, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                        }
                        return elementControllers;
                    }($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)), 
                    newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), 
                    compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, 
                    (scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective)).removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches)), 
                    elementControllers) {
                        var controllerDirective = controllerDirectives[name], controller = elementControllers[name], bindings = controllerDirective.$$bindings.bindToController;
                        controller.instance = controller(), $element.data("$" + controllerDirective.name + "Controller", controller.instance), 
                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                    }
                    for (forEach(controllerDirectives, function(controllerDirective, name) {
                        var require = controllerDirective.require;
                        controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                    }), forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$onChanges)) try {
                            controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        if (isFunction(controllerInstance.$onInit)) try {
                            controllerInstance.$onInit();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        isFunction(controllerInstance.$doCheck) && (controllerScope.$watch(function() {
                            controllerInstance.$doCheck();
                        }), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", function() {
                            controllerInstance.$onDestroy();
                        });
                    }), i = 0, ii = preLinkFns.length; i < ii; i++) invokeLinkFn(linkFn = preLinkFns[i], linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn), 
                    i = postLinkFns.length - 1; 0 <= i; i--) invokeLinkFn(linkFn = postLinkFns[i], linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    forEach(elementControllers, function(controllerInstance) {
                        controllerInstance = controllerInstance.instance;
                        isFunction(controllerInstance.$postLink) && controllerInstance.$postLink();
                    });
                }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
                if (isString(require)) {
                    var value, dataName = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(dataName[0].length), inheritType = dataName[1] || dataName[3], optional = "?" === dataName[2];
                    if ("^^" === inheritType ? $element = $element.parent() : value = (value = elementControllers && elementControllers[name]) && value.instance, 
                    value || (dataName = "$" + name + "Controller", value = "^^" === inheritType && $element[0] && $element[0].nodeType === NODE_TYPE_DOCUMENT ? null : inheritType ? $element.inheritedData(dataName) : $element.data(dataName)), 
                    !value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                } else if (isArray(require)) {
                    value = [];
                    for (var i = 0, ii = require.length; i < ii; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                } else isObject(require) && (value = {}, forEach(require, function(controller, property) {
                    value[property] = getControllers(directiveName, controller, $element, elementControllers);
                }));
                return value || null;
            }
            function markDirectiveScope(directives, isolateScope, newScope) {
                for (var j = 0, jj = directives.length; j < jj; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: isolateScope,
                    $$newScope: newScope
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name !== ignoreDirective) {
                    var match = null;
                    if (hasDirectives.hasOwnProperty(name)) for (var directives = $injector.get(name + "Directive"), i = 0, ii = directives.length; i < ii; i++) {
                        var bindings, directive = directives[i];
                        (void 0 === maxPriority || maxPriority > directive.priority) && -1 !== directive.restrict.indexOf(location) && ((directive = startAttrName ? inherit(directive, {
                            $$start: startAttrName,
                            $$end: endAttrName
                        }) : directive).$$bindings || (bindings = directive.$$bindings = function(directive, directiveName) {
                            var bindings = {
                                isolateScope: null,
                                bindToController: null
                            };
                            if (isObject(directive.scope) && (!0 === directive.bindToController ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), 
                            bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), 
                            isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), 
                            bindings.bindToController && !directive.controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                            return bindings;
                        }(directive, directive.name), isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope)), 
                        tDirectives.push(directive), match = directive);
                    }
                    return match;
                }
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr;
                forEach(dst, function(value, key) {
                    "$" !== key.charAt(0) && (src[key] && src[key] !== value && (value.length ? value += ("style" === key ? ";" : " ") + src[key] : value = src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]));
                });
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 != diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
            function wrapTemplate(type, template) {
                switch (type = lowercase(type || "html")) {
                  case "svg":
                  case "math":
                    var wrapper = window.document.createElement("div");
                    return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function sanitizeSrcsetPropertyValue(value) {
                return sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset");
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; i < ii; i++) if ($rootElement[i] === firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                    j2++) j2 < jj ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                for (var fragment = window.document.createDocumentFragment(), i = 0; i < removeCount; i++) fragment.appendChild(elementsToRemove[i]);
                for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)), 
                jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")), 
                i = 1; i < removeCount; i++) delete elementsToRemove[i];
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function strictBindingsCheck(attrName, directiveName) {
                if (strictComponentBindingsEnabled) throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName);
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                var changes, removeWatchCollection = [], initialChanges = {};
                function recordChanges(key, currentValue, previousValue) {
                    isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue) && (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue), 
                    onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)), 
                    changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue));
                }
                function triggerOnChangesHook() {
                    destination.$onChanges(changes), changes = void 0;
                }
                return forEach(bindings, function(definition, scopeName) {
                    var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName, optional = definition.optional;
                    switch (definition.mode) {
                      case "@":
                        optional || hasOwnProperty.call(attrs, attrName) || (strictBindingsCheck(attrName, directive.name), 
                        destination[scopeName] = attrs[attrName] = void 0), removeWatch = attrs.$observe(attrName, function(value) {
                            var oldValue;
                            (isString(value) || isBoolean(value)) && (oldValue = destination[scopeName], recordChanges(scopeName, value, oldValue), 
                            destination[scopeName] = value);
                        }), attrs.$$observers[attrName].$$scope = scope, isString(lastValue = attrs[attrName]) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue), 
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "=":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : simpleCompare, 
                        parentSet = parentGet.assign || function() {
                            throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                        }, lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function(parentValue) {
                            return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), 
                            lastValue = parentValue;
                        };
                        parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), 
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "<":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        var isLiteral = (parentGet = $parse(attrs[attrName])).literal, initialValue = destination[scopeName] = parentGet(scope);
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                        removeWatch = scope[definition.collection ? "$watchCollection" : "$watch"](parentGet, function(newValue, oldValue) {
                            if (oldValue === newValue) {
                                if (oldValue === initialValue || isLiteral && equals(oldValue, initialValue)) return;
                                oldValue = initialValue;
                            }
                            recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue;
                        }), removeWatchCollection.push(removeWatch);
                        break;

                      case "&":
                        if (optional || hasOwnProperty.call(attrs, attrName) || strictBindingsCheck(attrName, directive.name), 
                        (parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop) === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                    }
                }), {
                    initialChanges: initialChanges,
                    removeWatches: removeWatchCollection.length && function() {
                        for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) removeWatchCollection[i]();
                    }
                };
            }
        } ];
    }
    function SimpleChange(previous, current) {
        this.previousValue = previous, this.currentValue = current;
    }
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ], SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
    };
    var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i, SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
    function directiveNormalize(name) {
        return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        });
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
            values += (0 < values.length ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        var i = (jqNodes = jqLite(jqNodes)).length;
        if (i <= 1) return jqNodes;
        for (;i--; ) {
            var node = jqNodes[i];
            (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && "" === node.nodeValue.trim()) && splice.call(jqNodes, i, 1);
        }
        return jqNodes;
    }
    var $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
    function $ControllerProvider() {
        var controllers = {};
        this.has = function(name) {
            return controllers.hasOwnProperty(name);
        }, this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.$get = [ "$injector", function($injector) {
            return function(expression, locals, controllerPrototype, match) {
                var constructor, identifier;
                if (controllerPrototype = !0 === controllerPrototype, match && isString(match) && (identifier = match), 
                isString(expression)) {
                    if (!(match = expression.match(CNTRL_REG))) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                    if (constructor = match[1], identifier = identifier || match[3], !(expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : function(obj, path, bindFnToScope) {
                        if (!path) return obj;
                        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; i < len; i++) key = keys[i], 
                        obj = obj && (lastInstance = obj)[key];
                        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
                    }(locals.$scope, constructor, !0))) throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                    assertArgFn(expression, constructor, !0);
                }
                if (controllerPrototype) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype, instance = Object.create(controllerPrototype || null);
                    return identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                    extend(function() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, 
                        identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), 
                        instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
                if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                locals.$scope[identifier] = instance;
            }
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $$IsDocumentHiddenProvider() {
        this.$get = [ "$document", "$rootScope", function($document, $rootScope) {
            var doc = $document[0], hidden = doc && doc.hidden;
            function changeListener() {
                hidden = doc.hidden;
            }
            return $document.on("visibilitychange", changeListener), $rootScope.$on("$destroy", function() {
                $document.off("visibilitychange", changeListener);
            }), function() {
                return hidden;
            };
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function $$ForceReflowProvider() {
        this.$get = [ "$document", function($document) {
            return function(domNode) {
                return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, 
                domNode.offsetWidth + 1;
            };
        } ];
    }
    var APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    }, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    }, JSON_PROTECTION_PREFIX = /^\)]\}',?\n/, $httpMinErr = minErr("$http");
    function serializeValue(v) {
        return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v;
    }
    function $HttpParamSerializerProvider() {
        this.$get = function() {
            return function(params) {
                if (!params) return "";
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null == value || isFunction(value) || (isArray(value) ? forEach(value, function(v) {
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                    }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))));
                }), parts.join("&");
            };
        };
    }
    function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
            return function(params) {
                if (!params) return "";
                var parts = [];
                return function serialize(toSerialize, prefix, topLevel) {
                    isArray(toSerialize) ? forEach(toSerialize, function(value, index) {
                        serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                    }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function(value, key) {
                        serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                    }) : (isFunction(toSerialize) && (toSerialize = toSerialize()), parts.push(encodeUriQuery(prefix) + "=" + (null == toSerialize ? "" : encodeUriQuery(serializeValue(toSerialize)))));
                }(params, "", !0), parts.join("&");
            };
        };
    }
    function defaultHttpResponseTransform(data, str) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var jsonStart = str("Content-Type"), hasJsonContentType = jsonStart && 0 === jsonStart.indexOf(APPLICATION_JSON);
                if (hasJsonContentType || (jsonStart = (str = tempData).match(JSON_START)) && JSON_ENDS[jsonStart[0]].test(str)) try {
                    data = fromJson(tempData);
                } catch (e) {
                    if (!hasJsonContentType) return data;
                    throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"', data, e);
                }
            }
        }
        return data;
    }
    function parseHeaders(headers) {
        var i, parsed = createMap();
        function fillInParsed(key, val) {
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
        }
        return isString(headers) ? forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
        }) : isObject(headers) && forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
        }), parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(value) {
            if (headersObj = headersObj || parseHeaders(headers), value) {
                value = headersObj[lowercase(value)];
                return value = void 0 === value ? null : value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
            data = fn(data, headers, status);
        }), data);
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return !isObject(d) || (obj = d, "[object File]" === toString.call(obj)) || function(obj) {
                    return "[object Blob]" === toString.call(obj);
                }(d) || function(obj) {
                    return "[object FormData]" === toString.call(obj);
                }(d) ? d : toJson(d);
                var obj;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer",
            jsonpCallbackParam: "callback"
        }, useApplyAsync = !1;
        this.useApplyAsync = function(value) {
            return void 0 !== value ? (useApplyAsync = !!value, this) : useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [], xsrfTrustedOrigins = this.xsrfTrustedOrigins = [];
        Object.defineProperty(this, "xsrfWhitelistedOrigins", {
            get: function() {
                return this.xsrfTrustedOrigins;
            },
            set: function(origins) {
                this.xsrfTrustedOrigins = origins;
            }
        }), this.$get = [ "$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
            var defaultCache = $cacheFactory("$http");
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            var parsedAllowedOriginUrls, urlIsAllowedOrigin = (parsedAllowedOriginUrls = [ originUrl ].concat(xsrfTrustedOrigins.map(urlResolve)), 
            function(parsedUrl) {
                parsedUrl = urlResolve(parsedUrl);
                return parsedAllowedOriginUrls.some(urlsAreSameOrigin.bind(null, parsedUrl));
            });
            function $http(promise) {
                if (!isObject(promise)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", promise);
                if (!isString($sce.valueOf(promise.url))) throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", promise.url);
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer,
                    jsonpCallbackParam: defaults.jsonpCallbackParam
                }, promise);
                config.headers = function(config) {
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defaultHeadersIteration: for (defHeaderName in defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)])) {
                        for (reqHeaderName in lowercaseDefHeaderName = lowercase(defHeaderName), reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return function(headers, config) {
                        var headerContent, processedHeaders = {};
                        return forEach(headers, function(headerFn, header) {
                            isFunction(headerFn) ? null != (headerContent = headerFn(config)) && (processedHeaders[header] = headerContent) : processedHeaders[header] = headerFn;
                        }), processedHeaders;
                    }(reqHeaders, shallowCopy(config));
                }(promise), config.method = uppercase(config.method), config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer, 
                $browser.$$incOutstandingRequestCount("$http");
                var requestInterceptors = [], responseInterceptors = [], promise = $q.resolve(config);
                return forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError);
                }), promise = chainInterceptors(promise, requestInterceptors), promise = (promise = chainInterceptors(promise = promise.then(function(config) {
                    var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                    void 0 === reqData && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    });
                    void 0 === config.withCredentials && void 0 !== defaults.withCredentials && (config.withCredentials = defaults.withCredentials);
                    return function(config, reqData) {
                        var cache, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, isJsonp = "jsonp" === lowercase(config.method), url = config.url;
                        isJsonp ? url = $sce.getTrustedResourceUrl(url) : isString(url) || (url = $sce.valueOf(url));
                        url = function(url, serializedParams) {
                            0 < serializedParams.length && (url += (-1 === url.indexOf("?") ? "?" : "&") + serializedParams);
                            return url;
                        }(url, config.paramSerializer(config.params)), isJsonp && (url = function(url, cbKey) {
                            var parts = url.split("?");
                            if (2 < parts.length) throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                            return forEach(parseKeyValue(parts[1]), function(value, key) {
                                if ("JSON_CALLBACK" === value) throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                                if (key === cbKey) throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url);
                            }), url += (-1 === url.indexOf("?") ? "?" : "&") + cbKey + "=JSON_CALLBACK";
                        }(url, config.jsonpCallbackParam));
                        $http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                        !config.cache && !defaults.cache || !1 === config.cache || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache);
                        cache && (void 0 !== (xsrfValue = cache.get(url)) ? isPromiseLike(xsrfValue) ? xsrfValue.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(xsrfValue) ? resolvePromise(xsrfValue[1], xsrfValue[0], shallowCopy(xsrfValue[2]), xsrfValue[3], xsrfValue[4]) : resolvePromise(xsrfValue, 200, {}, "OK", "complete") : cache.put(url, promise));
                        {
                            var xsrfValue;
                            void 0 === xsrfValue && ((xsrfValue = urlIsAllowedOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0) && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                            $httpBackend(config.method, url, reqData, function(status, response, headersString, statusText, xhrStatus) {
                                cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText, xhrStatus ]) : cache.remove(url));
                                function resolveHttpPromise() {
                                    resolvePromise(response, status, headersString, statusText, xhrStatus);
                                }
                                useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), 
                                $rootScope.$$phase || $rootScope.$apply());
                            }, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers)));
                        }
                        return promise;
                        function createApplyHandlers(eventHandlers) {
                            if (eventHandlers) {
                                var applyHandlers = {};
                                return forEach(eventHandlers, function(eventHandler, key) {
                                    applyHandlers[key] = function(event) {
                                        function callEventHandler() {
                                            eventHandler(event);
                                        }
                                        useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler);
                                    };
                                }), applyHandlers;
                            }
                        }
                        function resolvePromise(response, status, headers, statusText, xhrStatus) {
                            (isSuccess(status = -1 <= status ? status : 0) ? deferred.resolve : deferred.reject)({
                                data: response,
                                status: status,
                                headers: headersGetter(headers),
                                config: config,
                                statusText: statusText,
                                xhrStatus: xhrStatus
                            });
                        }
                        function resolvePromiseWithResult(result) {
                            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus);
                        }
                        function removePendingReq() {
                            var idx = $http.pendingRequests.indexOf(config);
                            -1 !== idx && $http.pendingRequests.splice(idx, 1);
                        }
                    }(config, reqData).then(transformResponse, transformResponse);
                }), responseInterceptors)).finally(function() {
                    $browser.$$completeOutstandingRequest(noop, "$http");
                });
                function chainInterceptors(promise, interceptors) {
                    for (var i = 0, ii = interceptors.length; i < ii; ) {
                        var thenFn = interceptors[i++], rejectFn = interceptors[i++];
                        promise = promise.then(thenFn, rejectFn);
                    }
                    return interceptors.length = 0, promise;
                }
                function transformResponse(response) {
                    var resp = extend({}, response);
                    return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse), 
                    isSuccess(response.status) ? resp : $q.reject(resp);
                }
            }
            return $http.pendingRequests = [], function() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }("get", "delete", "head", "jsonp"), function() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }("post", "put", "patch"), $http.defaults = defaults, $http;
        } ];
    }
    function $xhrFactoryProvider() {
        this.$get = function() {
            return function() {
                return new window.XMLHttpRequest();
            };
        };
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
            return function($browser, createXhr, $browserDefer, callbacks, rawDocument) {
                return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                    if (url = url || $browser.url(), "jsonp" === lowercase(method)) var callbackPath = callbacks.createCallback(url), jsonpDone = function(url, callbackPath, done) {
                        url = url.replace("JSON_CALLBACK", callbackPath);
                        var script = rawDocument.createElement("script"), callback = null;
                        return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                            script.removeEventListener("load", callback), script.removeEventListener("error", callback), 
                            rawDocument.body.removeChild(script), script = null;
                            var status = -1, text = "unknown";
                            event && (text = (event = "load" === event.type && !callbacks.wasCalled(callbackPath) ? {
                                type: "error"
                            } : event).type, status = "error" === event.type ? 404 : 200), done && done(status, text);
                        }, script.addEventListener("load", callback), script.addEventListener("error", callback), 
                        rawDocument.body.appendChild(script), callback;
                    }(url, callbackPath, function(status, text) {
                        var response = 200 === status && callbacks.getResponse(callbackPath);
                        completeRequest(callback, status, response, "", text, "complete"), callbacks.removeCallback(callbackPath);
                    }); else {
                        var xhr = createXhr(method, url), abortedByTimeout = !1;
                        xhr.open(method, url, !0), forEach(headers, function(value, key) {
                            void 0 !== value && xhr.setRequestHeader(key, value);
                        }), xhr.onload = function() {
                            var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                            0 === status && (status = response ? 200 : "file" === urlResolve(url).protocol ? 404 : 0), 
                            completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete");
                        };
                        if (xhr.onerror = function() {
                            completeRequest(callback, -1, null, null, "", "error");
                        }, xhr.ontimeout = function() {
                            completeRequest(callback, -1, null, null, "", "timeout");
                        }, xhr.onabort = function() {
                            completeRequest(callback, -1, null, null, "", abortedByTimeout ? "timeout" : "abort");
                        }, forEach(eventHandlers, function(value, key) {
                            xhr.addEventListener(key, value);
                        }), forEach(uploadEventHandlers, function(value, key) {
                            xhr.upload.addEventListener(key, value);
                        }), withCredentials && (xhr.withCredentials = !0), responseType) try {
                            xhr.responseType = responseType;
                        } catch (e) {
                            if ("json" !== responseType) throw e;
                        }
                        xhr.send(void 0 === post ? null : post);
                    }
                    var timeoutId;
                    function timeoutRequest(reason) {
                        abortedByTimeout = "timeout" === reason, jsonpDone && jsonpDone(), xhr && xhr.abort();
                    }
                    function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {
                        void 0 !== timeoutId && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 
                        callback(status, response, headersString, statusText, xhrStatus);
                    }
                    0 < timeout ? timeoutId = $browserDefer(function() {
                        timeoutRequest("timeout");
                    }, timeout) : isPromiseLike(timeout) && timeout.then(function() {
                        timeoutRequest(void 0 !== timeout.$$timeoutId ? "timeout" : "abort");
                    });
                };
            }($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
        } ];
    }
    var $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                var unwatch = scope.$watch(function(scope) {
                    return unwatch(), constantInterp(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                var contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
                if (!text.length || -1 === text.indexOf(startSymbol)) {
                    if (mustHaveExpression) return;
                    var constantInterp = unescapeText(text), constantInterp = valueFn(constantInterp = contextAllowsConcatenation ? $sce.getTrusted(trustedContext, constantInterp) : constantInterp);
                    return constantInterp.exp = text, constantInterp.expressions = [], constantInterp.$$watchDelegate = constantWatchDelegate, 
                    constantInterp;
                }
                allOrNothing = !!allOrNothing;
                for (var endIndex, exp, singleExpression, index = 0, expressions = [], textLength = text.length, concat = [], expressionPositions = []; index < textLength; ) {
                    if (-1 === (exp = text.indexOf(startSymbol, index)) || -1 === (endIndex = text.indexOf(endSymbol, exp + startSymbolLength))) {
                        index !== textLength && concat.push(unescapeText(text.substring(index)));
                        break;
                    }
                    index !== exp && concat.push(unescapeText(text.substring(index, exp))), exp = text.substring(exp + startSymbolLength, endIndex), 
                    expressions.push(exp), index = endIndex + endSymbolLength, expressionPositions.push(concat.length), 
                    concat.push("");
                }
                singleExpression = 1 === concat.length && 1 === expressionPositions.length;
                var interceptor = contextAllowsConcatenation && singleExpression ? void 0 : function(value) {
                    try {
                        return value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value), 
                        allOrNothing && void 0 === value ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }, parseFns = expressions.map(function(exp) {
                    return $parse(exp, interceptor);
                });
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && void 0 === values[i]) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return contextAllowsConcatenation ? $sce.getTrusted(trustedContext, singleExpression ? concat[0] : concat.join("")) : (trustedContext && 1 < concat.length && $interpolateMinErr.throwNoconcat(text), 
                        concat.join(""));
                    };
                    return extend(function(context) {
                        var i = 0, ii = expressions.length, values = new Array(ii);
                        try {
                            for (;i < ii; i++) values[i] = parseFns[i](context);
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function(values, oldValues) {
                                var currValue = compute(values);
                                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), 
                                lastValue = currValue;
                            });
                        }
                    });
                }
            }
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
    }, $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    var $intervalMinErr = minErr("$interval");
    function $IntervalProvider() {
        this.$get = [ "$$intervalFactory", "$window", function(interval, $window) {
            function clearIntervalFn(id) {
                $window.clearInterval(id), delete intervals[id];
            }
            var intervals = {}, interval = interval(function(tick, id, deferred) {
                id = $window.setInterval(tick, id);
                return intervals[id] = deferred, id;
            }, clearIntervalFn);
            return interval.cancel = function(deferred) {
                if (!deferred) return !1;
                if (!deferred.hasOwnProperty("$$intervalId")) throw $intervalMinErr("badprom", "`$interval.cancel()` called with a promise that was not generated by `$interval()`.");
                if (!intervals.hasOwnProperty(deferred.$$intervalId)) return !1;
                var id = deferred.$$intervalId, deferred = intervals[id];
                return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), clearIntervalFn(id), 
                !0;
            }, interval;
        } ];
    }
    function $$IntervalFactoryProvider() {
        this.$get = [ "$browser", "$q", "$$q", "$rootScope", function($browser, $q, $$q, $rootScope) {
            return function(setIntervalFn, clearIntervalFn) {
                return function(fn, delay, count, invokeApply) {
                    var hasParams = 4 < arguments.length, args = hasParams ? sliceArgs(arguments, 4) : [], iteration = 0, skipApply = void 0 !== invokeApply && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                    function callback() {
                        hasParams ? fn.apply(null, args) : fn(iteration);
                    }
                    return count = void 0 !== count ? count : 0, promise.$$intervalId = setIntervalFn(function() {
                        skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++), 
                        0 < count && count <= iteration && (deferred.resolve(iteration), clearIntervalFn(promise.$$intervalId)), 
                        skipApply || $rootScope.$apply();
                    }, delay, deferred, skipApply), promise;
                };
            };
        } ];
    }
    function $jsonpCallbacksProvider() {
        this.$get = function() {
            var callbacks = angular.callbacks, callbackMap = {};
            return {
                createCallback: function(url) {
                    var callbackId = "_" + (callbacks.$$counter++).toString(36), callbackPath = "angular.callbacks." + callbackId, callback = function(callbackId) {
                        var callback = function(data) {
                            callback.data = data, callback.called = !0;
                        };
                        return callback.id = callbackId, callback;
                    }(callbackId);
                    return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath;
                },
                wasCalled: function(callbackPath) {
                    return callbackMap[callbackPath].called;
                },
                getResponse: function(callbackPath) {
                    return callbackMap[callbackPath].data;
                },
                removeCallback: function(callbackPath) {
                    var callback = callbackMap[callbackPath];
                    delete callbacks[callback.id], delete callbackMap[callbackPath];
                }
            };
        };
    }
    var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location");
    function normalizePath(pathValue, search, hash) {
        var parts, search = (parts = [], forEach(search, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (!0 === arrayValue ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (!0 === value ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : ""), hash = hash ? "#" + encodeUriSegment(hash) : "";
        return function(path) {
            for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
            return segments.join("/");
        }(pathValue) + (search ? "?" + search : "") + hash;
    }
    function parseAbsoluteUrl(parsedUrl, locationObj) {
        parsedUrl = urlResolve(parsedUrl);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    var DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/;
    function parseAppUrl(match, locationObj, html5Mode) {
        if (DOUBLE_SLASH_REGEX.test(match)) throw $locationMinErr("badpath", 'Invalid url "{0}".', match);
        var path = "/" !== match.charAt(0), match = urlResolve(match = path ? "/" + match : match), path = path && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname;
        locationObj.$$path = function(path, html5Mode) {
            for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = decodeURIComponent(segments[i]), 
            html5Mode && (segments[i] = segments[i].replace(/\//g, "%2F"));
            return segments.join("/");
        }(path, html5Mode), locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
        locationObj.$$path && "/" !== locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function startsWith(str, search) {
        return str.slice(0, search.length) === search;
    }
    function stripBaseUrl(base, url) {
        if (startsWith(url, base)) return url.substr(base.length);
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 === index ? url : url.substr(0, index);
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), 
        this.$$parse = function(url) {
            var pathUrl = stripBaseUrl(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this, !0), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$normalizeUrl = function(url) {
            return appBaseNoFile + url.substr(1);
        }, this.$$parseLinkUrl = function(url, appUrl) {
            return appUrl && "#" === appUrl[0] ? (this.hash(appUrl.slice(1)), !0) : (void 0 !== (appUrl = stripBaseUrl(appBase, url)) ? (rewrittenUrl = appUrl, 
            rewrittenUrl = basePrefix && void 0 !== (appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + rewrittenUrl) : void 0 !== (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl);
            var rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
            void 0 !== withoutBaseUrl && "#" === withoutBaseUrl.charAt(0) ? void 0 === (withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl)) && (withoutHashUrl = withoutBaseUrl) : this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", 
            void 0 === withoutBaseUrl && (appBase = url, this.replace())), parseAppUrl(withoutHashUrl, this, !1), 
            this.$$path = function(path, url, base) {
                var firstPathSegmentMatch = /^\/[A-Z]:(\/.*)/;
                startsWith(url, base) && (url = url.replace(base, ""));
                if (firstPathSegmentMatch.exec(url)) return path;
                return (firstPathSegmentMatch = firstPathSegmentMatch.exec(path)) ? firstPathSegmentMatch[1] : path;
            }(this.$$path, withoutHashUrl, appBase), this.$$compose();
        }, this.$$normalizeUrl = function(url) {
            return appBase + (url ? hashPrefix + url : "");
        }, this.$$parseLinkUrl = function(url, relHref) {
            return stripHash(appBase) === stripHash(url) && (this.$$parse(url), !0);
        };
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, appUrl) {
            return appUrl && "#" === appUrl[0] ? (this.hash(appUrl.slice(1)), !0) : (appBase === stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl);
            var rewrittenUrl;
        }, this.$$normalizeUrl = function(url) {
            return appBase + hashPrefix + url;
        };
    }
    var locationPrototype = {
        $$absUrl: "",
        $$html5: !1,
        $$replace: !1,
        $$compose: function() {
            this.$$url = normalizePath(this.$$path, this.$$search, this.$$hash), this.$$absUrl = this.$$normalizeUrl(this.$$url), 
            this.$$urlUpdatedByLocation = !0;
        },
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (void 0 === url) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return !match[1] && "" !== url || this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), 
            this.hash(match[5] || ""), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return "/" === (path = null !== path ? path.toString() : "").charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    forEach(search = copy(search, {}), function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                null == paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return null !== hash ? hash.toString() : "";
        }),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return void 0 === value ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "!", html5Mode = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(prefix) {
            return void 0 !== prefix ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), 
            isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) && (html5Mode.rewriteLinks = mode.rewriteLinks), 
            this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            var appBase, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                appBase = (LocationMode = initialUrl).substring(0, LocationMode.indexOf("/", LocationMode.indexOf("//") + 2)) + (baseHref || "/"), 
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
            var $location, appBaseNoFile = function(url) {
                return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
            }(appBase);
            ($location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix)).$$parseLinkUrl(initialUrl, initialUrl), 
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url(), oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state), $location.$$state = $browser.state();
                } catch (e) {
                    throw $location.url(oldUrl), $location.$$state = oldState, e;
                }
            }
            $rootElement.on("click", function(event) {
                var relHref = html5Mode.rewriteLinks;
                if (relHref && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 !== event.which && 2 !== event.button) {
                    for (var absHref, elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    isString(relHref) && void 0 === elm.attr(relHref) || (absHref = elm.prop("href"), 
                    relHref = elm.attr("href") || elm.attr("xlink:href"), isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                    IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
                    $location.absUrl() !== $browser.url() && $rootScope.$apply()));
                }
            }), $location.absUrl() !== initialUrl && $browser.url($location.absUrl(), !0);
            var initializing = !0;
            return $browser.onUrlChange(function(newUrl, newState) {
                startsWith(newUrl, appBaseNoFile) ? ($rootScope.$evalAsync(function() {
                    var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                    $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, 
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, 
                    afterLocationChange(oldUrl, oldState)));
                }), $rootScope.$$phase || $rootScope.$digest()) : $window.location.href = newUrl;
            }), $rootScope.$watch(function() {
                var oldUrl, oldState, currentReplace, urlOrStateChanged, a, b;
                (initializing || $location.$$urlUpdatedByLocation) && ($location.$$urlUpdatedByLocation = !1, 
                oldUrl = $browser.url(), b = $location.absUrl(), oldState = $browser.state(), currentReplace = $location.$$replace, 
                urlOrStateChanged = !((a = oldUrl) === (b = b) || urlResolve(a).href === urlResolve(b).href) || $location.$$html5 && $sniffer.history && oldState !== $location.$$state, 
                (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                    var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), 
                    afterLocationChange(oldUrl, oldState)));
                }))), $location.$$replace = !1;
            }), $location;
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return void 0 !== flag ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            var fn, formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: (fn = consoleLog("debug"), function() {
                    debug && fn.apply(self, arguments);
                })
            };
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop;
                return function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(function(arg) {
                            return isError(arg) && (arg.stack && formatStackTrace ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                            arg;
                        }(arg));
                    }), Function.prototype.apply.call(logFn, console, args);
                };
            }
        } ];
    }
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = void 0 === state ? null : state, this.$$urlUpdatedByLocation = !0, 
            this;
        };
    });
    var $parseMinErr = minErr("$parse"), objectValueOf = {}.constructor.prototype.valueOf;
    function getStringValue(name) {
        return name + "";
    }
    var OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = !0;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "\t",
        v: "\v",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                var ch2, ch3, op1, op2, op3, token = this.text.charAt(this.index);
                '"' === token || "'" === token ? this.readString(token) : this.isNumber(token) || "." === token && this.isNumber(this.peek()) ? this.readNumber() : this.isIdentifierStart(this.peekMultichar()) ? this.readIdent() : this.is(token, "(){}[].,;:?") ? (this.tokens.push({
                    index: this.index,
                    text: token
                }), this.index++) : this.isWhitespace(token) ? this.index++ : (ch3 = (ch2 = token + this.peek()) + this.peek(2), 
                op1 = OPERATORS[token], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3], op1 || op2 || op3 ? (token = op3 ? ch3 : op2 ? ch2 : token, 
                this.tokens.push({
                    index: this.index,
                    text: token,
                    operator: !0
                }), this.index += token.length) : this.throwError("Unexpected next character ", this.index, this.index + 1));
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return -1 !== chars.indexOf(ch);
        },
        peek: function(num) {
            num = num || 1;
            return this.index + num < this.text.length && this.text.charAt(this.index + num);
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && "string" == typeof ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "\t" === ch || "\n" === ch || "\v" === ch || "" === ch;
        },
        isIdentifierStart: function(ch) {
            return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || "$" === ch;
        },
        isIdentifierContinue: function(ch) {
            return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
            return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
            return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
        },
        peekMultichar: function() {
            var ch = this.text.charAt(this.index), peek = this.peek();
            if (!peek) return ch;
            var cp1 = ch.charCodeAt(0), cp2 = peek.charCodeAt(0);
            return 55296 <= cp1 && cp1 <= 56319 && 56320 <= cp2 && cp2 <= 57343 ? ch + peek : ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, colStr) {
            colStr = colStr || this.index;
            colStr = void 0 !== start ? "s " + start + "-" + this.index + " [" + this.text.substring(start, colStr) + "]" : " " + colStr;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." === ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" === ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" === number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" !== number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: !0,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            for (this.index += this.peekMultichar().length; this.index < this.text.length; ) {
                var ch = this.peekMultichar();
                if (!this.isIdentifierContinue(ch)) break;
                this.index += ch.length;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: !0
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var hex, ch = this.text.charAt(this.index);
                if (rawString += ch, escape) "u" === ch ? ((hex = this.text.substring(this.index + 1, this.index + 5)).match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                this.index += 4, string += String.fromCharCode(parseInt(hex, 16))) : string += ESCAPE[ch] || ch, 
                escape = !1; else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: !0,
                        value: string
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function(lexer, options) {
        this.lexer = lexer, this.options = options;
    };
    function ifDefined(v, d) {
        return void 0 !== v ? v : d;
    }
    function plusFn(l, r) {
        return void 0 === l ? r : void 0 === r ? l : l + r;
    }
    AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", 
    AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", 
    AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", 
    AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", 
    AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", 
    AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", 
    AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter", 
    AST.prototype = {
        ast: function(value) {
            this.text = value, this.tokens = this.lexer.lex(value);
            value = this.program();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value;
        },
        program: function() {
            for (var body = []; ;) if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: AST.Program,
                body: body
            };
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var left = this.expression(); this.expect("|"); ) left = this.filter(left);
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            if (this.expect("=")) {
                if (!isAssignable(result)) throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                result = {
                    type: AST.AssignmentExpression,
                    left: result,
                    right: this.assignment(),
                    operator: "="
                };
            }
            return result;
        },
        ternary: function() {
            var alternate, consequent, test = this.logicalOR();
            return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), 
            {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
            }) : test;
        },
        logicalOR: function() {
            for (var left = this.logicalAND(); this.expect("||"); ) left = {
                type: AST.LogicalExpression,
                operator: "||",
                left: left,
                right: this.logicalAND()
            };
            return left;
        },
        logicalAND: function() {
            for (var left = this.equality(); this.expect("&&"); ) left = {
                type: AST.LogicalExpression,
                operator: "&&",
                left: left,
                right: this.equality()
            };
            return left;
        },
        equality: function() {
            for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.relational()
            };
            return left;
        },
        relational: function() {
            for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.additive()
            };
            return left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.multiplicative()
            };
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.unary()
            };
            return left;
        },
        unary: function() {
            var token;
            return (token = this.expect("+", "-", "!")) ? {
                type: AST.UnaryExpression,
                operator: token.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var primary, next;
            for (this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                type: AST.Literal,
                value: this.options.literals[this.consume().text]
            } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek()); next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === next.text ? (primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === next.text ? primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return primary;
        },
        filter: function(result) {
            for (var args = [ result ], result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: !0
            }; this.expect(":"); ) args.push(this.expression());
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (")" !== this.peekToken().text) for (;args.push(this.filterChain()), this.expect(","); ) ;
            return args;
        },
        identifier: function() {
            var token = this.consume();
            return token.identifier || this.throwError("is not a valid identifier", token), 
            {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if ("]" !== this.peekToken().text) for (;!this.peek("]") && (elements.push(this.expression()), 
            this.expect(",")); ) ;
            return this.consume("]"), {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var property, properties = [];
            if ("}" !== this.peekToken().text) for (;!this.peek("}") && (property = {
                type: AST.Property,
                kind: "init"
            }, this.peek().constant ? (property.key = this.constant(), property.computed = !1, 
            this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(), 
            property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["), 
            property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"), 
            property.value = this.expression()) : this.throwError("invalid key", this.peek()), 
            properties.push(property), this.expect(",")); ) ;
            return this.consume("}"), {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), 
            token;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(t, e1, e2, e3, e4) {
            if (this.tokens.length > t) {
                var token = this.tokens[t], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, token) {
            token = this.peek(e1, e2, e3, token);
            return !!token && (this.tokens.shift(), token);
        },
        selfReferential: {
            this: {
                type: AST.ThisExpression
            },
            $locals: {
                type: AST.LocalsExpression
            }
        }
    };
    var PURITY_ABSOLUTE = 1, PURITY_RELATIVE = 2;
    function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
        var allConstants, argsToWatch, isStatelessFilter, astIsPure = ast.isPure = function(node, parentIsPure) {
            switch (node.type) {
              case AST.MemberExpression:
                if (node.computed) return !1;
                break;

              case AST.UnaryExpression:
                return PURITY_ABSOLUTE;

              case AST.BinaryExpression:
                return "+" !== node.operator && PURITY_ABSOLUTE;

              case AST.CallExpression:
                return !1;
            }
            return void 0 === parentIsPure ? PURITY_RELATIVE : parentIsPure;
        }(ast, parentIsPure);
        switch (ast.type) {
          case AST.Program:
            allConstants = !0, forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter, astIsPure), allConstants = allConstants && expr.expression.constant;
            }), ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = !0, ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter, astIsPure), ast.constant = ast.argument.constant, 
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter, astIsPure), findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure), 
            findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, 
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = !1, ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter, astIsPure), ast.computed && findConstantAndWatchExpressions(ast.property, $filter, astIsPure), 
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), 
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.CallExpression:
            isStatelessFilter = !!ast.filter && function($filter, filterName) {
                return !$filter(filterName).$stateful;
            }($filter, ast.callee.name), allConstants = isStatelessFilter, argsToWatch = [], 
            forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, 
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, 
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter, astIsPure), allConstants = allConstants && property.value.constant, 
                argsToWatch.push.apply(argsToWatch, property.value.toWatch), property.computed && (findConstantAndWatchExpressions(property.key, $filter, !1), 
                allConstants = allConstants && property.key.constant, argsToWatch.push.apply(argsToWatch, property.key.toWatch));
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
          case AST.LocalsExpression:
            ast.constant = !1, ast.toWatch = [];
        }
    }
    function getInputs(candidate) {
        if (1 === candidate.length) {
            var lastExpression = candidate[0].expression, candidate = lastExpression.toWatch;
            return 1 !== candidate.length || candidate[0] !== lastExpression ? candidate : void 0;
        }
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        if (1 === ast.body.length && isAssignable(ast.body[0].expression)) return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {
                type: AST.NGValueParameter
            },
            operator: "="
        };
    }
    function ASTCompiler($filter) {
        this.$filter = $filter;
    }
    function ASTInterpreter($filter) {
        this.$filter = $filter;
    }
    function Parser(lexer, $filter, options) {
        this.ast = new AST(lexer, options), this.astCompiler = new (options.csp ? ASTInterpreter : ASTCompiler)($filter);
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var identStart, identContinue, cache = createMap(), literals = {
            true: !0,
            false: !1,
            null: null,
            undefined: void 0
        };
        this.addLiteral = function(literalName, literalValue) {
            literals[literalName] = literalValue;
        }, this.setIdentifierFns = function(identifierStart, identifierContinue) {
            return identStart = identifierStart, identContinue = identifierContinue, this;
        }, this.$get = [ "$filter", function($filter) {
            var $parseOptions = {
                csp: csp().noUnsafeEval,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
            };
            return $parse.$$getAst = function(exp) {
                return new Parser(new Lexer($parseOptions), $filter, $parseOptions).getAst(exp).ast;
            }, $parse;
            function $parse(exp, interceptorFn) {
                var cacheKey, parsedExpression;
                switch (typeof exp) {
                  case "string":
                    return exp = exp.trim(), (parsedExpression = cache[cacheKey = exp]) || (parsedExpression = new Parser(new Lexer($parseOptions), $filter, $parseOptions).parse(exp), 
                    cache[cacheKey] = addWatchDelegate(parsedExpression)), addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : !("object" == typeof newValue && "object" == typeof (newValue = getValueOf(newValue)) && !compareObjectIdentity) && (newValue === oldValueOfValue || newValue != newValue && oldValueOfValue != oldValueOfValue);
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var lastResult;
                if (1 === (inputExpressions = parsedExpression.inputs).length) {
                    var oldInputValueOf = expressionInputDirtyCheck, inputExpressions = inputExpressions[0];
                    return scope.$watch(function(scope) {
                        var newInputValue = inputExpressions(scope);
                        return expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure) || (lastResult = parsedExpression(scope, void 0, void 0, [ newInputValue ]), 
                        oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; i < ii; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, 
                oldInputValues[i] = null;
                return scope.$watch(function(scope) {
                    for (var changed = !1, i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        (changed = changed || !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure)) && (oldInputValues[i] = newInputValue, 
                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                    }
                    return lastResult = changed ? parsedExpression(scope, void 0, void 0, oldInputValues) : lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var unwatch, lastValue, isDone = parsedExpression.literal ? isAllDefined : isDefined, exp = parsedExpression.$$intercepted || parsedExpression, post = parsedExpression.$$interceptor || identity, useInputs = parsedExpression.inputs && !exp.inputs;
                return oneTimeWatch.literal = parsedExpression.literal, oneTimeWatch.constant = parsedExpression.constant, 
                oneTimeWatch.inputs = parsedExpression.inputs, addWatchDelegate(oneTimeWatch), unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);
                function unwatchIfDone() {
                    isDone(lastValue) && unwatch();
                }
                function oneTimeWatch(scope, locals, assign, inputs) {
                    return lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs), 
                    isDone(lastValue) && scope.$$postDigest(unwatchIfDone), post(lastValue);
                }
            }
            function isAllDefined(value) {
                var allDefined = !0;
                return forEach(value, function(val) {
                    void 0 === val && (allDefined = !1);
                }), allDefined;
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch = scope.$watch(function(scope) {
                    return unwatch(), parsedExpression(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function addWatchDelegate(parsedExpression) {
                return parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : parsedExpression.oneTime ? parsedExpression.$$watchDelegate = oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), 
                parsedExpression;
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                function chainedInterceptor(value) {
                    return second(first(value));
                }
                var first, second;
                parsedExpression.$$interceptor && (first = parsedExpression.$$interceptor, second = interceptorFn, 
                chainedInterceptor.$stateful = first.$stateful || second.$stateful, chainedInterceptor.$$pure = first.$$pure && second.$$pure, 
                interceptorFn = chainedInterceptor, parsedExpression = parsedExpression.$$intercepted);
                function fn(scope, locals, assign, value) {
                    return value = useInputs && value ? value[0] : parsedExpression(scope, locals, assign, value), 
                    interceptorFn(value);
                }
                var useInputs = !1;
                return fn.$$intercepted = parsedExpression, fn.$$interceptor = interceptorFn, fn.literal = parsedExpression.literal, 
                fn.oneTime = parsedExpression.oneTime, fn.constant = parsedExpression.constant, 
                interceptorFn.$stateful || (useInputs = !parsedExpression.inputs, fn.inputs = parsedExpression.inputs || [ parsedExpression ], 
                interceptorFn.$$pure || (fn.inputs = fn.inputs.map(function(e) {
                    return e.isPure === PURITY_RELATIVE ? function(s) {
                        return e(s);
                    } : e;
                }))), addWatchDelegate(fn);
            }
        } ];
    }
    function $QProvider() {
        var errorOnUnhandledRejections = !0;
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ], this.errorOnUnhandledRejections = function(value) {
            return void 0 !== value ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
        };
    }
    function $$QProvider() {
        var errorOnUnhandledRejections = !0;
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ], this.errorOnUnhandledRejections = function(value) {
            return void 0 !== value ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
        };
    }
    function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
        var $qMinErr = minErr("$q", TypeError), queueSize = 0, checkQueue = [];
        function defer() {
            return new Deferred();
        }
        function Deferred() {
            var promise = this.promise = new Promise();
            this.resolve = function(val) {
                resolvePromise(promise, val);
            }, this.reject = function(reason) {
                rejectPromise(promise, reason);
            }, this.notify = function(progress) {
                notifyPromise(promise, progress);
            };
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        function processChecks() {
            for (;!queueSize && checkQueue.length; ) {
                var errorMessage, toCheck = checkQueue.shift();
                toCheck.pur || (toCheck.pur = !0, errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value), 
                isError(toCheck.value) ? exceptionHandler(toCheck.value, errorMessage) : exceptionHandler(errorMessage));
            }
        }
        function scheduleProcessQueue(state) {
            !errorOnUnhandledRejections || state.pending || 2 !== state.status || state.pur || (0 === queueSize && 0 === checkQueue.length && nextTick(processChecks), 
            checkQueue.push(state)), !state.processScheduled && state.pending && (state.processScheduled = !0, 
            ++queueSize, nextTick(function() {
                !function(state) {
                    var fn, promise, pending = state.pending;
                    state.processScheduled = !1, state.pending = void 0;
                    try {
                        for (var i = 0, ii = pending.length; i < ii; ++i) {
                            state.pur = !0, promise = pending[i][0], fn = pending[i][state.status];
                            try {
                                isFunction(fn) ? resolvePromise(promise, fn(state.value)) : (1 === state.status ? resolvePromise : rejectPromise)(promise, state.value);
                            } catch (e) {
                                rejectPromise(promise, e), e && !0 === e.$$passToExceptionHandler && exceptionHandler(e);
                            }
                        }
                    } finally {
                        --queueSize, errorOnUnhandledRejections && 0 === queueSize && nextTick(processChecks);
                    }
                }(state);
            }));
        }
        function resolvePromise(promise, val) {
            promise.$$state.status || (val === promise ? $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : function $$resolve(promise, val) {
                var then;
                var done = !1;
                try {
                    (isObject(val) || isFunction(val)) && (then = val.then), isFunction(then) ? (promise.$$state.status = -1, 
                    then.call(val, doResolve, doReject, doNotify)) : (promise.$$state.value = val, promise.$$state.status = 1, 
                    scheduleProcessQueue(promise.$$state));
                } catch (e) {
                    doReject(e);
                }
                function doResolve(val) {
                    done || (done = !0, $$resolve(promise, val));
                }
                function doReject(val) {
                    done || (done = !0, $$reject(promise, val));
                }
                function doNotify(progress) {
                    notifyPromise(promise, progress);
                }
            }(promise, val));
        }
        function rejectPromise(promise, reason) {
            promise.$$state.status || $$reject(promise, reason);
        }
        function $$reject(promise, reason) {
            promise.$$state.value = reason, promise.$$state.status = 2, scheduleProcessQueue(promise.$$state);
        }
        function notifyPromise(promise, progress) {
            var callbacks = promise.$$state.pending;
            promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                for (var callback, result, i = 0, ii = callbacks.length; i < ii; i++) {
                    result = callbacks[i][0], callback = callbacks[i][3];
                    try {
                        notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                    } catch (e) {
                        exceptionHandler(e);
                    }
                }
            });
        }
        function reject(reason) {
            var result = new Promise();
            return rejectPromise(result, reason), result;
        }
        function handleCallback(value, resolver, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback());
            } catch (e) {
                return reject(e);
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                return resolver(value);
            }, reject) : resolver(value);
        }
        function when(value, callback, errback, progressBack) {
            var result = new Promise();
            return resolvePromise(result, value), result.then(callback, errback, progressBack);
        }
        extend(Promise.prototype, {
            then: function(onFulfilled, onRejected, progressBack) {
                if (void 0 === onFulfilled && void 0 === onRejected && void 0 === progressBack) return this;
                var result = new Promise();
                return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]), 
                0 < this.$$state.status && scheduleProcessQueue(this.$$state), result;
            },
            catch: function(callback) {
                return this.then(null, callback);
            },
            finally: function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, resolve, callback);
                }, function(error) {
                    return handleCallback(error, reject, callback);
                }, progressBack);
            }
        });
        var resolve = when;
        function $Q(resolver) {
            if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            var promise = new Promise();
            return resolver(function(value) {
                resolvePromise(promise, value);
            }, function(reason) {
                rejectPromise(promise, reason);
            }), promise;
        }
        return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when, 
        $Q.resolve = resolve, $Q.all = function(promises) {
            var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, when(promise).then(function(value) {
                    results[key] = value, --counter || resolvePromise(result, results);
                }, function(reason) {
                    rejectPromise(result, reason);
                });
            }), 0 === counter && resolvePromise(result, results), result;
        }, $Q.race = function(promises) {
            var deferred = defer();
            return forEach(promises, function(promise) {
                when(promise).then(deferred.resolve, deferred.reject);
            }), deferred.promise;
        }, $Q;
    }
    function markQExceptionHandled(q) {
        q.$$state && (q.$$state.pur = !0);
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function(raf, $timeout) {
            var requestAnimationFrame = raf.requestAnimationFrame || raf.webkitRequestAnimationFrame, cancelAnimationFrame = raf.cancelAnimationFrame || raf.webkitCancelAnimationFrame || raf.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            return raf.supported = rafSupported, raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
        this.digestTtl = function(value) {
            return TTL = arguments.length ? value : TTL;
        }, this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = !0;
            }
            function Scope() {
                this.$id = ++uid, this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                (this.$root = this).$$destroyed = !1, this.$$suspended = !1, this.$$listeners = {}, 
                this.$$listenerCount = {}, this.$$watchersCount = 0, this.$$isolateBindings = null;
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    return parent = parent || this, isolate ? (child = new Scope()).$root = this.$root : (this.$$ChildScope || (this.$$ChildScope = function(parent) {
                        function ChildScope() {
                            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                            this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = ++uid, 
                            this.$$ChildScope = null, this.$$suspended = !1;
                        }
                        return ChildScope.prototype = parent, ChildScope;
                    }(this)), child = new this.$$ChildScope()), child.$parent = parent, child.$$prevSibling = parent.$$childTail, 
                    parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, 
                    !isolate && parent === this || child.$on("$destroy", destroyChildScope), child;
                },
                $watch: function(watchExp, fn, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp), fn = isFunction(fn) ? fn : noop;
                    if (get.$$watchDelegate) return get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: fn,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    return lastDirtyWatch = null, array || ((array = scope.$$watchers = []).$$digestWatchIndex = -1), 
                    array.unshift(watcher), array.$$digestWatchIndex++, incrementWatchersCount(this, 1), 
                    function() {
                        var index = arrayRemove(array, watcher);
                        0 <= index && (incrementWatchersCount(scope, -1), index < array.$$digestWatchIndex && array.$$digestWatchIndex--), 
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                    if (watchExpressions.length) return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                        newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    }) : (forEach(watchExpressions, function(unwatchFn, i) {
                        unwatchFn = self.$watch(unwatchFn, function(value) {
                            newValues[i] = value, changeReactionScheduled || (changeReactionScheduled = !0, 
                            self.$evalAsync(watchGroupAction));
                        });
                        deregisterFns.push(unwatchFn);
                    }), function() {
                        for (;deregisterFns.length; ) deregisterFns.shift()();
                    });
                    var shouldCall = !0;
                    return self.$evalAsync(function() {
                        shouldCall && listener(newValues, newValues, self);
                    }), function() {
                        shouldCall = !1;
                    };
                    function watchGroupAction() {
                        changeReactionScheduled = !1;
                        try {
                            firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                        } finally {
                            for (var i = 0; i < watchExpressions.length; i++) oldValues[i] = newValues[i];
                        }
                    }
                },
                $watchCollection: function(changeDetector, listener) {
                    $watchCollectionInterceptor.$$pure = $parse(changeDetector).literal, $watchCollectionInterceptor.$stateful = !$watchCollectionInterceptor.$$pure;
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = 1 < listener.length, changeDetected = 0, changeDetector = $parse(changeDetector, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    function $watchCollectionInterceptor(_value) {
                        var newLength, key, newItem, oldItem;
                        if (void 0 !== (newValue = _value)) {
                            if (isObject(newValue)) if (isArrayLike(newValue)) {
                                oldValue !== internalArray && (oldLength = (oldValue = internalArray).length = 0, 
                                changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                                oldValue.length = oldLength = newLength);
                                for (var i = 0; i < newLength; i++) oldItem = oldValue[i], newItem = newValue[i], 
                                oldItem != oldItem && newItem != newItem || oldItem === newItem || (changeDetected++, 
                                oldValue[i] = newItem);
                            } else {
                                for (key in oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, 
                                changeDetected++), newLength = 0, newValue) hasOwnProperty.call(newValue, key) && (newLength++, 
                                newItem = newValue[key], oldItem = oldValue[key], key in oldValue ? oldItem != oldItem && newItem != newItem || oldItem === newItem || (changeDetected++, 
                                oldValue[key] = newItem) : (oldLength++, oldValue[key] = newItem, changeDetected++));
                                if (newLength < oldLength) for (key in changeDetected++, oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, 
                                delete oldValue[key]);
                            } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                            return changeDetected;
                        }
                    }
                    return this.$watch(changeDetector, function() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else for (var key in veryOldValue = {}, newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]); else veryOldValue = newValue;
                    });
                },
                $digest: function() {
                    var watch, value, last, watchers, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = asyncQueue.length ? $rootScope : this, watchLog = [];
                    beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), 
                    flushApplyAsync()), lastDirtyWatch = null;
                    do {
                        dirty = !1, current = target;
                        for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                            try {
                                (0, (asyncTask = asyncQueue[asyncQueuePosition]).fn)(asyncTask.scope, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        asyncQueue.length = 0;
                        traverseScopesLoop: do {
                            if (watchers = !current.$$suspended && current.$$watchers) for (watchers.$$digestWatchIndex = watchers.length; watchers.$$digestWatchIndex--; ) try {
                                if (watch = watchers[watchers.$$digestWatchIndex]) if ((value = (0, watch.get)(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, (lastDirtyWatch = watch).last = watch.eq ? copy(value, null) : value, 
                                (0, watch.fn)(value, last === initWatchVal ? value : last, current), ttl < 5 && (watchLog[logIdx = 4 - ttl] || (watchLog[logIdx] = []), 
                                watchLog[logIdx].push({
                                    msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                    newVal: value,
                                    oldVal: last
                                }));
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            if (!(next = !current.$$suspended && current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueuePosition < postDigestQueue.length; ) try {
                        postDigestQueue[postDigestQueuePosition++]();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                    postDigestQueue.length = postDigestQueuePosition = 0, $browser.$$checkUrlChange();
                },
                $suspend: function() {
                    this.$$suspended = !0;
                },
                $isSuspended: function() {
                    return this.$$suspended;
                },
                $resume: function() {
                    this.$$suspended = !1;
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var eventName, parent = this.$parent;
                        for (eventName in this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), 
                        incrementWatchersCount(this, -this.$$watchersCount), this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                        parent && parent.$$childHead === this && (parent.$$childHead = this.$$nextSibling), 
                        parent && parent.$$childTail === this && (parent.$$childTail = this.$$prevSibling), 
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, 
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return noop;
                        }, this.$$listeners = {}, this.$$nextSibling = null, function cleanUpScope($scope) {
                            9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)), 
                            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
                        }(this);
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                        asyncQueue.length && $rootScope.$digest();
                    }, null, "$evalAsync"), asyncQueue.push({
                        scope: this,
                        fn: $parse(expr),
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        try {
                            return this.$eval(expr);
                        } finally {
                            clearPhase();
                        }
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    var scope = this;
                    expr && applyAsyncQueue.push(function() {
                        scope.$eval(expr);
                    }), expr = $parse(expr), null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                        $rootScope.$apply(flushApplyAsync);
                    }, null, "$applyAsync"));
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    for (var current = this; current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), 
                    current.$$listenerCount[name]++, current = current.$parent; ) ;
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        -1 !== indexOfListener && (delete namedListeners[indexOfListener], decrementListenerCount(self, 1, name));
                    };
                },
                $emit: function(name, args) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; i < length; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                    } while (!stopPropagation && (scope = scope.$parent));
                    return event.currentScope = null, event;
                },
                $broadcast: function(name, args) {
                    var current = this, next = this, event = {
                        name: name,
                        targetScope: this,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!this.$$listenerCount[name]) return event;
                    for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (i = 0, length = (listeners = (event.currentScope = current).$$listeners[name] || []).length; i < length; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== this && current.$$nextSibling)) for (;current !== this && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event.currentScope = null, event;
                }
            };
            var $rootScope = new Scope(), asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [], postDigestQueuePosition = 0;
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                for (;current.$$watchersCount += count, current = current.$parent; ) ;
            }
            function decrementListenerCount(current, count, name) {
                for (;current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name], 
                current = current.$parent; ) ;
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                for (;applyAsyncQueue.length; ) try {
                    applyAsyncQueue.shift()();
                } catch (e) {
                    $exceptionHandler(e);
                }
                applyAsyncId = null;
            }
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationTrustedUrlList = /^\s*(https?|s?ftp|mailto|tel|file):/, imgSrcSanitizationTrustedUrlList = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationTrustedUrlList = function(regexp) {
            return void 0 !== regexp ? (aHrefSanitizationTrustedUrlList = regexp, this) : aHrefSanitizationTrustedUrlList;
        }, this.imgSrcSanitizationTrustedUrlList = function(regexp) {
            return void 0 !== regexp ? (imgSrcSanitizationTrustedUrlList = regexp, this) : imgSrcSanitizationTrustedUrlList;
        }, this.$get = function() {
            return function(uri, normalizedVal) {
                var regex = normalizedVal ? imgSrcSanitizationTrustedUrlList : aHrefSanitizationTrustedUrlList, normalizedVal = urlResolve(uri && uri.trim()).href;
                return "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    ASTCompiler.prototype = {
        compile: function(ast) {
            var self = this;
            this.state = {
                nextId: 0,
                filters: {},
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            }, findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, fn = "";
            this.stage = "assign", (assignable = assignableAST(ast)) && (this.state.computing = "assign", 
            toWatch = this.nextId(), this.recurse(assignable, toWatch), this.return_(toWatch), 
            fn = "fn.assign=" + this.generateFunction("assign", "s,v,l"));
            var toWatch = getInputs(ast.body);
            self.stage = "inputs", forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                }, self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push({
                    name: fnKey,
                    isPure: watch.isPure
                }), watch.watchId = key;
            }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
            fn = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + fn + this.watchFns() + "return fn;", 
            fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fn)(this.$filter, getStringValue, ifDefined, plusFn);
            return this.state = this.stage = void 0, fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [], inputs = this.state.inputs, self = this;
            return forEach(inputs, function(input) {
                result.push("var " + input.name + "=" + self.generateFunction(input.name, "s")), 
                input.isPure && result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";");
            }), inputs.length && result.push("fn.inputs=[" + inputs.map(function(i) {
                return i.name;
            }).join(",") + "];"), result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [], self = this;
            return forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            }), parts.length ? "var " + parts.join(",") + ";" : "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, args, expression, computed, self = this;
            if (recursionFn = recursionFn || noop, !skipWatchIdCheck && void 0 !== ast.watchId) return intoId = intoId || this.nextId(), 
            void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, void 0, void 0, function(expr) {
                        right = expr;
                    }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right);
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(intoId || expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, void 0, void 0, function(expr) {
                    right = expr;
                }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), 
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, void 0, void 0, function(expr) {
                    left = expr;
                }), this.recurse(ast.right, void 0, void 0, function(expr) {
                    right = expr;
                }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", 
                this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), 
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), 
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), 
                nameId.computed = !1, nameId.name = ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if_("inputs" === self.stage || "s", function() {
                        create && 1 !== create && self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), 
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), 
                self.recurse(ast.object, left, void 0, function() {
                    self.if_(self.notNull(left), function() {
                        ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), 
                        create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), 
                        expression = self.computedMember(left, right), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !0, nameId.name = right)) : (create && 1 !== create && self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), 
                        expression = self.nonComputedMember(left, ast.property.name), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !1, nameId.name = ast.property.name));
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), 
                args = [], forEach(ast.arguments, function(expr) {
                    var argument = self.nextId();
                    self.recurse(expr, argument), args.push(argument);
                }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), 
                recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function() {
                    self.if_(self.notNull(right), function() {
                        forEach(ast.arguments, function(expr) {
                            self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                                args.push(argument);
                            });
                        }), expression = left.name ? self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")" : right + "(" + args.join(",") + ")", 
                        self.assign(intoId, expression);
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }));
                break;

              case AST.AssignmentExpression:
                right = this.nextId(), left = {}, this.recurse(ast.left, void 0, left, function() {
                    self.if_(self.notNull(left.context), function() {
                        self.recurse(ast.right, right), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, 
                        self.assign(intoId, expression), recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [], forEach(ast.elements, function(expr) {
                    self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                        args.push(argument);
                    });
                }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(intoId || expression);
                break;

              case AST.ObjectExpression:
                computed = !(args = []), forEach(ast.properties, function(property) {
                    property.computed && (computed = !0);
                }), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, function(property) {
                    property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, 
                    right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right);
                })) : (forEach(ast.properties, function(property) {
                    self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, function(expr) {
                        args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                    });
                }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), recursionFn(intoId || expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s"), recursionFn(intoId || "s");
                break;

              case AST.LocalsExpression:
                this.assign(intoId, "l"), recursionFn(intoId || "l");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v"), recursionFn(intoId || "v");
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property, own = this.current().own;
            return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), 
            own[key];
        },
        assign: function(id, value) {
            if (id) return this.current().body.push(id, "=", value, ";"), id;
        },
        filter: function(filterName) {
            return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), 
            this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        return_: function(id) {
            this.current().body.push("return ", id, ";");
        },
        if_: function(test, alternate, consequent) {
            var body;
            !0 === test ? alternate() : ((body = this.current().body).push("if(", test, "){"), 
            alternate(), body.push("}"), consequent && (body.push("else{"), consequent(), body.push("}")));
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        isNull: function(expression) {
            return expression + "==null";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(right) ? left + "." + right : left + '["' + right.replace(/[^$_a-zA-Z0-9]/g, this.stringEscapeFn) + '"]';
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right);
        },
        getStringValue: function(item) {
            this.assign(item, "getStringValue(" + item + ")");
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (!0 === value) return "true";
            if (!1 === value) return "false";
            if (null === value) return "null";
            if (void 0 === value) return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            return skip || this.current().vars.push(id + (init ? "=" + init : "")), id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    }, ASTInterpreter.prototype = {
        compile: function(fn) {
            var assign, self = this;
            findConstantAndWatchExpressions(fn, self.$filter), (toWatch = assignableAST(fn)) && (assign = this.recurse(toWatch));
            var inputs, toWatch = getInputs(fn.body);
            toWatch && (inputs = [], forEach(toWatch, function(watch, key) {
                var input = self.recurse(watch);
                input.isPure = watch.isPure, watch.input = input, inputs.push(input), watch.watchId = key;
            }));
            var expressions = [];
            forEach(fn.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            fn = 0 === fn.body.length ? noop : 1 === fn.body.length ? expressions[0] : function(scope, locals) {
                var lastValue;
                return forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                }), lastValue;
            };
            return assign && (fn.assign = function(scope, value, locals) {
                return assign(scope, locals, value);
            }), inputs && (fn.inputs = inputs), fn;
        },
        recurse: function(ast, context, create) {
            var left, right, args, self = this;
            if (ast.input) return this.inputs(ast.input, ast.watchId);
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
              case AST.LogicalExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                return self.identifier(ast.name, context, create);

              case AST.MemberExpression:
                return left = this.recurse(ast.object, !1, !!create), ast.computed || (right = ast.property.name), 
                ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);

              case AST.CallExpression:
                return args = [], forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), 
                ast.filter ? function(scope, locals, assign, inputs) {
                    for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                    var value = right.apply(void 0, values, inputs);
                    return context ? {
                        context: void 0,
                        name: void 0,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var value, rhs = right(scope, locals, assign, inputs);
                    if (null != rhs.value) {
                        for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                        value = rhs.value.apply(rhs.context, values);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function(scope, locals, assign, rhs) {
                    var lhs = left(scope, locals, assign, rhs), rhs = right(scope, locals, assign, rhs);
                    return lhs.context[lhs.name] = rhs, context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                return args = [], forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                }), function(scope, locals, assign, inputs) {
                    for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                return args = [], forEach(ast.properties, function(property) {
                    property.computed ? args.push({
                        key: self.recurse(property.key),
                        computed: !0,
                        value: self.recurse(property.value)
                    }) : args.push({
                        key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                        computed: !1,
                        value: self.recurse(property.value)
                    });
                }), function(scope, locals, assign, inputs) {
                    for (var value = {}, i = 0; i < args.length; ++i) args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.LocalsExpression:
                return function(scope, locals) {
                    return context ? {
                        value: locals
                    } : locals;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, arg) {
                arg = void 0 !== (arg = argument(scope, locals, assign, arg)) ? +arg : 0;
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, arg) {
                arg = void 0 !== (arg = argument(scope, locals, assign, arg)) ? -arg : -0;
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, arg) {
                arg = !argument(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = plusFn(left(scope, locals, assign, arg), right(scope, locals, assign, arg));
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                var lhs = left(scope, locals, assign, arg), arg = right(scope, locals, assign, arg), arg = (void 0 !== lhs ? lhs : 0) - (void 0 !== arg ? arg : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) * right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) / right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) % right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) === right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) !== right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) == right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) != right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) < right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) > right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) <= right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) >= right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) && right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, arg) {
                arg = left(scope, locals, assign, arg) || right(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, arg) {
                arg = (test(scope, locals, assign, arg) ? alternate : consequent)(scope, locals, assign, arg);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: void 0,
                    name: void 0,
                    value: value
                } : value;
            };
        },
        identifier: function(name, context, create) {
            return function(value, base, assign, inputs) {
                base = base && name in base ? base : value;
                create && 1 !== create && base && null == base[name] && (base[name] = {});
                value = base ? base[name] : void 0;
                return context ? {
                    context: base,
                    name: name,
                    value: value
                } : value;
            };
        },
        computedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var rhs, value, lhs = left(scope, locals, assign, inputs);
                return null != lhs && (rhs = right(scope, locals, assign, inputs), rhs += "", create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), 
                value = lhs[rhs]), context ? {
                    context: lhs,
                    name: rhs,
                    value: value
                } : value;
            };
        },
        nonComputedMember: function(left, right, context, create) {
            return function(scope, locals, lhs, value) {
                lhs = left(scope, locals, lhs, value);
                create && 1 !== create && lhs && null == lhs[right] && (lhs[right] = {});
                value = null != lhs ? lhs[right] : void 0;
                return context ? {
                    context: lhs,
                    name: right,
                    value: value
                } : value;
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                return inputs ? inputs[watchId] : input(scope, value, locals);
            };
        }
    }, Parser.prototype = {
        constructor: Parser,
        parse: function(fn) {
            var ast = this.getAst(fn), fn = this.astCompiler.compile(ast.ast);
            return fn.literal = function(ast) {
                return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
            }(ast.ast), fn.constant = ast.ast.constant, fn.oneTime = ast.oneTime, fn;
        },
        getAst: function(exp) {
            var oneTime = !1;
            return ":" === (exp = exp.trim()).charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, 
            exp = exp.substring(2)), {
                ast: this.ast.ast(exp),
                oneTime: oneTime
            };
        }
    };
    var $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        MEDIA_URL: "mediaUrl",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
    function snakeToCamel(name) {
        return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return void 0 !== matchers && forEach(matchers, function(matcher) {
            adjustedMatchers.push(function(matcher) {
                if ("self" === matcher) return matcher;
                if (isString(matcher)) {
                    if (-1 < matcher.indexOf("***")) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                    return matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"), 
                    new RegExp("^" + matcher + "$");
                }
                if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
                throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
            }(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var trustedResourceUrlList = [ "self" ], bannedResourceUrlList = [];
        this.trustedResourceUrlList = function(value) {
            return trustedResourceUrlList = arguments.length ? adjustMatchers(value) : trustedResourceUrlList;
        }, Object.defineProperty(this, "resourceUrlWhitelist", {
            get: function() {
                return this.trustedResourceUrlList;
            },
            set: function(value) {
                this.trustedResourceUrlList = value;
            }
        }), this.bannedResourceUrlList = function(value) {
            return bannedResourceUrlList = arguments.length ? adjustMatchers(value) : bannedResourceUrlList;
        }, Object.defineProperty(this, "resourceUrlBlacklist", {
            get: function() {
                return this.bannedResourceUrlList;
            },
            set: function(value) {
                this.bannedResourceUrlList = value;
            }
        }), this.$get = [ "$injector", "$$sanitizeUri", function($injector, $$sanitizeUri) {
            var htmlSanitizer = function(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlsAreSameOrigin(parsedUrl, originUrl) || function(requestUrl) {
                    return urlsAreSameOrigin(requestUrl, function() {
                        if (window.document.baseURI) return window.document.baseURI;
                        baseUrlParsingNode || ((baseUrlParsingNode = window.document.createElement("a")).href = ".", 
                        baseUrlParsingNode = baseUrlParsingNode.cloneNode(!1));
                        return baseUrlParsingNode.href;
                    }());
                }(parsedUrl) : matcher.exec(parsedUrl.href);
            }
            function generateHolderType(Base) {
                function holderType(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                }
                return (holderType.prototype = Base ? new Base() : holderType.prototype).valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(byType[SCE_CONTEXTS.MEDIA_URL]), 
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: function(type, trustedValue) {
                    var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                    if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                    if (null == trustedValue || "" === trustedValue) return trustedValue;
                    if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                    return new Constructor(trustedValue);
                },
                getTrusted: function(type, maybeTrusted) {
                    if (null == maybeTrusted || "" === maybeTrusted) return maybeTrusted;
                    var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                    if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                    if (isFunction(maybeTrusted.$$unwrapTrustedValue) && (maybeTrusted = maybeTrusted.$$unwrapTrustedValue()), 
                    type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) return $$sanitizeUri(maybeTrusted.toString(), type === SCE_CONTEXTS.MEDIA_URL);
                    if (type === SCE_CONTEXTS.RESOURCE_URL) {
                        if (function(url) {
                            for (var parsedUrl = urlResolve(url.toString()), allowed = !1, i = 0, n = trustedResourceUrlList.length; i < n; i++) if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {
                                allowed = !0;
                                break;
                            }
                            if (allowed) for (i = 0, n = bannedResourceUrlList.length; i < n; i++) if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {
                                allowed = !1;
                                break;
                            }
                            return allowed;
                        }(maybeTrusted)) return maybeTrusted;
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                    }
                    if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                    throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                },
                valueOf: function(maybeTrusted) {
                    return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
                }
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return enabled = arguments.length ? !!value : enabled;
        }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                    return sce.getTrusted(type, value);
                });
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, lName) {
                lName = lowercase(lName);
                sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function(transitions, animations) {
            var eventSupport = {}, hasHistoryPushState = !(!(transitions.nw && transitions.nw.process) && transitions.chrome && (transitions.chrome.app && transitions.chrome.app.runtime || !transitions.chrome.app && transitions.chrome.runtime && transitions.chrome.runtime.id)) && transitions.history && transitions.history.pushState, android = toInt((/android (\d+)/.exec(lowercase((transitions.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test((transitions.navigator || {}).userAgent), document = animations[0] || {}, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            return bodyStyle && (transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle), 
            animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle)), {
                history: !(!hasHistoryPushState || android < 4 || boxee),
                hasEvent: function(event) {
                    return ("input" !== event || !msie) && (void 0 === eventSupport[event] && (divElm = document.createElement("div"), 
                    eventSupport[event] = "on" + event in divElm), eventSupport[event]);
                    var divElm;
                },
                csp: csp(),
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    function $$TaskTrackerFactoryProvider() {
        this.$get = valueFn(function(log) {
            return new TaskTracker(log);
        });
    }
    function TaskTracker(log) {
        var taskCounts = {}, taskCallbacks = [], ALL_TASKS_TYPE = this.ALL_TASKS_TYPE = "$$all$$", DEFAULT_TASK_TYPE = this.DEFAULT_TASK_TYPE = "$$default$$";
        function getLastCallback() {
            var cbInfo = taskCallbacks.pop();
            return cbInfo && cbInfo.cb;
        }
        function getLastCallbackForType(taskType) {
            for (var i = taskCallbacks.length - 1; 0 <= i; --i) {
                var cbInfo = taskCallbacks[i];
                if (cbInfo.type === taskType) return taskCallbacks.splice(i, 1), cbInfo.cb;
            }
        }
        this.completeTask = function(fn, taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            try {
                fn();
            } finally {
                !function(taskType) {
                    taskCounts[taskType = taskType || DEFAULT_TASK_TYPE] && (taskCounts[taskType]--, 
                    taskCounts[ALL_TASKS_TYPE]--);
                }(taskType);
                var countForType = taskCounts[taskType], countForAll = taskCounts[ALL_TASKS_TYPE];
                if (!countForAll || !countForType) for (var nextCb, getNextCallback = countForAll ? getLastCallbackForType : getLastCallback; nextCb = getNextCallback(taskType); ) try {
                    nextCb();
                } catch (e) {
                    log.error(e);
                }
            }
        }, this.incTaskCount = function(taskType) {
            taskCounts[taskType = taskType || DEFAULT_TASK_TYPE] = (taskCounts[taskType] || 0) + 1, 
            taskCounts[ALL_TASKS_TYPE] = (taskCounts[ALL_TASKS_TYPE] || 0) + 1;
        }, this.notifyWhenNoPendingTasks = function(callback, taskType) {
            taskCounts[taskType = taskType || ALL_TASKS_TYPE] ? taskCallbacks.push({
                type: taskType,
                cb: callback
            }) : callback();
        };
    }
    var $templateRequestMinErr = minErr("$templateRequest");
    function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
            return val ? (httpOptions = val, this) : httpOptions;
        }, this.$get = [ "$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                handleRequestFn.totalPendingRequests++, isString(tpl) && void 0 !== $templateCache.get(tpl) || (tpl = $sce.getTrustedResourceUrl(tpl));
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                return isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                    return transformer !== defaultHttpResponseTransform;
                }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null), 
                $http.get(tpl, extend({
                    cache: $templateCache,
                    transformResponse: transformResponse
                }, httpOptions)).finally(function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return $templateCache.put(tpl, response.data);
                }, function(resp) {
                    ignoreRequestError || (resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText), 
                    $exceptionHandler(resp));
                    return $q.reject(resp);
                });
            }
            return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {
                findBindings: function(bindings, expression, opt_exactMatch) {
                    var bindings = bindings.getElementsByClassName("ng-binding"), matches = [];
                    return forEach(bindings, function(binding) {
                        var dataBinding = angular.element(binding).data("$binding");
                        dataBinding && forEach(dataBinding, function(bindingName) {
                            opt_exactMatch ? new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)").test(bindingName) && matches.push(binding) : -1 !== bindingName.indexOf(expression) && matches.push(binding);
                        });
                    }), matches;
                },
                findModels: function(element, expression, opt_exactMatch) {
                    for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                        var elements = "[" + prefixes[p] + "model" + (opt_exactMatch ? "=" : "*=") + '"' + expression + '"]', elements = element.querySelectorAll(elements);
                        if (elements.length) return elements;
                    }
                },
                getLocation: function() {
                    return $location.url();
                },
                setLocation: function(url) {
                    url !== $location.url() && ($location.url(url), $rootScope.$digest());
                },
                whenStable: function(callback) {
                    $browser.notifyWhenNoOutstandingRequests(callback);
                }
            };
            return testability;
        } ];
    }
    var $timeoutMinErr = minErr("$timeout");
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, timeoutId, invokeApply) {
                isFunction(fn) || (invokeApply = timeoutId, timeoutId = fn, fn = noop);
                var args = sliceArgs(arguments, 3), skipApply = void 0 !== invokeApply && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, timeoutId, "$timeout");
                return promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            return timeout.cancel = function(deferred) {
                if (!deferred) return !1;
                if (!deferred.hasOwnProperty("$$timeoutId")) throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
                if (!deferreds.hasOwnProperty(deferred.$$timeoutId)) return !1;
                var id = deferred.$$timeoutId, deferred = deferreds[id];
                return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), delete deferreds[id], 
                $browser.defer.cancel(id);
            }, timeout;
        } ];
    }
    var baseUrlParsingNode, urlParsingNode = window.document.createElement("a"), originUrl = urlResolve(window.location.href);
    urlParsingNode.href = "http://[::1]";
    var ipv6InBrackets = "[::1]" === urlParsingNode.hostname;
    function urlResolve(hostname) {
        if (!isString(hostname)) return hostname;
        msie && (urlParsingNode.setAttribute("href", hostname), hostname = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", hostname);
        hostname = urlParsingNode.hostname;
        return !ipv6InBrackets && -1 < hostname.indexOf(":") && (hostname = "[" + hostname + "]"), 
        {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlsAreSameOrigin(url1, url2) {
        return url1 = urlResolve(url1), url2 = urlResolve(url2), url1.protocol === url2.protocol && url1.host === url2.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
        var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        return function() {
            var cookieArray, cookie, i, index, name, currentCookieString = function(rawDocument) {
                try {
                    return rawDocument.cookie || "";
                } catch (e) {
                    return "";
                }
            }(rawDocument);
            if (currentCookieString !== lastCookieString) for (cookieArray = (lastCookieString = currentCookieString).split("; "), 
            lastCookies = {}, i = 0; i < cookieArray.length; i++) 0 < (index = (cookie = cookieArray[i]).indexOf("=")) && (name = safeDecodeURIComponent(cookie.substring(0, index)), 
            void 0 === lastCookies[name] && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
            return lastCookies;
        };
    }
    function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
    }
    function $FilterProvider($provide) {
        var suffix = "Filter";
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator, anyPropertyKey) {
            if (!isArrayLike(array)) {
                if (null == array) return array;
                throw minErr("filter")("notarray", "Expected array but received: {0}", array);
            }
            var predicateFn, matchAgainstAnyProp;
            switch (anyPropertyKey = anyPropertyKey || "$", getTypeForFilter(expression)) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = !0;

              case "object":
                predicateFn = function(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
                    var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
                    !0 === comparator ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
                        return void 0 !== actual && (null === actual || null === expected ? actual === expected : !(isObject(expected) || isObject(actual) && !hasCustomToString(actual)) && (actual = lowercase("" + actual), 
                        expected = lowercase("" + expected), -1 !== actual.indexOf(expected)));
                    });
                    return function(item) {
                        return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                    };
                }(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
        };
    }
    function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        var key, actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
        if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
        if (isArray(actual)) return actual.some(function(item) {
            return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
        });
        switch (actualType) {
          case "object":
            if (matchAgainstAnyProp) {
                for (key in actual) if (key.charAt && "$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0)) return !0;
                return !dontMatchWholeObject && deepCompare(actual, expected, comparator, anyPropertyKey, !1);
            }
            if ("object" !== expectedType) return comparator(actual, expected);
            for (key in expected) {
                var expectedVal = expected[key];
                if (!isFunction(expectedVal) && void 0 !== expectedVal) {
                    var matchAnyProperty = key === anyPropertyKey;
                    if (!deepCompare(matchAnyProperty ? actual : actual[key], expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) return !1;
                }
            }
            return !0;

          case "function":
            return !1;

          default:
            return comparator(actual, expected);
        }
    }
    function getTypeForFilter(val) {
        return null === val ? "null" : typeof val;
    }
    $$CookieReader.$inject = [ "$document" ], $FilterProvider.$inject = [ "$provide" ];
    var MAX_DIGITS = 22, DECIMAL_SEP = ".", ZERO_CHAR = "0";
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            void 0 === currencySymbol && (currencySymbol = formats.CURRENCY_SYM), void 0 === fractionSize && (fractionSize = formats.PATTERNS[1].maxFrac);
            var currencySymbolRe = currencySymbol ? /\u00A4/g : /\s*\u00A4\s*/g;
            return null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function formatNumber(number, pattern, groupSep, decimalSep, exponent) {
        if (!isString(number) && !isNumber(number) || isNaN(number)) return "";
        var isInfinity = !isFinite(number), isZero = !1, decimals = Math.abs(number) + "", formattedText = "";
        if (isInfinity) formattedText = ""; else {
            (function(parsedNumber, fractionSize, minFrac, carry) {
                var digits = parsedNumber.d, fractionLen = digits.length - parsedNumber.i, roundAt = (fractionSize = void 0 === fractionSize ? Math.min(Math.max(minFrac, fractionLen), carry) : +fractionSize) + parsedNumber.i, carry = digits[roundAt];
                if (0 < roundAt) {
                    digits.splice(Math.max(parsedNumber.i, roundAt));
                    for (var j = roundAt; j < digits.length; j++) digits[j] = 0;
                } else {
                    fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), 
                    digits[0] = 0;
                    for (var i = 1; i < roundAt; i++) digits[i] = 0;
                }
                if (5 <= carry) if (roundAt - 1 < 0) {
                    for (var k = 0; roundAt < k; k--) digits.unshift(0), parsedNumber.i++;
                    digits.unshift(1), parsedNumber.i++;
                } else digits[roundAt - 1]++;
                for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
                (carry = digits.reduceRight(function(carry, d, i, digits) {
                    return d += carry, digits[i] = d % 10, Math.floor(d / 10);
                }, 0)) && (digits.unshift(carry), parsedNumber.i++);
            })(decimals = function(numStr) {
                var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
                for (0 < (i = (numStr = -1 < (numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) ? numStr.replace(DECIMAL_SEP, "") : numStr).search(/e/i)) ? (numberOfIntegerDigits < 0 && (numberOfIntegerDigits = i), 
                numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : numberOfIntegerDigits < 0 && (numberOfIntegerDigits = numStr.length), 
                i = 0; numStr.charAt(i) === ZERO_CHAR; i++) ;
                if (i === (zeros = numStr.length)) digits = [ 0 ], numberOfIntegerDigits = 1; else {
                    for (zeros--; numStr.charAt(zeros) === ZERO_CHAR; ) zeros--;
                    for (numberOfIntegerDigits -= i, digits = [], j = 0; i <= zeros; i++, j++) digits[j] = +numStr.charAt(i);
                }
                return MAX_DIGITS < numberOfIntegerDigits && (digits = digits.splice(0, MAX_DIGITS - 1), 
                exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
                    d: digits,
                    e: exponent,
                    i: numberOfIntegerDigits
                };
            }(decimals), exponent, pattern.minFrac, pattern.maxFrac);
            for (var digits = decimals.d, integerLen = decimals.i, exponent = decimals.e, decimals = [], isZero = digits.reduce(function(isZero, d) {
                return isZero && !d;
            }, !0); integerLen < 0; ) digits.unshift(0), integerLen++;
            0 < integerLen ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, 
            digits = [ 0 ]);
            var groups = [];
            for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize; ) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
            digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep), 
            decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent);
        }
        return number < 0 && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf;
    }
    function padNumber(num, digits, trim, negWrap) {
        var neg = "";
        for ((num < 0 || negWrap && num <= 0) && (negWrap ? num = 1 - num : (num = -num, 
        neg = "-")), num = "" + num; num.length < digits; ) num = ZERO_CHAR + num;
        return neg + (num = trim ? num.substr(num.length - digits) : num);
    }
    function dateGetter(name, size, offset, trim, negWrap) {
        return offset = offset || 0, function(value) {
            value = value["get" + name]();
            return (0 < offset || -offset < value) && (value += offset), padNumber(value = 0 === value && -12 === offset ? 12 : value, size, trim, negWrap);
        };
    }
    function dateStrGetter(name, shortForm, standAlone) {
        return function(value, formats) {
            value = value["get" + name]();
            return formats[uppercase((standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "") + name)][value];
        };
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
    }
    function weekGetter(size) {
        return function(datetime) {
            var diff = getFirstThursdayOfYear(datetime.getFullYear()), diff = +(datetime = datetime, 
            new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()))) - +diff;
            return padNumber(1 + Math.round(diff / 6048e5), size);
        };
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    currencyFilter.$inject = [ "$locale" ];
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4, 0, !(numberFilter.$inject = [ "$locale" ]), !0),
        yy: dateGetter("FullYear", 2, 0, !0, !0),
        y: dateGetter("FullYear", 1, 0, !1, !0),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        LLLL: dateStrGetter("Month", !1, !0),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: function(date, formats) {
            return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
        },
        Z: function(date, formats, paddedZone) {
            var zone = -1 * paddedZone, paddedZone = 0 <= zone ? "+" : "";
            return paddedZone += padNumber(Math[0 < zone ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        },
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: function(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
        }
    }, DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/;
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            !isDate(date = isNumber(date = isString(date) ? (NUMBER_STRING.test(date) ? toInt : function(string) {
                if (ms = string.match(R_ISO8601_STR)) {
                    var date = new Date(0), m = 0, s = 0, h = ms[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = ms[8] ? date.setUTCHours : date.setHours;
                    ms[9] && (m = toInt(ms[9] + ms[10]), s = toInt(ms[9] + ms[11])), h.call(date, toInt(ms[1]), toInt(ms[2]) - 1, toInt(ms[3]));
                    var h = toInt(ms[4] || 0) - m, m = toInt(ms[5] || 0) - s, s = toInt(ms[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (ms[7] || 0)));
                    return timeSetter.call(date, h, m, s, ms), date;
                }
                return string;
            })(date) : date) ? new Date(date) : date) || !isFinite(date.getTime())) return date;
            for (;format; ) format = (match = DATE_FORMATS_SPLIT.exec(format)) ? (parts = concat(parts, match, 1)).pop() : (parts.push(format), 
            null);
            var dateTimezoneOffset = date.getTimezoneOffset();
            return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), 
            date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            return toJson(object, spacing = void 0 === spacing ? 2 : spacing);
        };
    }
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
        return function(input, limit, begin) {
            return limit = (Math.abs(Number(limit)) === 1 / 0 ? Number : toInt)(limit), !isNumberNaN(limit) && isArrayLike(input = isNumber(input) ? input.toString() : input) ? (begin = (begin = !begin || isNaN(begin) ? 0 : toInt(begin)) < 0 ? Math.max(0, input.length + begin) : begin, 
            0 <= limit ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input;
        };
    }
    function sliceFn(input, begin, end) {
        return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end);
    }
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder, compareValues) {
            if (null == array) return array;
            if (!isArrayLike(array)) throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
            0 === (sortPredicate = !isArray(sortPredicate) ? [ sortPredicate ] : sortPredicate).length && (sortPredicate = [ "+" ]);
            var predicates = sortPredicate.map(function(predicate) {
                var key, descending = 1, get = identity;
                return isFunction(predicate) ? get = predicate : isString(predicate) && ("+" !== predicate.charAt(0) && "-" !== predicate.charAt(0) || (descending = "-" === predicate.charAt(0) ? -1 : 1, 
                predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate)).constant && (key = get(), 
                get = function(value) {
                    return value[key];
                })), {
                    get: get,
                    descending: descending
                };
            }), descending = reverseOrder ? -1 : 1, compare = isFunction(compareValues) ? compareValues : defaultCompare, compareValues = Array.prototype.map.call(array, function(value, index) {
                return {
                    value: value,
                    tieBreaker: {
                        value: index,
                        type: "number",
                        index: index
                    },
                    predicateValues: predicates.map(function(predicate) {
                        return function(value, index) {
                            var type = typeof value;
                            null === value ? type = "null" : "object" === type && (value = function(value) {
                                if (isFunction(value.valueOf) && isPrimitive(value = value.valueOf())) return value;
                                if (hasCustomToString(value) && isPrimitive(value = value.toString())) return value;
                                return value;
                            }(value));
                            return {
                                value: value,
                                type: type,
                                index: index
                            };
                        }(predicate.get(value), index);
                    })
                };
            });
            return compareValues.sort(function(v1, v2) {
                for (var i = 0, ii = predicates.length; i < ii; i++) {
                    var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                    if (result) return result * predicates[i].descending * descending;
                }
                return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;
            }), array = compareValues.map(function(item) {
                return item.value;
            });
        };
        function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return 1;

              default:
                return;
            }
        }
        function defaultCompare(v1, v2) {
            var value1, value2, result = 0, type1 = v1.type, type2 = v2.type;
            return type1 === type2 ? (value1 = v1.value, value2 = v2.value, "string" === type1 ? (value1 = value1.toLowerCase(), 
            value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index), 
            isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value1 < value2 ? -1 : 1)) : result = "undefined" !== type1 && ("undefined" === type2 || "null" !== type1 && ("null" === type2 || type1 < type2)) ? -1 : 1, 
            result;
        }
    }
    function ngDirective(directive) {
        return (directive = isFunction(directive) ? {
            link: directive
        } : directive).restrict = directive.restrict || "AC", valueFn(directive);
    }
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref) return function(scope, element) {
                var href;
                "a" === element[0].nodeName.toLowerCase() && (href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href", 
                element.on("click", function(event) {
                    element.attr(href) || event.preventDefault();
                }));
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        var normalized, linkFn;
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function(value) {
                attr.$set(attrName, !!value);
            });
        }
        "multiple" !== propName && (normalized = directiveNormalize("ng-" + attrName), linkFn = "checked" === propName ? function(scope, element, attr) {
            attr.ngModel !== attr[normalized] && defaultLinkFn(scope, 0, attr);
        } : defaultLinkFn, ngAttributeAliasDirectives[normalized] = function() {
            return {
                restrict: "A",
                priority: 100,
                link: linkFn
            };
        });
    }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" === attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                    }
                    scope.$watch(attr[ngAttr], function(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = [ "$sce", function($sce) {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized])), 
                    attr.$observe(normalized, function(value) {
                        value ? (attr.$set(name, value), msie && propName && element.prop(propName, attr[name])) : "href" === attrName && attr.$set(name, null);
                    });
                }
            };
        } ];
    });
    var nullFormCtrl = {
        $addControl: noop,
        $getControls: valueFn([]),
        $$renameControl: function(control, name) {
            control.$name = name;
        },
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop,
        $$setSubmitted: noop
    };
    function FormController($element, $attrs, $scope, $animate, $interpolate) {
        this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0, 
        this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope), this.$dirty = !1, 
        this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1, 
        this.$$parentForm = nullFormCtrl, this.$$element = $element, this.$$animate = $animate, 
        setupValidity(this);
    }
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ], 
    FormController.prototype = {
        $rollbackViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$rollbackViewValue();
            });
        },
        $commitViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$commitViewValue();
            });
        },
        $addControl: function(control) {
            assertNotHasOwnProperty(control.$name, "input"), this.$$controls.push(control), 
            control.$name && (this[control.$name] = control), control.$$parentForm = this;
        },
        $getControls: function() {
            return shallowCopy(this.$$controls);
        },
        $$renameControl: function(control, newName) {
            var oldName = control.$name;
            this[oldName] === control && delete this[oldName], (this[newName] = control).$name = newName;
        },
        $removeControl: function(control) {
            control.$name && this[control.$name] === control && delete this[control.$name], 
            forEach(this.$pending, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), forEach(this.$error, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), forEach(this.$$success, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), arrayRemove(this.$$controls, control), control.$$parentForm = nullFormCtrl;
        },
        $setDirty: function() {
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), 
            this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty();
        },
        $setPristine: function() {
            this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " ng-submitted"), 
            this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, forEach(this.$$controls, function(control) {
                control.$setPristine();
            });
        },
        $setUntouched: function() {
            forEach(this.$$controls, function(control) {
                control.$setUntouched();
            });
        },
        $setSubmitted: function() {
            for (var rootForm = this; rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl; ) rootForm = rootForm.$$parentForm;
            rootForm.$$setSubmitted();
        },
        $$setSubmitted: function() {
            this.$$animate.addClass(this.$$element, "ng-submitted"), this.$submitted = !0, forEach(this.$$controls, function(control) {
                control.$$setSubmitted && control.$$setSubmitted();
            });
        }
    }, addSetValidityMethod({
        clazz: FormController,
        set: function(object, property, controller) {
            var list = object[property];
            list ? -1 === list.indexOf(controller) && list.push(controller) : object[property] = [ controller ];
        },
        unset: function(object, property, controller) {
            var list = object[property];
            list && (arrayRemove(list, controller), 0 === list.length && delete object[property]);
        }
    });
    var formDirective = (TIME_REGEXP = function(isNgForm) {
        return [ "$timeout", "$parse", function($timeout, $parse) {
            return {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: FormController,
                compile: function(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : !(!isNgForm || !attr.ngForm) && "ngForm";
                    return {
                        pre: function(scope, formElement, attr, ctrls) {
                            var handleFormSubmission, controller = ctrls[0];
                            "action" in attr || (handleFormSubmission = function(event) {
                                scope.$apply(function() {
                                    controller.$commitViewValue(), controller.$setSubmitted();
                                }), event.preventDefault();
                            }, formElement[0].addEventListener("submit", handleFormSubmission), formElement.on("$destroy", function() {
                                $timeout(function() {
                                    formElement[0].removeEventListener("submit", handleFormSubmission);
                                }, 0, !1);
                            })), (ctrls[1] || controller.$$parentForm).$addControl(controller);
                            var setter = nameAttr ? getSetter(controller.$name) : noop;
                            nameAttr && (setter(scope, controller), attr.$observe(nameAttr, function(newValue) {
                                controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue), 
                                (setter = getSetter(controller.$name))(scope, controller));
                            })), formElement.on("$destroy", function() {
                                controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            function getSetter(expression) {
                return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop;
            }
        } ];
    })(), ngFormDirective = TIME_REGEXP(!0);
    function setupValidity(instance) {
        instance.$$classCache = {}, instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
    }
    function addSetValidityMethod(context) {
        var clazz = context.clazz, set = context.set, unset = context.unset;
        function cachedToggleClass(ctrl, className, switchValue) {
            switchValue && !ctrl.$$classCache[className] ? (ctrl.$$animate.addClass(ctrl.$$element, className), 
            ctrl.$$classCache[className] = !0) : !switchValue && ctrl.$$classCache[className] && (ctrl.$$animate.removeClass(ctrl.$$element, className), 
            ctrl.$$classCache[className] = !1);
        }
        function toggleValidationCss(ctrl, validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, !0 === isValid), cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, !1 === isValid);
        }
        clazz.prototype.$setValidity = function(validationErrorKey, state, combinedState) {
            (void 0 === state ? function(ctrl, name, value, controller) {
                ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller);
            } : function(ctrl, name, value, controller) {
                ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0);
            })(this, "$pending", validationErrorKey, combinedState), isBoolean(state) ? state ? (unset(this.$error, validationErrorKey, combinedState), 
            set(this.$$success, validationErrorKey, combinedState)) : (set(this.$error, validationErrorKey, combinedState), 
            unset(this.$$success, validationErrorKey, combinedState)) : (unset(this.$error, validationErrorKey, combinedState), 
            unset(this.$$success, validationErrorKey, combinedState)), this.$pending ? (cachedToggleClass(this, "ng-pending", !0), 
            this.$valid = this.$invalid = void 0, toggleValidationCss(this, "", null)) : (cachedToggleClass(this, "ng-pending", !1), 
            this.$valid = isObjectEmpty(this.$error), this.$invalid = !this.$valid, toggleValidationCss(this, "", this.$valid)), 
            toggleValidationCss(this, validationErrorKey, combinedState = this.$pending && this.$pending[validationErrorKey] ? void 0 : !this.$error[validationErrorKey] && (!!this.$$success[validationErrorKey] || null)), 
            this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
        };
    }
    function isObjectEmpty(obj) {
        if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
        return !0;
    }
    var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/, jQuery = /^(\d{4,})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown", PARTIAL_VALIDATION_TYPES = createMap();
    forEach("date,datetime-local,month,time,week".split(","), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = !0;
    });
    var inputType = {
        text: function(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(0, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
        },
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, function(milliseconds, existingDate) {
            if (isDate(milliseconds)) return milliseconds;
            if (isString(milliseconds)) {
                WEEK_REGEXP.lastIndex = 0;
                var firstThurs = WEEK_REGEXP.exec(milliseconds);
                if (firstThurs) {
                    var year = +firstThurs[1], addDays = +firstThurs[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (addDays - 1);
                    return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), 
                    seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), 
                    new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
                }
            }
            return NaN;
        }, "yyyy-Www"),
        month: createDateInputType("month", jQuery, createDateParser(jQuery, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            var parsedMinVal;
            {
                var minVal;
                badInputChecker(0, element, 0, ctrl, "number"), numberFormatterParser(ctrl), baseInputType(0, element, attr, ctrl, $sniffer, $browser), 
                void 0 === attr.min && !attr.ngMin || (minVal = attr.min || $parse(attr.ngMin)(scope), 
                parsedMinVal = parseNumberAttrVal(minVal), ctrl.$validators.min = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || void 0 === parsedMinVal || parsedMinVal <= viewValue;
                }, attr.$observe("min", function(val) {
                    val !== minVal && (parsedMinVal = parseNumberAttrVal(val), minVal = val, ctrl.$validate());
                }));
            }
            {
                var maxVal, parsedMaxVal;
                void 0 === attr.max && !attr.ngMax || (maxVal = attr.max || $parse(attr.ngMax)(scope), 
                parsedMaxVal = parseNumberAttrVal(maxVal), ctrl.$validators.max = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || void 0 === parsedMaxVal || viewValue <= parsedMaxVal;
                }, attr.$observe("max", function(val) {
                    val !== maxVal && (parsedMaxVal = parseNumberAttrVal(val), maxVal = val, ctrl.$validate());
                }));
            }
            {
                var stepVal, parsedStepVal;
                void 0 === attr.step && !attr.ngStep || (stepVal = attr.step || $parse(attr.ngStep)(scope), 
                parsedStepVal = parseNumberAttrVal(stepVal), ctrl.$validators.step = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || void 0 === parsedStepVal || isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal);
                }, attr.$observe("step", function(val) {
                    val !== stepVal && (parsedStepVal = parseNumberAttrVal(val), stepVal = val, ctrl.$validate());
                }));
            }
        },
        url: function(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(0, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
            ctrl.$validators.url = function(modelValue, value) {
                value = modelValue || value;
                return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
            };
        },
        email: function(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(0, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
            ctrl.$validators.email = function(modelValue, value) {
                value = modelValue || value;
                return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
            };
        },
        radio: function(scope, element, attr, ctrl) {
            var doTrim = !attr.ngTrim || "false" !== trim(attr.ngTrim);
            void 0 === attr.name && element.attr("name", ++uid);
            element.on("change", function(ev) {
                var value;
                element[0].checked && (value = attr.value, doTrim && (value = trim(value)), ctrl.$setViewValue(value, ev && ev.type));
            }), ctrl.$render = function() {
                var value = attr.value;
                doTrim && (value = trim(value)), element[0].checked = value === ctrl.$viewValue;
            }, attr.$observe("value", ctrl.$render);
        },
        range: function(hasMinAttr, element, attr, ctrl, hasMaxAttr, hasStepAttr) {
            badInputChecker(0, element, 0, ctrl, "range"), numberFormatterParser(ctrl), baseInputType(0, element, attr, ctrl, hasMaxAttr, hasStepAttr);
            var supportsRange = ctrl.$$hasNativeValidators && "range" === element[0].type, minVal = supportsRange ? 0 : void 0, maxVal = supportsRange ? 100 : void 0, stepVal = supportsRange ? 1 : void 0, validity = element[0].validity, hasMinAttr = void 0 !== attr.min, hasMaxAttr = void 0 !== attr.max, hasStepAttr = void 0 !== attr.step, originalRender = ctrl.$render;
            ctrl.$render = supportsRange && void 0 !== validity.rangeUnderflow && void 0 !== validity.rangeOverflow ? function() {
                originalRender(), ctrl.$setViewValue(element.val());
            } : originalRender, hasMinAttr && (minVal = parseNumberAttrVal(attr.min), ctrl.$validators.min = supportsRange ? function() {
                return !0;
            } : function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || void 0 === minVal || minVal <= viewValue;
            }, setInitialValueAndObserver("min", function(elVal) {
                if (minVal = parseNumberAttrVal(elVal), isNumberNaN(ctrl.$modelValue)) return;
                supportsRange ? ((elVal = element.val()) < minVal && (elVal = minVal, element.val(elVal)), 
                ctrl.$setViewValue(elVal)) : ctrl.$validate();
            }));
            hasMaxAttr && (maxVal = parseNumberAttrVal(attr.max), ctrl.$validators.max = supportsRange ? function() {
                return !0;
            } : function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || void 0 === maxVal || viewValue <= maxVal;
            }, setInitialValueAndObserver("max", function(elVal) {
                if (maxVal = parseNumberAttrVal(elVal), isNumberNaN(ctrl.$modelValue)) return;
                supportsRange ? (elVal = element.val(), maxVal < elVal && (element.val(maxVal), 
                elVal = maxVal < minVal ? minVal : maxVal), ctrl.$setViewValue(elVal)) : ctrl.$validate();
            }));
            hasStepAttr && (stepVal = parseNumberAttrVal(attr.step), ctrl.$validators.step = supportsRange ? function() {
                return !validity.stepMismatch;
            } : function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || void 0 === stepVal || isValidForStep(viewValue, minVal || 0, stepVal);
            }, setInitialValueAndObserver("step", function(val) {
                if (stepVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue)) return;
                supportsRange ? ctrl.$viewValue !== element.val() && ctrl.$setViewValue(element.val()) : ctrl.$validate();
            }));
            function setInitialValueAndObserver(htmlAttrName, changeFn) {
                element.attr(htmlAttrName, attr[htmlAttrName]);
                var oldVal = attr[htmlAttrName];
                attr.$observe(htmlAttrName, function(val) {
                    val !== oldVal && changeFn(oldVal = val);
                });
            }
        },
        checkbox: function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1);
            element.on("change", function(ev) {
                ctrl.$setViewValue(element[0].checked, ev && ev.type);
            }), ctrl.$render = function() {
                element[0].checked = ctrl.$viewValue;
            }, ctrl.$isEmpty = function(value) {
                return !1 === value;
            }, ctrl.$formatters.push(function(value) {
                return equals(value, trueValue);
            }), ctrl.$parsers.push(function(value) {
                return value ? trueValue : falseValue;
            });
        },
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    };
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var composing, timeout, type = lowercase(element[0].type);
        $sniffer.android || (composing = !1, element.on("compositionstart", function() {
            composing = !0;
        }), element.on("compositionupdate", function(ev) {
            void 0 !== ev.data && "" !== ev.data || (composing = !1);
        }), element.on("compositionend", function() {
            composing = !1, listener();
        }));
        var deferListener, listener = function(event) {
            var value;
            timeout && ($browser.defer.cancel(timeout), timeout = null), composing || (value = element.val(), 
            event = event && event.type, "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), 
            (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event));
        };
        $sniffer.hasEvent("input") ? element.on("input", listener) : (deferListener = function(ev, input, origValue) {
            timeout = timeout || $browser.defer(function() {
                timeout = null, input && input.value === origValue || listener(ev);
            });
        }, element.on("keydown", function(event) {
            var key = event.keyCode;
            91 === key || 15 < key && key < 19 || 37 <= key && key <= 40 || deferListener(event, this, this.value);
        }), $sniffer.hasEvent("paste") && element.on("paste cut drop", deferListener)), 
        element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            var validity, origBadInput, origTypeMismatch;
            timeout || (validity = this[VALIDITY_STATE_PROPERTY], origBadInput = validity.badInput, 
            origTypeMismatch = validity.typeMismatch, timeout = $browser.defer(function() {
                timeout = null, validity.badInput === origBadInput && validity.typeMismatch === origTypeMismatch || listener(ev);
            }));
        }), ctrl.$render = function() {
            var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
            element.val() !== value && element.val(value);
        };
    }
    function createDateParser(regexp, mapping) {
        return function(date, previousDate) {
            var map;
            if (isDate(date)) return date;
            if (isString(date)) {
                if ('"' === date.charAt(0) && '"' === date.charAt(date.length - 1) && (date = date.substring(1, date.length - 1)), 
                ISO_DATE_REGEXP.test(date)) return new Date(date);
                if (regexp.lastIndex = 0, date = regexp.exec(date)) {
                    date.shift(), map = previousDate ? {
                        yyyy: previousDate.getFullYear(),
                        MM: previousDate.getMonth() + 1,
                        dd: previousDate.getDate(),
                        HH: previousDate.getHours(),
                        mm: previousDate.getMinutes(),
                        ss: previousDate.getSeconds(),
                        sss: previousDate.getMilliseconds() / 1e3
                    } : {
                        yyyy: 1970,
                        MM: 1,
                        dd: 1,
                        HH: 0,
                        mm: 0,
                        ss: 0,
                        sss: 0
                    }, forEach(date, function(part, index) {
                        index < mapping.length && (map[mapping[index]] = +part);
                    });
                    date = new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
                    return map.yyyy < 100 && date.setFullYear(map.yyyy), date;
                }
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            badInputChecker(0, element, 0, ctrl, type), baseInputType(0, element, attr, ctrl, $sniffer, $browser);
            var previousDate, previousTimezone, minVal, parsedMinVal, maxVal, parsedMaxVal, isTimeType = "time" === type || "datetimelocal" === type;
            function isValidDate(value) {
                return value && (!value.getTime || value.getTime() === value.getTime());
            }
            function parseObservedDateValue(val) {
                return void 0 === val || isDate(val) ? val : parseDateAndConvertTimeZoneToLocal(val) || void 0;
            }
            function parseDateAndConvertTimeZoneToLocal(value, parsedDate) {
                var timezone = ctrl.$options.getOption("timezone");
                previousTimezone && previousTimezone !== timezone && (parsedDate = addDateMinutes(parsedDate, timezoneToOffset(previousTimezone)));
                parsedDate = parseDate(value, parsedDate);
                return parsedDate = !isNaN(parsedDate) && timezone ? convertTimezoneToLocal(parsedDate, timezone) : parsedDate;
            }
            ctrl.$parsers.push(function(value) {
                return ctrl.$isEmpty(value) ? null : regexp.test(value) ? parseDateAndConvertTimeZoneToLocal(value, previousDate) : void (ctrl.$$parserName = type);
            }), ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                if (isValidDate(value)) {
                    previousDate = value;
                    var timezone = ctrl.$options.getOption("timezone");
                    return timezone && (previousDate = convertTimezoneToLocal(previousDate, previousTimezone = timezone, !0)), 
                    function(value, formatted) {
                        var targetFormat = format;
                        isTimeType && isString(ctrl.$options.getOption("timeSecondsFormat")) && (targetFormat = format.replace("ss.sss", ctrl.$options.getOption("timeSecondsFormat")).replace(/:$/, ""));
                        formatted = $filter("date")(value, targetFormat, formatted);
                        isTimeType && ctrl.$options.getOption("timeStripZeroSeconds") && (formatted = formatted.replace(/(?::00)?(?:\.000)?$/, ""));
                        return formatted;
                    }(value, timezone);
                }
                return previousTimezone = previousDate = null, "";
            }), void 0 === attr.min && !attr.ngMin || (minVal = attr.min || $parse(attr.ngMin)(scope), 
            parsedMinVal = parseObservedDateValue(minVal), ctrl.$validators.min = function(value) {
                return !isValidDate(value) || void 0 === parsedMinVal || parseDate(value) >= parsedMinVal;
            }, attr.$observe("min", function(val) {
                val !== minVal && (parsedMinVal = parseObservedDateValue(val), minVal = val, ctrl.$validate());
            })), void 0 === attr.max && !attr.ngMax || (maxVal = attr.max || $parse(attr.ngMax)(scope), 
            parsedMaxVal = parseObservedDateValue(maxVal), ctrl.$validators.max = function(value) {
                return !isValidDate(value) || void 0 === parsedMaxVal || parseDate(value) <= parsedMaxVal;
            }, attr.$observe("max", function(val) {
                val !== maxVal && (parsedMaxVal = parseObservedDateValue(val), maxVal = val, ctrl.$validate());
            }));
        };
    }
    function badInputChecker(scope, element, attr, ctrl, parserName) {
        var node = element[0];
        (ctrl.$$hasNativeValidators = isObject(node.validity)) && ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            if (!validity.badInput && !validity.typeMismatch) return value;
            ctrl.$$parserName = parserName;
        });
    }
    function numberFormatterParser(ctrl) {
        ctrl.$parsers.push(function(value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void (ctrl.$$parserName = "number");
        }), ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString();
            }
            return value;
        });
    }
    function parseNumberAttrVal(val) {
        return void 0 === val || isNumber(val) || (val = parseFloat(val)), isNumberNaN(val) ? void 0 : val;
    }
    function isNumberInteger(num) {
        return (0 | num) === num;
    }
    function countDecimals(num) {
        var match = num.toString(), decimalSymbolIndex = match.indexOf(".");
        if (-1 !== decimalSymbolIndex) return match.length - decimalSymbolIndex - 1;
        if (-1 < num && num < 1) {
            match = /e-(\d+)$/.exec(match);
            if (match) return Number(match[1]);
        }
        return 0;
    }
    function isValidForStep(multiplier, stepBase, step) {
        var valueDecimals, stepBaseDecimals, value = Number(multiplier), isNonIntegerValue = !isNumberInteger(value), isNonIntegerStepBase = !isNumberInteger(stepBase), isNonIntegerStep = !isNumberInteger(step);
        return (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) && (valueDecimals = isNonIntegerValue ? countDecimals(value) : 0, 
        stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0, multiplier = isNonIntegerStep ? countDecimals(step) : 0, 
        multiplier = Math.max(valueDecimals, stepBaseDecimals, multiplier), value *= multiplier = Math.pow(10, multiplier), 
        stepBase *= multiplier, step *= multiplier, isNonIntegerValue && (value = Math.round(value)), 
        isNonIntegerStepBase && (stepBase = Math.round(stepBase)), isNonIntegerStep && (step = Math.round(step))), 
        (value - stepBase) % step == 0;
    }
    function parseConstantExpr(parseFn, context, name, expression, fallback) {
        if (void 0 === expression) return fallback;
        if (!(parseFn = parseFn(expression)).constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
        return parseFn(context);
    }
    function hiddenInputBrowserCacheDirective() {
        var valueProperty = {
            configurable: !0,
            enumerable: !1,
            get: function() {
                return this.getAttribute("value") || "";
            },
            set: function(val) {
                this.setAttribute("value", val);
            }
        };
        return {
            restrict: "E",
            priority: 200,
            compile: function(_, attr) {
                if ("hidden" === lowercase(attr.type)) return {
                    pre: function(scope, node, attr, ctrls) {
                        node = node[0];
                        node.parentNode && node.parentNode.insertBefore(node, node.nextSibling), Object.defineProperty && Object.defineProperty(node, "value", valueProperty);
                    }
                };
            }
        };
    }
    function ngValueDirective() {
        function updateElementValue(element, attr, value) {
            var propValue = void 0 !== value ? value : 9 === msie ? "" : null;
            element.prop("value", propValue), attr.$set("value", value);
        }
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    updateElementValue(elm, attr, scope.$eval(attr.ngValue));
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        updateElementValue(elm, attr, value);
                    });
                };
            }
        };
    }
    var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                }
            }
        };
    } ], CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                        element.textContent = stringify(value);
                    });
                };
            }
        };
    } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], 
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = void 0 === value ? "" : value;
                    });
                };
            }
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(val) {
                    return $sce.valueOf(val);
                });
                return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                        var value = ngBindHtmlGetter(scope);
                        element.html($sce.getTrustedHtml(value) || "");
                    });
                };
            }
        };
    } ], ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });
    function classDirective(name, selector) {
        var indexWatchExpression;
        return name = "ngClass" + name, [ "$parse", function($parse) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    var oldClassString, classCounts = element.data("$classCounts"), oldModulo = !0;
                    function digestClassCounts(classArray, count) {
                        var classesToUpdate = [];
                        return forEach(classArray, function(className) {
                            (0 < count || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(0 < count) && classesToUpdate.push(className));
                        }), classesToUpdate.join(" ");
                    }
                    classCounts || (classCounts = createMap(), element.data("$classCounts", classCounts)), 
                    "ngClass" !== name && (indexWatchExpression = indexWatchExpression || $parse("$index", function($index) {
                        return 1 & $index;
                    }), scope.$watch(indexWatchExpression, function(newModulo) {
                        (newModulo === selector ? function(classString) {
                            classString = digestClassCounts(split(classString), 1), attr.$addClass(classString);
                        } : function(classString) {
                            classString = digestClassCounts(split(classString), -1), attr.$removeClass(classString);
                        })(oldClassString);
                        oldModulo = newModulo;
                    })), scope.$watch($parse(attr[name], toClassString), function(newClassString) {
                        oldModulo === selector && function(newClassArray, toRemoveString) {
                            var toAddString = split(newClassArray), newClassArray = split(toRemoveString), toRemoveString = arrayDifference(toAddString, newClassArray), toAddString = arrayDifference(newClassArray, toAddString), toRemoveString = digestClassCounts(toRemoveString, -1), toAddString = digestClassCounts(toAddString, 1);
                            attr.$addClass(toAddString), attr.$removeClass(toRemoveString);
                        }(oldClassString, newClassString);
                        oldClassString = newClassString;
                    });
                }
            };
        } ];
        function arrayDifference(tokens1, tokens2) {
            if (!tokens1 || !tokens1.length) return [];
            if (!tokens2 || !tokens2.length) return tokens1;
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
                for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
                values.push(token);
            }
            return values;
        }
        function split(classString) {
            return classString && classString.split(" ");
        }
        function toClassString(classValue) {
            if (!classValue) return classValue;
            var classString = classValue;
            return isArray(classValue) ? classString = classValue.map(toClassString).join(" ") : isObject(classValue) ? classString = Object.keys(classValue).filter(function(key) {
                return classValue[key];
            }).join(" ") : isString(classValue) || (classString = classValue + ""), classString;
        }
    }
    var ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", void 0), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {}, forceAsyncEvents = {
        blur: !0,
        focus: !0
    };
    function createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsync) {
        return {
            restrict: "A",
            compile: function($element, attr) {
                var fn = $parse(attr[directiveName]);
                return function(scope, element) {
                    element.on(eventName, function(event) {
                        function callback() {
                            fn(scope, {
                                $event: event
                            });
                        }
                        if ($rootScope.$$phase) if (forceAsync) scope.$evalAsync(callback); else try {
                            callback();
                        } catch (error) {
                            $exceptionHandler(error);
                        } else scope.$apply(callback);
                    });
                };
            }
        };
    }
    function ngListDirective() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = attr.ngList || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList;
                ctrl.$parsers.push(function(viewValue) {
                    if (void 0 !== viewValue) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trimValues ? trim(value) : value);
                        }), list;
                    }
                }), ctrl.$formatters.push(function(value) {
                    if (isArray(value)) return value.join(ngList);
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", "$exceptionHandler", function($parse, $rootScope, $exceptionHandler) {
            return createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsyncEvents[eventName]);
        } ];
    });
    var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    value ? childScope || $transclude(function(clone, newScope) {
                        childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    }) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), 
                    $animate.leave(previousElements).done(function(response) {
                        !1 !== response && (previousElements = null);
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    function cleanupLastIncludeContent() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement).done(function(response) {
                            !1 !== response && (previousElement = null);
                        }), previousElement = currentElement, currentElement = null);
                    }
                    var currentScope, previousElement, currentElement, changeCounter = 0;
                    scope.$watch(srcExp, function(src) {
                        function afterAnimation(response) {
                            !1 === response || void 0 === autoScrollExp || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }
                        var thisChangeId = ++changeCounter;
                        src ? ($templateRequest(src, !0).then(function(clone) {
                            var newScope;
                            scope.$$destroyed || thisChangeId === changeCounter && (newScope = scope.$new(), 
                            ctrl.template = clone, clone = $transclude(newScope, function(clone) {
                                cleanupLastIncludeContent(), $animate.enter(clone, null, $element).done(afterAnimation);
                            }), currentElement = clone, (currentScope = newScope).$emit("$includeContentLoaded", src), 
                            scope.$eval(onloadExp));
                        }, function() {
                            scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(), 
                            scope.$emit("$includeContentError", src));
                        }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), 
                        ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                if (toString.call($element[0]).match(/SVG/)) return $element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function(clone) {
                    $element.append(clone);
                }, {
                    futureParentElement: $element
                });
                $element.html(ctrl.template), $compile($element.contents())(scope);
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", ngModelMinErr = minErr("ngModel");
    function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
        var ctrl;
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, 
        this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], 
        this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, 
        this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, 
        this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope), 
        this.$$parentForm = nullFormCtrl, this.$options = defaultModelOptions, this.$$updateEvents = "", 
        this.$$updateEventHandler = this.$$updateEventHandler.bind(this), this.$$parsedNgModel = $parse($attr.ngModel), 
        this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel, 
        this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0, 
        this.$$parserName = "parse", this.$$currentValidationRunId = 0, this.$$scope = $scope, 
        this.$$rootScope = $scope.$root, this.$$attr = $attr, this.$$element = $element, 
        this.$$animate = $animate, this.$$timeout = $timeout, this.$$parse = $parse, this.$$q = $q, 
        this.$$exceptionHandler = $exceptionHandler, setupValidity(this), (ctrl = this).$$scope.$watch(function(modelValue) {
            modelValue = ctrl.$$ngModelGet(modelValue);
            return modelValue === ctrl.$modelValue || ctrl.$modelValue != ctrl.$modelValue && modelValue != modelValue || ctrl.$$setModelValue(modelValue), 
            modelValue;
        });
    }
    NgModelController.$inject = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate" ], 
    NgModelController.prototype = {
        $$initGetterSetters: function() {
            if (this.$options.getOption("getterSetter")) {
                var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                this.$$ngModelGet = function($scope) {
                    var modelValue = this.$$parsedNgModel($scope);
                    return modelValue = isFunction(modelValue) ? invokeModelGetter($scope) : modelValue;
                }, this.$$ngModelSet = function($scope, newValue) {
                    isFunction(this.$$parsedNgModel($scope)) ? invokeModelSetter($scope, {
                        $$$p: newValue
                    }) : this.$$parsedNgModelAssign($scope, newValue);
                };
            } else if (!this.$$parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
        },
        $render: noop,
        $isEmpty: function(value) {
            return void 0 === value || "" === value || null === value || value != value;
        },
        $$updateEmptyClasses: function(value) {
            this.$isEmpty(value) ? (this.$$animate.removeClass(this.$$element, "ng-not-empty"), 
            this.$$animate.addClass(this.$$element, "ng-empty")) : (this.$$animate.removeClass(this.$$element, "ng-empty"), 
            this.$$animate.addClass(this.$$element, "ng-not-empty"));
        },
        $setPristine: function() {
            this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, DIRTY_CLASS), 
            this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
        },
        $setDirty: function() {
            this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), 
            this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$$parentForm.$setDirty();
        },
        $setUntouched: function() {
            this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, "ng-untouched", "ng-touched");
        },
        $setTouched: function() {
            this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, "ng-touched", "ng-untouched");
        },
        $rollbackViewValue: function() {
            this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue, 
            this.$render();
        },
        $validate: function() {
            var viewValue, modelValue, prevValid, prevModelValue, allowInvalid, that;
            isNumberNaN(this.$modelValue) || (viewValue = this.$$lastCommittedViewValue, modelValue = this.$$rawModelValue, 
            prevValid = this.$valid, prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid"), 
            (that = this).$$runValidators(modelValue, viewValue, function(allValid) {
                allowInvalid || prevValid === allValid || (that.$modelValue = allValid ? modelValue : void 0, 
                that.$modelValue !== prevModelValue && that.$$writeModelToScope());
            }));
        },
        $$runValidators: function(modelValue, viewValue, doneCallback) {
            this.$$currentValidationRunId++;
            var syncValidatorsValid, validatorPromises, allValid, localValidationRunId = this.$$currentValidationRunId, that = this;
            function setValidity(name, isValid) {
                localValidationRunId === that.$$currentValidationRunId && that.$setValidity(name, isValid);
            }
            function validationDone(allValid) {
                localValidationRunId === that.$$currentValidationRunId && doneCallback(allValid);
            }
            !function() {
                var errorKey = that.$$parserName;
                {
                    if (void 0 !== that.$$parserValid) return that.$$parserValid || (forEach(that.$validators, function(v, name) {
                        setValidity(name, null);
                    }), forEach(that.$asyncValidators, function(v, name) {
                        setValidity(name, null);
                    })), setValidity(errorKey, that.$$parserValid), that.$$parserValid;
                    setValidity(errorKey, null);
                }
                return !0;
            }() ? validationDone(!1) : (syncValidatorsValid = !0, forEach(that.$validators, function(result, name) {
                result = Boolean(result(modelValue, viewValue));
                syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
            }), syncValidatorsValid || (forEach(that.$asyncValidators, function(v, name) {
                setValidity(name, null);
            }), 0) ? (validatorPromises = [], allValid = !0, forEach(that.$asyncValidators, function(promise, name) {
                promise = promise(modelValue, viewValue);
                if (!isPromiseLike(promise)) throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                setValidity(name, void 0), validatorPromises.push(promise.then(function() {
                    setValidity(name, !0);
                }, function() {
                    setValidity(name, allValid = !1);
                }));
            }), validatorPromises.length ? that.$$q.all(validatorPromises).then(function() {
                validationDone(allValid);
            }, noop) : validationDone(!0)) : validationDone(!1));
        },
        $commitViewValue: function() {
            var viewValue = this.$viewValue;
            this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== viewValue || "" === viewValue && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(viewValue), 
            this.$$lastCommittedViewValue = viewValue, this.$pristine && this.$setDirty(), this.$$parseAndValidate());
        },
        $$parseAndValidate: function() {
            var modelValue = this.$$lastCommittedViewValue, that = this;
            if (this.$$parserValid = void 0 !== modelValue || void 0, this.$setValidity(this.$$parserName, null), 
            this.$$parserName = "parse", this.$$parserValid) for (var i = 0; i < this.$parsers.length; i++) if (void 0 === (modelValue = this.$parsers[i](modelValue))) {
                this.$$parserValid = !1;
                break;
            }
            isNumberNaN(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
            var prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid");
            function writeToModelIfNeeded() {
                that.$modelValue !== prevModelValue && that.$$writeModelToScope();
            }
            this.$$rawModelValue = modelValue, allowInvalid && (this.$modelValue = modelValue, 
            writeToModelIfNeeded()), this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
                allowInvalid || (that.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded());
            });
        },
        $$writeModelToScope: function() {
            this.$$ngModelSet(this.$$scope, this.$modelValue), forEach(this.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    this.$$exceptionHandler(e);
                }
            }, this);
        },
        $setViewValue: function(value, trigger) {
            this.$viewValue = value, this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(trigger);
        },
        $$debounceViewValueCommit: function(trigger) {
            var debounceDelay = this.$options.getOption("debounce");
            isNumber(debounceDelay[trigger]) ? debounceDelay = debounceDelay[trigger] : isNumber(debounceDelay.default) && -1 === this.$options.getOption("updateOn").indexOf(trigger) ? debounceDelay = debounceDelay.default : isNumber(debounceDelay["*"]) && (debounceDelay = debounceDelay["*"]), 
            this.$$timeout.cancel(this.$$pendingDebounce);
            var that = this;
            0 < debounceDelay ? this.$$pendingDebounce = this.$$timeout(function() {
                that.$commitViewValue();
            }, debounceDelay) : this.$$rootScope.$$phase ? this.$commitViewValue() : this.$$scope.$apply(function() {
                that.$commitViewValue();
            });
        },
        $overrideModelOptions: function(options) {
            this.$options = this.$options.createChild(options), this.$$setUpdateOnEvents();
        },
        $processModelValue: function() {
            var viewValue = this.$$format();
            this.$viewValue !== viewValue && (this.$$updateEmptyClasses(viewValue), this.$viewValue = this.$$lastCommittedViewValue = viewValue, 
            this.$render(), this.$$runValidators(this.$modelValue, this.$viewValue, noop));
        },
        $$format: function() {
            for (var formatters = this.$formatters, idx = formatters.length, viewValue = this.$modelValue; idx--; ) viewValue = formatters[idx](viewValue);
            return viewValue;
        },
        $$setModelValue: function(modelValue) {
            this.$modelValue = this.$$rawModelValue = modelValue, this.$$parserValid = void 0, 
            this.$processModelValue();
        },
        $$setUpdateOnEvents: function() {
            this.$$updateEvents && this.$$element.off(this.$$updateEvents, this.$$updateEventHandler), 
            this.$$updateEvents = this.$options.getOption("updateOn"), this.$$updateEvents && this.$$element.on(this.$$updateEvents, this.$$updateEventHandler);
        },
        $$updateEventHandler: function(ev) {
            this.$$debounceViewValueCommit(ev && ev.type);
        }
    }, addSetValidityMethod({
        clazz: NgModelController,
        set: function(object, property) {
            object[property] = !0;
        },
        unset: function(object, property) {
            delete object[property];
        }
    });
    var defaultModelOptions, ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function(element) {
                return element.addClass(PRISTINE_CLASS).addClass("ng-untouched").addClass(VALID_CLASS), 
                {
                    pre: function(scope, element, attr, optionsCtrl) {
                        var modelCtrl = optionsCtrl[0], formCtrl = optionsCtrl[1] || modelCtrl.$$parentForm, optionsCtrl = optionsCtrl[2];
                        optionsCtrl && (modelCtrl.$options = optionsCtrl.$options), modelCtrl.$$initGetterSetters(), 
                        formCtrl.$addControl(modelCtrl), attr.$observe("name", function(newValue) {
                            modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                        }), scope.$on("$destroy", function() {
                            modelCtrl.$$parentForm.$removeControl(modelCtrl);
                        });
                    },
                    post: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        function setTouched() {
                            modelCtrl.$setTouched();
                        }
                        modelCtrl.$$setUpdateOnEvents(), element.on("blur", function() {
                            modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(setTouched) : scope.$apply(setTouched));
                        });
                    }
                };
            }
        };
    } ], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    function ModelOptions(options) {
        this.$$options = options;
    }
    function ngModelOptionsDirective() {
        function NgModelOptionsController($attrs, $scope) {
            this.$$attrs = $attrs, this.$$scope = $scope;
        }
        return NgModelOptionsController.$inject = [ "$attrs", "$scope" ], NgModelOptionsController.prototype = {
            $onInit: function() {
                var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions, modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                this.$options = parentOptions.createChild(modelOptionsDefinition);
            }
        }, {
            restrict: "A",
            priority: 10,
            require: {
                parentCtrl: "?^^ngModelOptions"
            },
            bindToController: !0,
            controller: NgModelOptionsController
        };
    }
    function defaults(dst, src) {
        forEach(src, function(value, key) {
            void 0 === dst[key] && (dst[key] = value);
        });
    }
    ModelOptions.prototype = {
        getOption: function(name) {
            return this.$$options[name];
        },
        createChild: function(options) {
            var inheritAll = !1;
            return forEach(options = extend({}, options), function(option, key) {
                "$inherit" === option ? "*" === key ? inheritAll = !0 : (options[key] = this.$$options[key], 
                "updateOn" === key && (options.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === key && (options.updateOnDefault = !1, 
                options[key] = trim(option.replace(DEFAULT_REGEXP, function() {
                    return options.updateOnDefault = !0, " ";
                })));
            }, this), inheritAll && (delete options["*"], defaults(options, this.$$options)), 
            defaults(options, defaultModelOptions.$$options), new ModelOptions(options);
        }
    }, defaultModelOptions = new ModelOptions({
        updateOn: "",
        updateOnDefault: !0,
        debounce: 0,
        getterSetter: !1,
        allowInvalid: !1,
        timezone: null
    });
    var ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
        function parseOptionsExpression(selectAs, valueFn, scope) {
            var match = selectAs.match(NG_OPTIONS_REGEXP);
            if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", selectAs, startingTag(valueFn));
            function getTrackByValue(value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            }
            var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), viewValueFn = selectAs && $parse(selectAs) || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function(value, locals) {
                return trackByFn(scope, locals);
            } : function(value) {
                return hashKey(value);
            }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function(value, key) {
                return locals[keyName] = key, locals[valueName] = value, locals;
            } : function(value) {
                return locals[valueName] = value, locals;
            };
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, 
                this.group = group, this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else for (var itemKey in optionValuesKeys = [], 
                optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                return optionValuesKeys;
            }
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function(optionValues) {
                    for (var watchedArray = [], optionValuesKeys = getOptionValuesKeys(optionValues = optionValues || []), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                        var disableWhen = optionValues === optionValuesKeys ? index : optionValuesKeys[index], label = optionValues[disableWhen], disableWhen = getLocals(label, disableWhen), label = getTrackByValueFn(label, disableWhen);
                        watchedArray.push(label), (match[2] || match[1]) && (label = displayFn(scope, disableWhen), 
                        watchedArray.push(label)), match[4] && (disableWhen = disableWhenFn(scope, disableWhen), 
                        watchedArray.push(disableWhen));
                    }
                    return watchedArray;
                }),
                getOptions: function() {
                    for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                        var selectValue = optionValues === optionValuesKeys ? index : optionValuesKeys[index], optionItem = getLocals(optionValues[selectValue], selectValue), viewValue = viewValueFn(scope, optionItem), selectValue = getTrackByValueFn(viewValue, optionItem), optionItem = new Option(selectValue, viewValue, displayFn(scope, optionItem), groupByFn(scope, optionItem), disableWhenFn(scope, optionItem));
                        optionItems.push(optionItem), selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function(option) {
                            return trackBy ? copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "ngModel" ],
            link: {
                pre: function(scope, selectElement, attr, ctrls) {
                    ctrls[0].registerOption = noop;
                },
                post: function(scope, selectElement, attr, providedEmptyOption) {
                    for (var selectCtrl = providedEmptyOption[0], ngModelCtrl = providedEmptyOption[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) if ("" === children[i].value) {
                        selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = children.eq(i);
                        break;
                    }
                    selectElement.empty();
                    var options, providedEmptyOption = !!selectCtrl.emptyOption;
                    jqLite(optionTemplate.cloneNode(!1)).val("?");
                    var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope), listFragment = $document[0].createDocumentFragment();
                    function addOptionElement(option, parent) {
                        var optionElement = optionTemplate.cloneNode(!1);
                        parent.appendChild(optionElement), function(option, element) {
                            (option.element = element).disabled = option.disabled, option.label !== element.label && (element.label = option.label, 
                            element.textContent = option.label), element.value = option.selectValue;
                        }(option, optionElement);
                    }
                    function getAndUpdateSelectedOption(element) {
                        var option = options.getOptionFromViewValue(element), element = option && option.element;
                        return element && !element.selected && (element.selected = !0), option;
                    }
                    selectCtrl.generateUnknownOptionValue = function(val) {
                        return "?";
                    }, multiple ? (selectCtrl.writeValue = function(values) {
                        var selectedOptions;
                        options && (selectedOptions = values && values.map(getAndUpdateSelectedOption) || [], 
                        options.items.forEach(function(option) {
                            option.element.selected && !includes(selectedOptions, option) && (option.element.selected = !1);
                        }));
                    }, selectCtrl.readValue = function() {
                        var selectedValues = selectElement.val() || [], selections = [];
                        return forEach(selectedValues, function(option) {
                            option = options.selectValueMap[option];
                            option && !option.disabled && selections.push(options.getViewValueFromOption(option));
                        }), selections;
                    }, ngOptions.trackBy && scope.$watchCollection(function() {
                        if (isArray(ngModelCtrl.$viewValue)) return ngModelCtrl.$viewValue.map(function(value) {
                            return ngOptions.getTrackByValue(value);
                        });
                    }, function() {
                        ngModelCtrl.$render();
                    })) : (selectCtrl.writeValue = function(value) {
                        var selectedOption, option;
                        options && (selectedOption = selectElement[0].options[selectElement[0].selectedIndex], 
                        option = options.getOptionFromViewValue(value), selectedOption && selectedOption.removeAttribute("selected"), 
                        option ? (selectElement[0].value !== option.selectValue && (selectCtrl.removeUnknownOption(), 
                        selectElement[0].value = option.selectValue, option.element.selected = !0), option.element.setAttribute("selected", "selected")) : selectCtrl.selectUnknownOrEmptyOption(value));
                    }, selectCtrl.readValue = function() {
                        var selectedOption = options.selectValueMap[selectElement.val()];
                        return selectedOption && !selectedOption.disabled ? (selectCtrl.unselectEmptyOption(), 
                        selectCtrl.removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null;
                    }, ngOptions.trackBy && scope.$watch(function() {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                    }, function() {
                        ngModelCtrl.$render();
                    })), providedEmptyOption && ($compile(selectCtrl.emptyOption)(scope), selectElement.prepend(selectCtrl.emptyOption), 
                    selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT ? (selectCtrl.hasEmptyOption = !1, 
                    selectCtrl.registerOption = function(optionScope, optionEl) {
                        "" === optionEl.val() && (selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = optionEl, 
                        selectCtrl.emptyOption.removeClass("ng-scope"), ngModelCtrl.$render(), optionEl.on("$destroy", function() {
                            var needsRerender = selectCtrl.$isEmptyOptionSelected();
                            selectCtrl.hasEmptyOption = !1, selectCtrl.emptyOption = void 0, needsRerender && ngModelCtrl.$render();
                        }));
                    }) : selectCtrl.emptyOption.removeClass("ng-scope")), scope.$watchCollection(ngOptions.getWatchables, function() {
                        var previousValue = options && selectCtrl.readValue();
                        if (options) for (var i = options.items.length - 1; 0 <= i; i--) {
                            var option = options.items[i];
                            void 0 !== option.group ? jqLiteRemove(option.element.parentNode) : jqLiteRemove(option.element);
                        }
                        options = ngOptions.getOptions();
                        var groupElementMap = {};
                        {
                            var nextValue;
                            options.items.forEach(function(option) {
                                var groupElement;
                                void 0 !== option.group ? ((groupElement = groupElementMap[option.group]) || (groupElement = optGroupTemplate.cloneNode(!1), 
                                listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group, 
                                groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment);
                            }), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), ngModelCtrl.$isEmpty(previousValue) || (nextValue = selectCtrl.readValue(), 
                            (ngOptions.trackBy || multiple ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), 
                            ngModelCtrl.$render()));
                        }
                    });
                }
            }
        };
    } ], ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function(scope, element, attr) {
                var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                function updateElementText(newText) {
                    element.text(newText || "");
                }
                forEach(attr, function(expression, attributeName) {
                    var whenKey = IS_WHEN.exec(attributeName);
                    whenKey && (whenKey = (whenKey[1] ? "-" : "") + lowercase(whenKey[2]), whens[whenKey] = element.attr(attr.$attr[attributeName]));
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                }), scope.$watch(numberExp, function(newVal) {
                    var count = parseFloat(newVal), whenExpFn = isNumberNaN(count);
                    (count = !(whenExpFn || count in whens) ? $locale.pluralCat(count - offset) : count) === lastCount || whenExpFn && isNumberNaN(lastCount) || (watchRemover(), 
                    void 0 === (whenExpFn = whensExpFns[count]) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), 
                    watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), 
                    lastCount = count);
                });
            }
        };
    } ], ngRefMinErr = minErr("ngRef"), ngRefDirective = [ "$parse", function($parse) {
        return {
            priority: -1,
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var controllerName = directiveNormalize(nodeName_(tElement)), getter = $parse(tAttrs.ngRef), setter = getter.assign || function() {
                    throw ngRefMinErr("nonassign", 'Expression in ngRef="{0}" is non-assignable!', tAttrs.ngRef);
                };
                return function(scope, element, attrs) {
                    var refValue;
                    if (attrs.hasOwnProperty("ngRefRead")) {
                        if ("$element" === attrs.ngRefRead) refValue = element; else if (!(refValue = element.data("$" + attrs.ngRefRead + "Controller"))) throw ngRefMinErr("noctrl", 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', attrs.ngRefRead, tAttrs.ngRef);
                    } else refValue = element.data("$" + controllerName + "Controller");
                    setter(scope, refValue = refValue || element), element.on("$destroy", function() {
                        getter(scope) === refValue && setter(scope, null);
                    });
                };
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
        function updateScope(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, 
            scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), 
            scope.$odd = !(scope.$even = 0 == (1 & index));
        }
        function trackByIdArrayFn($scope, key, value) {
            return hashKey(value);
        }
        function trackByIdObjFn($scope, key) {
            return key;
        }
        var ngRepeatMinErr = minErr("ngRepeat");
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function($element, trackByExp) {
                var expression = trackByExp.ngRepeat, ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                if (!(match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/))) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                var hashFnLocals, trackByExpGetter, trackByIdExpFn, valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                return trackByExp && (hashFnLocals = {
                    $id: hashKey
                }, trackByExpGetter = $parse(trackByExp), trackByIdExpFn = function($scope, key, value, index) {
                    return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                    hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                }), function($scope, $element, $attr, ctrl, $transclude) {
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function(collection) {
                        var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, blockKey, previousNode = $element[0], nextBlockMap = createMap();
                        if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, 
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else for (var itemKey in trackByIdFn = trackByIdExpFn || trackByIdObjFn, 
                        collectionKeys = [], collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                        for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), 
                        index = 0; index < collectionLength; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], trackById = trackByIdFn($scope, key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], 
                        delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                            if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                block && block.scope && (lastBlockMap[block.id] = block);
                            }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            nextBlockOrder[index] = {
                                id: trackById,
                                scope: void 0,
                                clone: void 0
                            }, nextBlockMap[trackById] = !0;
                        }
                        for (blockKey in hashFnLocals && (hashFnLocals[valueIdentifier] = void 0), lastBlockMap) {
                            if (elementsToRemove = getBlockNodes((block = lastBlockMap[blockKey]).clone), $animate.leave(elementsToRemove), 
                            elementsToRemove[0].parentNode) for (index = 0, length = elementsToRemove.length; index < length; index++) elementsToRemove[index].$$NG_REMOVED = !0;
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], (block = nextBlockOrder[index]).scope) {
                            for (nextNode = previousNode; nextNode = nextNode.nextSibling, nextNode && nextNode.$$NG_REMOVED; ) ;
                            block.clone[0] !== nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode), 
                            previousNode = function(block) {
                                return block.clone[block.clone.length - 1];
                            }(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        } else $transclude(function(clone, endNode) {
                            block.scope = endNode;
                            endNode = ngRepeatEndComment.cloneNode(!1);
                            clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode, 
                            block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        });
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ], ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function(value) {
                    $animate[value ? "removeClass" : "addClass"](element, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function(value) {
                    $animate[value ? "addClass" : "removeClass"](element, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watchCollection(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        });
    }), ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, watchExpr, ngSwitchController) {
                var selectedTranscludes, watchExpr = watchExpr.ngSwitch || watchExpr.on, selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                scope.$watch(watchExpr, function(value) {
                    for (var i, ii; previousLeaveAnimations.length; ) $animate.cancel(previousLeaveAnimations.pop());
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy(), (previousLeaveAnimations[i] = $animate.leave(selected)).done(function(array, index) {
                            return function(response) {
                                !1 !== response && array.splice(index, 1);
                            };
                        }(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                        selectedTransclude.transclude(function(caseElement, block) {
                            selectedScopes.push(block);
                            var anchor = selectedTransclude.element;
                            caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                            block = {
                                clone: caseElement
                            };
                            selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    });
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attrs, ctrl, $transclude) {
            forEach(attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                return array[index - 1] !== element;
            }), function(whenCase) {
                ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [], ctrl.cases["!" + whenCase].push({
                    transclude: $transclude,
                    element: element
                });
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeMinErr = minErr("ngTransclude"), ngTranscludeDirective = [ "$compile", function($compile) {
        return {
            restrict: "EAC",
            compile: function(tElement) {
                var fallbackLinkFn = $compile(tElement.contents());
                return tElement.empty(), function($scope, $element, slotName, controller, $transclude) {
                    if (!$transclude) throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                    slotName.ngTransclude === slotName.$attr.ngTransclude && (slotName.ngTransclude = "");
                    slotName = slotName.ngTransclude || slotName.ngTranscludeSlot;
                    function useFallbackContent() {
                        fallbackLinkFn($scope, function(clone) {
                            $element.append(clone);
                        });
                    }
                    $transclude(function(clone, transcludedScope) {
                        clone.length && function(nodes) {
                            for (var i = 0, ii = nodes.length; i < ii; i++) {
                                var node = nodes[i];
                                if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) return !0;
                            }
                        }(clone) ? $element.append(clone) : (useFallbackContent(), transcludedScope.$destroy());
                    }, null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent();
                };
            }
        };
    } ], scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(text, templateUrl) {
                "text/ng-template" === templateUrl.type && (templateUrl = templateUrl.id, text = text[0].text, 
                $templateCache.put(templateUrl, text));
            }
        };
    } ], noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    };
    function setOptionSelectedStatus(optionEl, value) {
        optionEl.prop("selected", value), optionEl.attr("selected", value);
    }
    function selectDirective() {
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            priority: 1,
            link: {
                pre: function(scope, element, attr, ctrls) {
                    var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl) return void (selectCtrl.registerOption = noop);
                    {
                        var lastView, lastViewRef;
                        selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", function() {
                            selectCtrl.removeUnknownOption(), scope.$apply(function() {
                                ngModelCtrl.$setViewValue(selectCtrl.readValue());
                            });
                        }), attr.multiple && (selectCtrl.multiple = !0, selectCtrl.readValue = function() {
                            var array = [];
                            return forEach(element.find("option"), function(val) {
                                val.selected && !val.disabled && (val = val.value, array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val));
                            }), array;
                        }, selectCtrl.writeValue = function(value) {
                            forEach(element.find("option"), function(option) {
                                var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                                shouldBeSelected !== option.selected && setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                            });
                        }, lastViewRef = NaN, scope.$watch(function() {
                            lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), 
                            ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue;
                        }), ngModelCtrl.$isEmpty = function(value) {
                            return !value || 0 === value.length;
                        });
                    }
                },
                post: function(scope, element, attrs, ctrls) {
                    var ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl) return;
                    var selectCtrl = ctrls[0];
                    ngModelCtrl.$render = function() {
                        selectCtrl.writeValue(ngModelCtrl.$viewValue);
                    };
                }
            }
        };
    }
    var originalCleanData, SelectController = [ "$element", "$scope", function($element, $scope) {
        var self = this, optionsMap = new NgMap();
        self.selectValueMap = {}, self.ngModelCtrl = noopNgModelController, self.multiple = !1, 
        self.unknownOption = jqLite(window.document.createElement("option")), self.hasEmptyOption = !1, 
        self.emptyOption = void 0, self.renderUnknownOption = function(unknownVal) {
            unknownVal = self.generateUnknownOptionValue(unknownVal);
            self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), setOptionSelectedStatus(self.unknownOption, !0), 
            $element.val(unknownVal);
        }, self.updateUnknownOption = function(unknownVal) {
            unknownVal = self.generateUnknownOptionValue(unknownVal);
            self.unknownOption.val(unknownVal), setOptionSelectedStatus(self.unknownOption, !0), 
            $element.val(unknownVal);
        }, self.generateUnknownOptionValue = function(val) {
            return "? " + hashKey(val) + " ?";
        }, self.removeUnknownOption = function() {
            self.unknownOption.parent() && self.unknownOption.remove();
        }, self.selectEmptyOption = function() {
            self.emptyOption && ($element.val(""), setOptionSelectedStatus(self.emptyOption, !0));
        }, self.unselectEmptyOption = function() {
            self.hasEmptyOption && setOptionSelectedStatus(self.emptyOption, !1);
        }, $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        }), self.readValue = function() {
            var realVal = $element.val(), realVal = realVal in self.selectValueMap ? self.selectValueMap[realVal] : realVal;
            return self.hasOption(realVal) ? realVal : null;
        }, self.writeValue = function(value) {
            var selectedOption = $element[0].options[$element[0].selectedIndex];
            selectedOption && setOptionSelectedStatus(jqLite(selectedOption), !1), self.hasOption(value) ? (self.removeUnknownOption(), 
            selectedOption = hashKey(value), $element.val(selectedOption in self.selectValueMap ? selectedOption : value), 
            selectedOption = $element[0].options[$element[0].selectedIndex], setOptionSelectedStatus(jqLite(selectedOption), !0)) : self.selectUnknownOrEmptyOption(value);
        }, self.addOption = function(value, count) {
            count[0].nodeType !== NODE_TYPE_COMMENT && (assertNotHasOwnProperty(value, '"option value"'), 
            "" === value && (self.hasEmptyOption = !0, self.emptyOption = count), count = optionsMap.get(value) || 0, 
            optionsMap.set(value, count + 1), scheduleRender());
        }, self.removeOption = function(value) {
            var count = optionsMap.get(value);
            count && (1 === count ? (optionsMap.delete(value), "" === value && (self.hasEmptyOption = !1, 
            self.emptyOption = void 0)) : optionsMap.set(value, count - 1));
        }, self.hasOption = function(value) {
            return !!optionsMap.get(value);
        }, self.$hasEmptyOption = function() {
            return self.hasEmptyOption;
        }, self.$isUnknownOptionSelected = function() {
            return $element[0].options[0] === self.unknownOption[0];
        }, self.$isEmptyOptionSelected = function() {
            return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0];
        };
        var renderScheduled = !(self.selectUnknownOrEmptyOption = function(value) {
            null == value && self.emptyOption ? (self.removeUnknownOption(), self.selectEmptyOption()) : self.unknownOption.parent().length ? self.updateUnknownOption(value) : self.renderUnknownOption(value);
        });
        function scheduleRender() {
            renderScheduled || (renderScheduled = !0, $scope.$$postDigest(function() {
                renderScheduled = !1, self.ngModelCtrl.$render();
            }));
        }
        var updateScheduled = !1;
        function scheduleViewValueUpdate(renderAfter) {
            updateScheduled || (updateScheduled = !0, $scope.$$postDigest(function() {
                $scope.$$destroyed || (updateScheduled = !1, self.ngModelCtrl.$setViewValue(self.readValue()), 
                renderAfter && self.ngModelCtrl.$render());
            }));
        }
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
            var oldVal, hashedVal;
            optionAttrs.$attr.ngValue ? optionAttrs.$observe("value", function(newVal) {
                var removal, previouslySelected = optionElement.prop("selected");
                void 0 !== hashedVal && (self.removeOption(oldVal), delete self.selectValueMap[hashedVal], 
                removal = !0), hashedVal = hashKey(newVal), oldVal = newVal, self.selectValueMap[hashedVal] = newVal, 
                self.addOption(newVal, optionElement), optionElement.attr("value", hashedVal), removal && previouslySelected && scheduleViewValueUpdate();
            }) : interpolateValueFn ? optionAttrs.$observe("value", function(newVal) {
                var removal;
                self.readValue();
                var previouslySelected = optionElement.prop("selected");
                void 0 !== oldVal && (self.removeOption(oldVal), removal = !0), oldVal = newVal, 
                self.addOption(newVal, optionElement), removal && previouslySelected && scheduleViewValueUpdate();
            }) : interpolateTextFn ? optionScope.$watch(interpolateTextFn, function(newVal, oldVal) {
                optionAttrs.$set("value", newVal);
                var previouslySelected = optionElement.prop("selected");
                oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement), 
                oldVal && previouslySelected && scheduleViewValueUpdate();
            }) : self.addOption(optionAttrs.value, optionElement), optionAttrs.$observe("disabled", function(newVal) {
                ("true" === newVal || newVal && optionElement.prop("selected")) && (self.multiple ? scheduleViewValueUpdate(!0) : (self.ngModelCtrl.$setViewValue(null), 
                self.ngModelCtrl.$render()));
            }), optionElement.on("$destroy", function() {
                var currentValue = self.readValue(), removeValue = optionAttrs.value;
                self.removeOption(removeValue), scheduleRender(), (self.multiple && currentValue && -1 !== currentValue.indexOf(removeValue) || currentValue === removeValue) && scheduleViewValueUpdate(!0);
            });
        };
    } ], optionDirective = [ "$interpolate", function($interpolate) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                var interpolateValueFn, interpolateTextFn;
                return void 0 !== attr.ngValue || (void 0 !== attr.value ? interpolateValueFn = $interpolate(attr.value, !0) : (interpolateTextFn = $interpolate(element.text(), !0)) || attr.$set("value", element.text())), 
                function(scope, element, attr) {
                    var selectCtrl = element.parent(), selectCtrl = selectCtrl.data("$selectController") || selectCtrl.parent().data("$selectController");
                    selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                };
            }
        };
    } ], requiredDirective = [ "$parse", function($parse) {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                var value;
                ctrl && (value = attr.hasOwnProperty("required") || $parse(attr.ngRequired)(scope), 
                attr.ngRequired || (attr.required = !0), ctrl.$validators.required = function(modelValue, viewValue) {
                    return !value || !ctrl.$isEmpty(viewValue);
                }, attr.$observe("required", function(newVal) {
                    value !== newVal && (value = newVal, ctrl.$validate());
                }));
            }
        };
    } ], patternDirective = [ "$parse", function($parse) {
        return {
            restrict: "A",
            require: "?ngModel",
            compile: function(tElm, tAttr) {
                var patternExp, parseFn;
                return tAttr.ngPattern && (patternExp = tAttr.ngPattern, parseFn = "/" === tAttr.ngPattern.charAt(0) && REGEX_STRING_REGEXP.test(tAttr.ngPattern) ? function() {
                    return tAttr.ngPattern;
                } : $parse(tAttr.ngPattern)), function(scope, elm, attr, ctrl) {
                    var attrVal, regexp;
                    ctrl && (attrVal = attr.pattern, attr.ngPattern ? attrVal = parseFn(scope) : patternExp = attr.pattern, 
                    regexp = parsePatternAttr(attrVal, patternExp, elm), attr.$observe("pattern", function(newVal) {
                        var oldRegexp = regexp;
                        regexp = parsePatternAttr(newVal, patternExp, elm), (oldRegexp && oldRegexp.toString()) !== (regexp && regexp.toString()) && ctrl.$validate();
                    }), ctrl.$validators.pattern = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || void 0 === regexp || regexp.test(viewValue);
                    });
                };
            }
        };
    } ], maxlengthDirective = [ "$parse", function($parse) {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                var maxlength, maxlengthParsed;
                ctrl && (maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope), maxlengthParsed = parseLength(maxlength), 
                attr.$observe("maxlength", function(value) {
                    maxlength !== value && (maxlengthParsed = parseLength(value), maxlength = value, 
                    ctrl.$validate());
                }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                    return maxlengthParsed < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlengthParsed;
                });
            }
        };
    } ], minlengthDirective = [ "$parse", function($parse) {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                var minlength, minlengthParsed;
                ctrl && (minlength = attr.minlength || $parse(attr.ngMinlength)(scope), minlengthParsed = parseLength(minlength) || -1, 
                attr.$observe("minlength", function(value) {
                    minlength !== value && (minlengthParsed = parseLength(value) || -1, minlength = value, 
                    ctrl.$validate());
                }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed;
                });
            }
        };
    } ];
    function parsePatternAttr(regex, patternExp, elm) {
        if (regex) {
            if (!(regex = isString(regex) ? new RegExp("^" + regex + "$") : regex).test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
            return regex;
        }
    }
    function parseLength(intVal) {
        intVal = toInt(intVal);
        return isNumberNaN(intVal) ? -1 : intVal;
    }
    window.angular.bootstrap ? window.console && console.log("WARNING: Tried to load AngularJS more than once.") : (bindJQueryFired || ((jQuery = void 0 === (jQuery = jq()) ? window.jQuery : jQuery ? window[jQuery] : void 0) && jQuery.fn.on ? extend((jqLite = jQuery).fn, {
        scope: JQLitePrototype.scope,
        isolateScope: JQLitePrototype.isolateScope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
    }) : jqLite = JQLite, originalCleanData = jqLite.cleanData, jqLite.cleanData = function(elems) {
        for (var events, elem, i = 0; null != (elem = elems[i]); i++) (events = (jqLite._data(elem) || {}).events) && events.$destroy && jqLite(elem).triggerHandler("$destroy");
        originalCleanData(elems);
    }, angular.element = jqLite, bindJQueryFired = !0), function(angular) {
        extend(angular, {
            errorHandlingConfig: errorHandlingConfig,
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            merge: merge,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            callbacks: {
                $$counter: 0
            },
            getTestability: getTestability,
            reloadWithDebugInfo: reloadWithDebugInfo,
            UNSAFE_restoreLegacyJqLiteXHTMLReplacement: UNSAFE_restoreLegacyJqLiteXHTMLReplacement,
            $$minErr: minErr,
            $$csp: csp,
            $$encodeUriSegment: encodeUriSegment,
            $$encodeUriQuery: encodeUriQuery,
            $$lowercase: lowercase,
            $$stringify: stringify,
            $$uppercase: uppercase
        }), (angularModule = setupModuleLoader(window))("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRef: ngRefDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective,
                input: hiddenInputBrowserCacheDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $$isDocumentHidden: $$IsDocumentHiddenProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $$intervalFactory: $$IntervalFactoryProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $$taskTrackerFactory: $$TaskTrackerFactoryProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$Map: $$MapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        } ]).info({
            angularVersion: "1.8.2"
        });
    }(angular), angular.module("ngLocale", [], [ "$provide", function($provide) {
        var PLURAL_CATEGORY_ONE = "one", PLURAL_CATEGORY_OTHER = "other";
        function getVF(n, base) {
            var v = base;
            void 0 === v && (v = Math.min(function(n) {
                var i = (n += "").indexOf(".");
                return -1 == i ? 0 : n.length - i - 1;
            }(n), 3));
            base = Math.pow(10, v);
            return {
                v: v,
                f: (n * base | 0) % base
            };
        }
        $provide.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                short: "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            localeID: "en_US",
            pluralCat: function(n, vf) {
                var i = 0 | n, vf = getVF(n, vf);
                return 1 == i && 0 == vf.v ? PLURAL_CATEGORY_ONE : PLURAL_CATEGORY_OTHER;
            }
        });
    } ]), jqLite(function() {
        angularInit(window.document, bootstrap);
    }));
}(window), window.angular.$$csp().noInlineStyle || window.angular.element(document.head).prepend(window.angular.element("<style>").text('@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}')), 
function(window, angular) {
    "use strict";
    var bind, extend, forEach, isArray, isDefined, lowercase, noop, nodeContains, htmlParser, htmlSanitizeWriter, $sanitizeMinErr = angular.$$minErr("$sanitize");
    angular.module("ngSanitize", []).provider("$sanitize", function() {
        var hasBeenInstantiated = !1, svgEnabled = !1;
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return hasBeenInstantiated = !0, svgEnabled && extend(validElements, svgElements), 
            function(html) {
                var buf = [];
                return htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
                })), buf.join("");
            };
        } ], this.enableSvg = function(enableSvg) {
            return isDefined(enableSvg) ? (svgEnabled = enableSvg, this) : svgEnabled;
        }, this.addValidElements = function(elements) {
            return hasBeenInstantiated || (isArray(elements) && (elements = {
                htmlElements: elements
            }), addElementsTo(svgElements, elements.svgElements), addElementsTo(voidElements, elements.htmlVoidElements), 
            addElementsTo(validElements, elements.htmlVoidElements), addElementsTo(validElements, elements.htmlElements)), 
            this;
        }, this.addValidAttrs = function(attrs) {
            return hasBeenInstantiated || extend(validAttrs, arrayToMap(attrs, !0)), this;
        }, bind = angular.bind, extend = angular.extend, forEach = angular.forEach, isArray = angular.isArray, 
        isDefined = angular.isDefined, lowercase = angular.$$lowercase, noop = angular.noop, 
        htmlParser = function(html, handler) {
            null == html ? html = "" : "string" != typeof html && (html = "" + html);
            var inertBodyElement = getInertBodyElement(html);
            if (!inertBodyElement) return "";
            var mXSSAttempts = 5;
            do {
                if (0 === mXSSAttempts) throw $sanitizeMinErr("uinput", "Failed to sanitize html because the input is unstable");
            } while (mXSSAttempts--, html = inertBodyElement.innerHTML, inertBodyElement = getInertBodyElement(html), 
            html !== inertBodyElement.innerHTML);
            var nextNode, node = inertBodyElement.firstChild;
            for (;node; ) {
                switch (node.nodeType) {
                  case 1:
                    handler.start(node.nodeName.toLowerCase(), function(attrs) {
                        for (var map = {}, i = 0, ii = attrs.length; i < ii; i++) {
                            var attr = attrs[i];
                            map[attr.name] = attr.value;
                        }
                        return map;
                    }(node.attributes));
                    break;

                  case 3:
                    handler.chars(node.textContent);
                }
                if (!((nextNode = node.firstChild) || (1 === node.nodeType && handler.end(node.nodeName.toLowerCase()), 
                nextNode = getNonDescendant("nextSibling", node)))) for (;null == nextNode && (node = getNonDescendant("parentNode", node)) !== inertBodyElement; ) nextNode = getNonDescendant("nextSibling", node), 
                1 === node.nodeType && handler.end(node.nodeName.toLowerCase());
                node = nextNode;
            }
            for (;node = inertBodyElement.firstChild; ) inertBodyElement.removeChild(node);
        }, htmlSanitizeWriter = function(buf, uriValidator) {
            var ignoreCurrentElement = !1, out = bind(buf, buf.push);
            return {
                start: function(tag, attrs) {
                    tag = lowercase(tag), (ignoreCurrentElement = !ignoreCurrentElement && blockedElements[tag] ? tag : ignoreCurrentElement) || !0 !== validElements[tag] || (out("<"), 
                    out(tag), forEach(attrs, function(value, key) {
                        var lkey = lowercase(key), isImage = "img" === tag && "src" === lkey || "background" === lkey;
                        !0 !== validAttrs[lkey] || !0 === uriAttrs[lkey] && !uriValidator(value, isImage) || (out(" "), 
                        out(key), out('="'), out(encodeEntities(value)), out('"'));
                    }), out(">"));
                },
                end: function(tag) {
                    tag = lowercase(tag), ignoreCurrentElement || !0 !== validElements[tag] || !0 === voidElements[tag] || (out("</"), 
                    out(tag), out(">")), tag == ignoreCurrentElement && (ignoreCurrentElement = !1);
                },
                chars: function(chars) {
                    ignoreCurrentElement || out(encodeEntities(chars));
                }
            };
        }, nodeContains = window.Node.prototype.contains || function(arg) {
            return !!(16 & this.compareDocumentPosition(arg));
        };
        var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g, voidElements = stringToMap("area,br,col,hr,img,wbr"), blockElements = stringToMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), htmlAttrs = stringToMap("rp,rt"), svgAttrs = extend({}, htmlAttrs, blockElements), blockElements = extend({}, blockElements, stringToMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul")), htmlAttrs = extend({}, htmlAttrs, stringToMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), svgElements = stringToMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan"), blockedElements = stringToMap("script,style"), validElements = extend({}, voidElements, blockElements, htmlAttrs, svgAttrs), uriAttrs = stringToMap("background,cite,href,longdesc,src,xlink:href,xml:base"), htmlAttrs = stringToMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width"), svgAttrs = stringToMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan", !0), validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs);
        function stringToMap(str, lowercaseKeys) {
            return arrayToMap(str.split(","), lowercaseKeys);
        }
        function arrayToMap(items, lowercaseKeys) {
            for (var obj = {}, i = 0; i < items.length; i++) obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = !0;
            return obj;
        }
        function addElementsTo(elementsMap, newElements) {
            newElements && newElements.length && extend(elementsMap, arrayToMap(newElements));
        }
        var getInertBodyElement = function(window, document) {
            if (function() {
                try {
                    return !!getInertBodyElement_DOMParser("");
                } catch (e) {
                    return !1;
                }
            }()) return getInertBodyElement_DOMParser;
            if (!document || !document.implementation) throw $sanitizeMinErr("noinert", "Can't create an inert html document");
            var inertDocument = document.implementation.createHTMLDocument("inert"), inertBodyElement = (inertDocument.documentElement || inertDocument.getDocumentElement()).querySelector("body");
            return function(html) {
                inertBodyElement.innerHTML = html, document.documentMode && stripCustomNsAttrs(inertBodyElement);
                return inertBodyElement;
            };
            function getInertBodyElement_DOMParser(html) {
                html = "<remove></remove>" + html;
                try {
                    var body = new window.DOMParser().parseFromString(html, "text/html").body;
                    return body.firstChild.remove(), body;
                } catch (e) {
                    return;
                }
            }
        }(window, window.document);
        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
                return "&#" + (1024 * (value.charCodeAt(0) - 55296) + (value.charCodeAt(1) - 56320) + 65536) + ";";
            }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
                return "&#" + value.charCodeAt(0) + ";";
            }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        function stripCustomNsAttrs(node) {
            for (;node; ) {
                if (node.nodeType === window.Node.ELEMENT_NODE) for (var attrs = node.attributes, i = 0, l = attrs.length; i < l; i++) {
                    var attrNode = attrs[i], attrName = attrNode.name.toLowerCase();
                    "xmlns:ns1" !== attrName && 0 !== attrName.lastIndexOf("ns1:", 0) || (node.removeAttributeNode(attrNode), 
                    i--, l--);
                }
                var nextNode = node.firstChild;
                nextNode && stripCustomNsAttrs(nextNode), node = getNonDescendant("nextSibling", node);
            }
        }
        function getNonDescendant(nextNode, node) {
            nextNode = node[nextNode];
            if (nextNode && nodeContains.call(node, nextNode)) throw $sanitizeMinErr("elclob", "Failed to sanitize html because the element is clobbered: {0}", node.outerHTML || node.outerText);
            return nextNode;
        }
    }).info({
        angularVersion: "1.8.2"
    }), angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((s?ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i, MAILTO_REGEXP = /^mailto:/i, linkyMinErr = angular.$$minErr("linky"), isDefined = angular.isDefined, isFunction = angular.isFunction, isObject = angular.isObject, isString = angular.isString;
        return function(text, target, attributes) {
            if (null == text || "" === text) return text;
            if (!isString(text)) throw linkyMinErr("notstring", "Expected string but received: {0}", text);
            for (var match, url, i, attributesFn = isFunction(attributes) ? attributes : isObject(attributes) ? function() {
                return attributes;
            } : function() {
                return {};
            }, raw = text, html = []; match = raw.match(LINKY_URL_REGEXP); ) url = match[0], 
            match[2] || match[4] || (url = (match[3] ? "http://" : "mailto:") + url), i = match.index, 
            addText(raw.substr(0, i)), function(url, text) {
                var key, linkAttributes = attributesFn(url);
                for (key in html.push("<a "), linkAttributes) html.push(key + '="' + linkAttributes[key] + '" ');
                !isDefined(target) || "target" in linkAttributes || html.push('target="', target, '" '), 
                html.push('href="', url.replace(/"/g, "&quot;"), '">'), addText(text), html.push("</a>");
            }(url, match[0].replace(MAILTO_REGEXP, "")), raw = raw.substring(i + match[0].length);
            return addText(raw), $sanitize(html.join(""));
            function addText(buf) {
                var chars;
                buf && html.push((chars = buf, htmlSanitizeWriter(buf = [], noop).chars(chars), 
                buf.join("")));
            }
        };
    } ]);
}(window, window.angular), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.moment = factory();
}(this, function() {
    "use strict";
    var hookCallback, some;
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function isArray(input) {
        return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input);
    }
    function isObject(input) {
        return null != input && "[object Object]" === Object.prototype.toString.call(input);
    }
    function isNumber(input) {
        return "number" == typeof input || "[object Number]" === Object.prototype.toString.call(input);
    }
    function isDate(input) {
        return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input);
    }
    function map(arr, fn) {
        for (var res = [], i = 0; i < arr.length; ++i) res.push(fn(arr[i], i));
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) hasOwnProp(b, i) && (a[i] = b[i]);
        return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), 
        a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, !0).utc();
    }
    function getParsingFlags(m) {
        return null == m._pf && (m._pf = {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: !1,
            weekdayMismatch: !1
        }), m._pf;
    }
    function isValid(m) {
        if (null == m._isValid) {
            var flags = getParsingFlags(m), isNowValid = some.call(flags.parsedDateParts, function(i) {
                return null != i;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && isNowValid);
            if (m._strict && (isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour), 
            null != Object.isFrozen && Object.isFrozen(m)) return isNowValid;
            m._isValid = isNowValid;
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        return null != flags ? extend(getParsingFlags(m), flags) : getParsingFlags(m).userInvalidated = !0, 
        m;
    }
    some = Array.prototype.some || function(fun) {
        for (var t = Object(this), len = t.length >>> 0, i = 0; i < len; i++) if (i in t && fun.call(this, t[i], i, t)) return !0;
        return !1;
    };
    var momentProperties = hooks.momentProperties = [];
    function copyConfig(to, from) {
        var i, prop, val;
        if (void 0 !== from._isAMomentObject && (to._isAMomentObject = from._isAMomentObject), 
        void 0 !== from._i && (to._i = from._i), void 0 !== from._f && (to._f = from._f), 
        void 0 !== from._l && (to._l = from._l), void 0 !== from._strict && (to._strict = from._strict), 
        void 0 !== from._tzm && (to._tzm = from._tzm), void 0 !== from._isUTC && (to._isUTC = from._isUTC), 
        void 0 !== from._offset && (to._offset = from._offset), void 0 !== from._pf && (to._pf = getParsingFlags(from)), 
        void 0 !== from._locale && (to._locale = from._locale), 0 < momentProperties.length) for (i = 0; i < momentProperties.length; i++) void 0 !== (val = from[prop = momentProperties[i]]) && (to[prop] = val);
        return to;
    }
    var updateInProgress = !1;
    function Moment(config) {
        copyConfig(this, config), this._d = new Date(null != config._d ? config._d.getTime() : NaN), 
        this.isValid() || (this._d = new Date(NaN)), !1 === updateInProgress && (updateInProgress = !0, 
        hooks.updateOffset(this), updateInProgress = !1);
    }
    function isMoment(obj) {
        return obj instanceof Moment || null != obj && null != obj._isAMomentObject;
    }
    function absFloor(number) {
        return number < 0 ? Math.ceil(number) || 0 : Math.floor(number);
    }
    function toInt(value) {
        var coercedNumber = +value, value = 0;
        return value = 0 != coercedNumber && isFinite(coercedNumber) ? absFloor(coercedNumber) : value;
    }
    function compareArrays(array1, array2, dontConvert) {
        for (var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i = 0; i < len; i++) (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
        return diffs + lengthDiff;
    }
    function warn(msg) {
        !1 === hooks.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg);
    }
    function deprecate(msg, fn) {
        var firstTime = !0;
        return extend(function() {
            if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), firstTime) {
                for (var arg, args = [], i = 0; i < arguments.length; i++) {
                    if (arg = "", "object" == typeof arguments[i]) {
                        for (var key in arg += "\n[" + i + "] ", arguments[0]) arg += key + ": " + arguments[0][key] + ", ";
                        arg = arg.slice(0, -2);
                    } else arg = arguments[i];
                    args.push(arg);
                }
                warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack), 
                firstTime = !1;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var keys, deprecations = {};
    function deprecateSimple(name, msg) {
        null != hooks.deprecationHandler && hooks.deprecationHandler(name, msg), deprecations[name] || (warn(msg), 
        deprecations[name] = !0);
    }
    function isFunction(input) {
        return input instanceof Function || "[object Function]" === Object.prototype.toString.call(input);
    }
    function mergeConfigs(parentConfig, childConfig) {
        var prop, res = extend({}, parentConfig);
        for (prop in childConfig) hasOwnProp(childConfig, prop) && (isObject(parentConfig[prop]) && isObject(childConfig[prop]) ? (res[prop] = {}, 
        extend(res[prop], parentConfig[prop]), extend(res[prop], childConfig[prop])) : null != childConfig[prop] ? res[prop] = childConfig[prop] : delete res[prop]);
        for (prop in parentConfig) hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop]) && (res[prop] = extend({}, res[prop]));
        return res;
    }
    function Locale(config) {
        null != config && this.set(config);
    }
    hooks.suppressDeprecationWarnings = !1, hooks.deprecationHandler = null, keys = Object.keys || function(obj) {
        var i, res = [];
        for (i in obj) hasOwnProp(obj, i) && res.push(i);
        return res;
    };
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return "string" == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedProp, prop, normalizedInput = {};
        for (prop in inputObject) hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop)) && (normalizedInput[normalizedProp] = inputObject[prop]);
        return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function zeroFill(number, zerosToFill, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = zerosToFill - absNumber.length;
        return (0 <= number ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = "string" == typeof callback ? function() {
            return this[callback]();
        } : callback;
        token && (formatTokenFunctions[token] = func), padded && (formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        }), ordinal && (formatTokenFunctions[ordinal] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        });
    }
    function formatMoment(m, format) {
        return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] = formatFunctions[format] || function(format) {
            for (var input, array = format.match(formattingTokens), i = 0, length = array.length; i < length; i++) formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = (input = array[i]).match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "");
            return function(mom) {
                for (var output = "", i = 0; i < length; i++) output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
                return output;
            };
        }(format), formatFunctions[format](m)) : m.localeData().invalidDate();
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        for (localFormattingTokens.lastIndex = 0; 0 <= i && localFormattingTokens.test(format); ) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), 
        localFormattingTokens.lastIndex = 0, --i;
        return format;
    }
    var asSeconds = /\d/, asMinutes = /\d\d/, asDays = /\d{3}/, proto = /\d{4}/, asMilliseconds = /[+-]?\d{6}/, match1to2 = /\d\d?/, milliseconds = /\d\d\d\d?/, lang = /\d\d\d\d\d\d?/, asHours = /\d{1,3}/, days = /\d{1,4}/, proto$2 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, asWeeks = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes = {};
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        return hasOwnProp(regexes, token) ? regexes[token](config._strict, config._locale) : new RegExp(regexEscape(token.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        })));
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i, func = callback;
        for ("string" == typeof token && (token = [ token ]), isNumber(callback) && (func = function(input, array) {
            array[callback] = toInt(input);
        }), i = 0; i < token.length; i++) tokens[token[i]] = func;
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {}, callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        null != input && hasOwnProp(tokens, token) && tokens[token](input, config._a, config, token);
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    }
    addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? "" + y : "+" + y;
    }), addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    }), addFormatToken(0, [ "YYYY", 4 ], 0, "year"), addFormatToken(0, [ "YYYYY", 5 ], 0, "year"), 
    addFormatToken(0, [ "YYYYYY", 6, !0 ], 0, "year"), addUnitAlias("year", "y"), addUnitPriority("year", 1), 
    addRegexToken("Y", matchSigned), addRegexToken("YY", match1to2, asMinutes), addRegexToken("YYYY", days, proto), 
    addRegexToken("YYYYY", proto$2, asMilliseconds), addRegexToken("YYYYYY", proto$2, asMilliseconds), 
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR), addParseToken("YYYY", function(input, array) {
        array[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input);
    }), addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    }), addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
    }), hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (68 < toInt(input) ? 1900 : 2e3);
    };
    var indexOf, years = makeGetSet("FullYear", !0);
    function makeGetSet(unit, keepTime) {
        return function(value) {
            return null != value ? (set$1(this, unit, value), hooks.updateOffset(this, keepTime), 
            this) : get(this, unit);
        };
    }
    function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
        mom.isValid() && !isNaN(value) && ("FullYear" === unit && isLeapYear(mom.year()) && 1 === mom.month() && 29 === mom.date() ? mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month())) : mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value));
    }
    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) return NaN;
        var modMonth, modMonth = (month % (modMonth = 12) + modMonth) % modMonth;
        return year += (month - modMonth) / 12, 1 == modMonth ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    indexOf = Array.prototype.indexOf || function(o) {
        for (var i = 0; i < this.length; ++i) if (this[i] === o) return i;
        return -1;
    }, addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    }), addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    }), addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    }), addUnitAlias("month", "M"), addUnitPriority("month", 8), addRegexToken("M", match1to2), 
    addRegexToken("MM", match1to2, asMinutes), addRegexToken("MMM", function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    }), addRegexToken("MMMM", function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
    }), addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    }), addParseToken([ "MMM", "MMMM" ], function(input, array, config, month) {
        month = config._locale.monthsParse(input, month, config._strict);
        null != month ? array[MONTH] = month : getParsingFlags(config).invalidMonth = input;
    });
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, months = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
    var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) return mom;
        if ("string" == typeof value) if (/^\d+$/.test(value)) value = toInt(value); else if (!isNumber(value = mom.localeData().monthsParse(value))) return mom;
        return dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)), mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth), 
        mom;
    }
    function getSetMonth(value) {
        return null != value ? (setMonth(this, value), hooks.updateOffset(this, !0), this) : get(this, "Month");
    }
    var defaultMonthsShortRegex = asWeeks;
    var defaultMonthsRegex = asWeeks;
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        for (var mom, shortPieces = [], longPieces = [], mixedPieces = [], i = 0; i < 12; i++) mom = createUTC([ 2e3, i ]), 
        shortPieces.push(this.monthsShort(mom, "")), longPieces.push(this.months(mom, "")), 
        mixedPieces.push(this.months(mom, "")), mixedPieces.push(this.monthsShort(mom, ""));
        for (shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), 
        i = 0; i < 12; i++) shortPieces[i] = regexEscape(shortPieces[i]), longPieces[i] = regexEscape(longPieces[i]);
        for (i = 0; i < 24; i++) mixedPieces[i] = regexEscape(mixedPieces[i]);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, 
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        return y < 100 && 0 <= y && isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y), 
        date;
    }
    function firstWeekOffset(year, dow, fwd) {
        fwd = 7 + dow - fwd;
        return fwd - (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7 - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, resDayOfYear) {
        var resYear, resDayOfYear = 1 + 7 * (week - 1) + (7 + weekday - dow) % 7 + firstWeekOffset(year, dow, resDayOfYear), resDayOfYear = resDayOfYear <= 0 ? daysInYear(resYear = year - 1) + resDayOfYear : resDayOfYear > daysInYear(year) ? (resYear = year + 1, 
        resDayOfYear - daysInYear(year)) : (resYear = year, resDayOfYear);
        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    function weekOfYear(mom, dow, doy) {
        var resWeek, resYear, week = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - week - 1) / 7) + 1;
        return week < 1 ? resWeek = week + weeksInYear(resYear = mom.year() - 1, dow, doy) : week > weeksInYear(mom.year(), dow, doy) ? (resWeek = week - weeksInYear(mom.year(), dow, doy), 
        resYear = mom.year() + 1) : (resYear = mom.year(), resWeek = week), {
            week: resWeek,
            year: resYear
        };
    }
    function weeksInYear(year, dow, weekOffsetNext) {
        var weekOffset = firstWeekOffset(year, dow, weekOffsetNext), weekOffsetNext = firstWeekOffset(year + 1, dow, weekOffsetNext);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", [ "ww", 2 ], "wo", "week"), addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek"), 
    addUnitAlias("week", "w"), addUnitAlias("isoWeek", "W"), addUnitPriority("week", 5), 
    addUnitPriority("isoWeek", 5), addRegexToken("w", match1to2), addRegexToken("ww", match1to2, asMinutes), 
    addRegexToken("W", match1to2), addRegexToken("WW", match1to2, asMinutes), addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    addFormatToken("d", 0, "do", "day"), addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    }), addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    }), addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    }), addFormatToken("e", 0, 0, "weekday"), addFormatToken("E", 0, 0, "isoWeekday"), 
    addUnitAlias("day", "d"), addUnitAlias("weekday", "e"), addUnitAlias("isoWeekday", "E"), 
    addUnitPriority("day", 11), addUnitPriority("weekday", 11), addUnitPriority("isoWeekday", 11), 
    addRegexToken("d", match1to2), addRegexToken("e", match1to2), addRegexToken("E", match1to2), 
    addRegexToken("dd", function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    }), addRegexToken("ddd", function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    }), addRegexToken("dddd", function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    }), addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config, weekday) {
        weekday = config._locale.weekdaysParse(input, weekday, config._strict);
        null != weekday ? week.d = weekday : getParsingFlags(config).invalidWeekday = input;
    }), addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    var minutes = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    var hours = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    var defaultWeekdaysRegex = asWeeks;
    var defaultWeekdaysShortRegex = asWeeks;
    var defaultWeekdaysMinRegex = asWeeks;
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        for (var minp, shortp, longp, minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i = 0; i < 7; i++) longp = createUTC([ 2e3, 1 ]).day(i), 
        minp = this.weekdaysMin(longp, ""), shortp = this.weekdaysShort(longp, ""), longp = this.weekdays(longp, ""), 
        minPieces.push(minp), shortPieces.push(shortp), longPieces.push(longp), mixedPieces.push(minp), 
        mixedPieces.push(shortp), mixedPieces.push(longp);
        for (minPieces.sort(cmpLenRev), shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), 
        mixedPieces.sort(cmpLenRev), i = 0; i < 7; i++) shortPieces[i] = regexEscape(shortPieces[i]), 
        longPieces[i] = regexEscape(longPieces[i]), mixedPieces[i] = regexEscape(mixedPieces[i]);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, 
        this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), 
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i"), 
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addFormatToken("H", [ "HH", 2 ], 0, "hour"), addFormatToken("h", [ "hh", 2 ], 0, hFormat), 
    addFormatToken("k", [ "kk", 2 ], 0, function() {
        return this.hours() || 24;
    }), addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    }), addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    }), addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
    }), addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    }), meridiem("a", !0), meridiem("A", !1), addUnitAlias("hour", "h"), addUnitPriority("hour", 13), 
    addRegexToken("a", matchMeridiem), addRegexToken("A", matchMeridiem), addRegexToken("H", match1to2), 
    addRegexToken("h", match1to2), addRegexToken("k", match1to2), addRegexToken("HH", match1to2, asMinutes), 
    addRegexToken("hh", match1to2, asMinutes), addRegexToken("kk", match1to2, asMinutes), 
    addRegexToken("hmm", milliseconds), addRegexToken("hmmss", lang), addRegexToken("Hmm", milliseconds), 
    addRegexToken("Hmmss", lang), addParseToken([ "H", "HH" ], HOUR), addParseToken([ "k", "kk" ], function(kInput, array, config) {
        kInput = toInt(kInput);
        array[HOUR] = 24 === kInput ? 0 : kInput;
    }), addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input), config._meridiem = input;
    }), addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input), getParsingFlags(config).bigHour = !0;
    }), addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos)), 
        getParsingFlags(config).bigHour = !0;
    }), addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
        array[SECOND] = toInt(input.substr(pos2)), getParsingFlags(config).bigHour = !0;
    }), addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos));
    }), addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
        array[SECOND] = toInt(input.substr(pos2));
    });
    var globalLocale, seconds = makeGetSet("Hours", !0), baseConfig = {
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY h:mm A",
            LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        invalidDate: "Invalid date",
        ordinal: "%d",
        dayOfMonthOrdinalParse: /\d{1,2}/,
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        months: months,
        monthsShort: defaultLocaleMonthsShort,
        week: {
            dow: 0,
            doy: 6
        },
        weekdays: minutes,
        weekdaysMin: hours,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: /[ap]\.?m?\.?/i
    }, locales = {}, localeFamilies = {};
    function normalizeLocale(key) {
        return key && key.toLowerCase().replace("_", "-");
    }
    function loadLocale(name) {
        if (!locales[name] && "undefined" != typeof module && module && module.exports) try {
            var oldLocale = globalLocale._abbr;
            require("./locale/" + name), getSetGlobalLocale(oldLocale);
        } catch (e) {}
        return locales[name];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        return (globalLocale = key && (data = void 0 === values ? getLocale(key) : defineLocale(key, values)) ? data : globalLocale)._abbr;
    }
    function defineLocale(name, config) {
        if (null === config) return delete locales[name], null;
        var parentConfig = baseConfig;
        if (config.abbr = name, null != locales[name]) deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), 
        parentConfig = locales[name]._config; else if (null != config.parentLocale) {
            if (null == locales[config.parentLocale]) return localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []), 
            localeFamilies[config.parentLocale].push({
                name: name,
                config: config
            }), null;
            parentConfig = locales[config.parentLocale]._config;
        }
        return locales[name] = new Locale(mergeConfigs(parentConfig, config)), localeFamilies[name] && localeFamilies[name].forEach(function(x) {
            defineLocale(x.name, x.config);
        }), getSetGlobalLocale(name), locales[name];
    }
    function getLocale(key) {
        var locale;
        if (!(key = key && key._locale && key._locale._abbr ? key._locale._abbr : key)) return globalLocale;
        if (!isArray(key)) {
            if (locale = loadLocale(key)) return locale;
            key = [ key ];
        }
        return function(names) {
            for (var j, next, locale, split, i = 0; i < names.length; ) {
                for (j = (split = normalizeLocale(names[i]).split("-")).length, next = (next = normalizeLocale(names[i + 1])) ? next.split("-") : null; 0 < j; ) {
                    if (locale = loadLocale(split.slice(0, j).join("-"))) return locale;
                    if (next && next.length >= j && compareArrays(split, next, !0) >= j - 1) break;
                    j--;
                }
                i++;
            }
            return null;
        }(key);
    }
    function checkOverflow(m) {
        var overflow = m._a;
        return overflow && -2 === getParsingFlags(m).overflow && (overflow = overflow[MONTH] < 0 || 11 < overflow[MONTH] ? MONTH : overflow[DATE] < 1 || overflow[DATE] > daysInMonth(overflow[YEAR], overflow[MONTH]) ? DATE : overflow[HOUR] < 0 || 24 < overflow[HOUR] || 24 === overflow[HOUR] && (0 !== overflow[MINUTE] || 0 !== overflow[SECOND] || 0 !== overflow[MILLISECOND]) ? HOUR : overflow[MINUTE] < 0 || 59 < overflow[MINUTE] ? MINUTE : overflow[SECOND] < 0 || 59 < overflow[SECOND] ? SECOND : overflow[MILLISECOND] < 0 || 999 < overflow[MILLISECOND] ? MILLISECOND : -1, 
        getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || DATE < overflow) && (overflow = DATE), 
        getParsingFlags(m)._overflowWeeks && -1 === overflow && (overflow = WEEK), getParsingFlags(m)._overflowWeekday && -1 === overflow && (overflow = WEEKDAY), 
        getParsingFlags(m).overflow = overflow), m;
    }
    function defaults(a, b, c) {
        return null != a ? a : null != b ? b : c;
    }
    function configFromArray(config) {
        var i, currentDate, date, input = [];
        if (!config._d) {
            for (currentDate = function(config) {
                var nowValue = new Date(hooks.now());
                return config._useUTC ? [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ] : [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
            }(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && function(config) {
                var w, weekYear, week, weekday, dow, temp, weekdayOverflow, curWeek;
                null != (w = config._w).GG || null != w.W || null != w.E ? (dow = 1, temp = 4, weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year), 
                week = defaults(w.W, 1), ((weekday = defaults(w.E, 1)) < 1 || 7 < weekday) && (weekdayOverflow = !0)) : (dow = config._locale._week.dow, 
                temp = config._locale._week.doy, curWeek = weekOfYear(createLocal(), dow, temp), 
                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year), week = defaults(w.w, curWeek.week), 
                null != w.d ? ((weekday = w.d) < 0 || 6 < weekday) && (weekdayOverflow = !0) : null != w.e ? (weekday = w.e + dow, 
                (w.e < 0 || 6 < w.e) && (weekdayOverflow = !0)) : weekday = dow), week < 1 || week > weeksInYear(weekYear, dow, temp) ? getParsingFlags(config)._overflowWeeks = !0 : null != weekdayOverflow ? getParsingFlags(config)._overflowWeekday = !0 : (temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, temp), 
                config._a[YEAR] = temp.year, config._dayOfYear = temp.dayOfYear);
            }(config), null != config._dayOfYear && (date = defaults(config._a[YEAR], currentDate[YEAR]), 
            (config._dayOfYear > daysInYear(date) || 0 === config._dayOfYear) && (getParsingFlags(config)._overflowDayOfYear = !0), 
            date = createUTCDate(date, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), 
            config._a[DATE] = date.getUTCDate()), i = 0; i < 3 && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
            for (;i < 7; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
            24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, 
            config._a[HOUR] = 0), config._d = (config._useUTC ? createUTCDate : function(y, m, d, h, M, s, date) {
                return date = new Date(y, m, d, h, M, s, date), y < 100 && 0 <= y && isFinite(date.getFullYear()) && date.setFullYear(y), 
                date;
            }).apply(null, input), null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), 
            config._nextDay && (config._a[HOUR] = 24), config._w && void 0 !== config._w.d && config._w.d !== config._d.getDay() && (getParsingFlags(config).weekdayMismatch = !0);
        }
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, !1 ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, !1 ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, !1 ], [ "YYYYDDD", /\d{7}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ], aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
        var i, l, allowTime, dateFormat, timeFormat, tzFormat, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string);
        if (match) {
            for (getParsingFlags(config).iso = !0, i = 0, l = isoDates.length; i < l; i++) if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0], allowTime = !1 !== isoDates[i][2];
                break;
            }
            if (null != dateFormat) {
                if (match[3]) {
                    for (i = 0, l = isoTimes.length; i < l; i++) if (isoTimes[i][1].exec(match[3])) {
                        timeFormat = (match[2] || " ") + isoTimes[i][0];
                        break;
                    }
                    if (null == timeFormat) return void (config._isValid = !1);
                }
                if (allowTime || null == timeFormat) {
                    if (match[4]) {
                        if (!tzRegex.exec(match[4])) return void (config._isValid = !1);
                        tzFormat = "Z";
                    }
                    config._f = dateFormat + (timeFormat || "") + (tzFormat || ""), configFromStringAndFormat(config);
                } else config._isValid = !1;
            } else config._isValid = !1;
        } else config._isValid = !1;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, result, secondStr) {
        result = [ function(year) {
            year = parseInt(year, 10);
            {
                if (year <= 49) return 2e3 + year;
                if (year <= 999) return 1900 + year;
            }
            return year;
        }(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(result, 10) ];
        return secondStr && result.push(parseInt(secondStr, 10)), result;
    }
    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -240,
        EST: -300,
        CDT: -300,
        CST: -360,
        MDT: -360,
        MST: -420,
        PDT: -420,
        PST: -480
    };
    function configFromRFC2822(config) {
        var obsOffset, hm, m = rfc2822.exec(config._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim());
        m ? (hm = extractFromRFC2822Strings(m[4], m[3], m[2], m[5], m[6], m[7]), function(weekdayStr, parsedInput, config) {
            return !weekdayStr || defaultLocaleWeekdaysShort.indexOf(weekdayStr) === new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay() || (getParsingFlags(config).weekdayMismatch = !0, 
            void (config._isValid = !1));
        }(m[1], hm, config) && (config._a = hm, config._tzm = (obsOffset = m[8], hm = m[9], 
        m = m[10], obsOffset ? obsOffsets[obsOffset] : hm ? 0 : 60 * (((hm = parseInt(m, 10)) - (m = hm % 100)) / 100) + m), 
        config._d = createUTCDate.apply(null, config._a), config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), 
        getParsingFlags(config).rfc2822 = !0)) : config._isValid = !1;
    }
    function configFromStringAndFormat(config) {
        if (config._f !== hooks.ISO_8601) if (config._f !== hooks.RFC_2822) {
            config._a = [], getParsingFlags(config).empty = !0;
            for (var parsedInput, token, skipped, string = "" + config._i, stringLength = string.length, totalParsedInputLength = 0, tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], i = 0; i < tokens.length; i++) token = tokens[i], 
            (parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]) && (0 < (skipped = string.substr(0, string.indexOf(parsedInput))).length && getParsingFlags(config).unusedInput.push(skipped), 
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), 
            formatTokenFunctions[token] ? (parsedInput ? getParsingFlags(config).empty = !1 : getParsingFlags(config).unusedTokens.push(token), 
            addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && getParsingFlags(config).unusedTokens.push(token);
            getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength, 0 < string.length && getParsingFlags(config).unusedInput.push(string), 
            config._a[HOUR] <= 12 && !0 === getParsingFlags(config).bigHour && 0 < config._a[HOUR] && (getParsingFlags(config).bigHour = void 0), 
            getParsingFlags(config).parsedDateParts = config._a.slice(0), getParsingFlags(config).meridiem = config._meridiem, 
            config._a[HOUR] = function(locale, hour, isPm) {
                if (null == isPm) return hour;
                return null != locale.meridiemHour ? locale.meridiemHour(hour, isPm) : null != locale.isPM ? ((isPm = locale.isPM(isPm)) && hour < 12 && (hour += 12), 
                hour = !isPm && 12 === hour ? 0 : hour) : hour;
            }(config._locale, config._a[HOUR], config._meridiem), configFromArray(config), checkOverflow(config);
        } else configFromRFC2822(config); else configFromISO(config);
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        return config._locale = config._locale || getLocale(config._l), null === input || void 0 === format && "" === input ? createInvalid({
            nullInput: !0
        }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), 
        isMoment(input) ? new Moment(checkOverflow(input)) : (isDate(input) ? config._d = input : (isArray(format) ? function(config) {
            var tempConfig, bestMoment, scoreToBeat, i, currentScore;
            if (0 === config._f.length) return getParsingFlags(config).invalidFormat = !0, config._d = new Date(NaN);
            for (i = 0; i < config._f.length; i++) currentScore = 0, tempConfig = copyConfig({}, config), 
            null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._f = config._f[i], 
            configFromStringAndFormat(tempConfig), isValid(tempConfig) && (currentScore += getParsingFlags(tempConfig).charsLeftOver, 
            currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length, getParsingFlags(tempConfig).score = currentScore, 
            (null == scoreToBeat || currentScore < scoreToBeat) && (scoreToBeat = currentScore, 
            bestMoment = tempConfig));
            extend(config, bestMoment || tempConfig);
        } : format ? configFromStringAndFormat : function(config) {
            var input = config._i;
            void 0 === input ? config._d = new Date(hooks.now()) : isDate(input) ? config._d = new Date(input.valueOf()) : "string" == typeof input ? function(config) {
                var matched = aspNetJsonRegex.exec(config._i);
                null === matched ? (configFromISO(config), !1 === config._isValid && (delete config._isValid, 
                configFromRFC2822(config), !1 === config._isValid && (delete config._isValid, hooks.createFromInputFallback(config)))) : config._d = new Date(+matched[1]);
            }(config) : isArray(input) ? (config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            }), configFromArray(config)) : isObject(input) ? function(config) {
                var i;
                config._d || (i = normalizeObjectUnits(config._i), config._a = map([ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ], function(obj) {
                    return obj && parseInt(obj, 10);
                }), configFromArray(config));
            }(config) : isNumber(input) ? config._d = new Date(input) : hooks.createFromInputFallback(config);
        })(config), isValid(config) || (config._d = null), config));
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var res = {};
        return !0 !== locale && !1 !== locale || (strict = locale, locale = void 0), (isObject(input) && function(obj) {
            if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(obj).length;
            for (var k in obj) if (obj.hasOwnProperty(k)) return;
            return 1;
        }(input) || isArray(input) && 0 === input.length) && (input = void 0), res._isAMomentObject = !0, 
        res._useUTC = res._isUTC = isUTC, res._l = locale, res._i = input, res._f = format, 
        res._strict = strict, (res = new Moment(checkOverflow(prepareConfig(res = res))))._nextDay && (res.add(1, "d"), 
        res._nextDay = void 0), res;
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, !1);
    }
    hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    }), hooks.ISO_8601 = function() {}, hooks.RFC_2822 = function() {};
    var asYears = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        return this.isValid() && other.isValid() ? other < this ? this : other : createInvalid();
    }), asMonths = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        return this.isValid() && other.isValid() ? this < other ? this : other : createInvalid();
    });
    function pickBy(fn, moments) {
        var res, i;
        if (!(moments = 1 === moments.length && isArray(moments[0]) ? moments[0] : moments).length) return createLocal();
        for (res = moments[0], i = 1; i < moments.length; ++i) moments[i].isValid() && !moments[i][fn](res) || (res = moments[i]);
        return res;
    }
    var ordering = [ "year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond" ];
    function Duration(milliseconds) {
        var normalizedInput = normalizeObjectUnits(milliseconds), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._isValid = function(m) {
            for (var key in m) if (-1 === indexOf.call(ordering, key) || null != m[key] && isNaN(m[key])) return !1;
            for (var unitHasDecimal = !1, i = 0; i < ordering.length; ++i) if (m[ordering[i]]) {
                if (unitHasDecimal) return !1;
                parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]]) && (unitHasDecimal = !0);
            }
            return !0;
        }(normalizedInput), this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60, 
        this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, 
        this._data = {}, this._locale = getLocale(), this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        return number < 0 ? -1 * Math.round(-1 * number) : Math.round(number);
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset(), sign = "+";
            return offset < 0 && (offset = -offset, sign = "-"), sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    offset("Z", ":"), offset("ZZ", ""), addRegexToken("Z", matchShortOffset), addRegexToken("ZZ", matchShortOffset), 
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = !0, config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(parts, minutes) {
        minutes = (minutes || "").match(parts);
        if (null === minutes) return null;
        parts = ((minutes[minutes.length - 1] || []) + "").match(chunkOffset) || [ "-", 0, 0 ], 
        minutes = 60 * parts[1] + toInt(parts[2]);
        return 0 === minutes ? 0 : "+" === parts[0] ? minutes : -minutes;
    }
    function cloneWithOffset(input, diff) {
        var res;
        return diff._isUTC ? (res = diff.clone(), diff = (isMoment(input) || isDate(input) ? input : createLocal(input)).valueOf() - res.valueOf(), 
        res._d.setTime(res._d.valueOf() + diff), hooks.updateOffset(res, !1), res) : createLocal(input).local();
    }
    function getDateOffset(m) {
        return 15 * -Math.round(m._d.getTimezoneOffset() / 15);
    }
    function isUtc() {
        return !!this.isValid() && (this._isUTC && 0 === this._offset);
    }
    hooks.updateOffset = function() {};
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
        var diffRes, ret = input, match = null;
        return isDuration(input) ? ret = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
        } : isNumber(input) ? (ret = {}, key ? ret[key] = input : ret.milliseconds = input) : (match = aspNetRegex.exec(input)) ? (diffRes = "-" === match[1] ? -1 : 1, 
        ret = {
            y: 0,
            d: toInt(match[DATE]) * diffRes,
            h: toInt(match[HOUR]) * diffRes,
            m: toInt(match[MINUTE]) * diffRes,
            s: toInt(match[SECOND]) * diffRes,
            ms: toInt(absRound(1e3 * match[MILLISECOND])) * diffRes
        }) : (match = isoRegex.exec(input)) ? (diffRes = "-" === match[1] ? -1 : (match[1], 
        1), ret = {
            y: parseIso(match[2], diffRes),
            M: parseIso(match[3], diffRes),
            w: parseIso(match[4], diffRes),
            d: parseIso(match[5], diffRes),
            h: parseIso(match[6], diffRes),
            m: parseIso(match[7], diffRes),
            s: parseIso(match[8], diffRes)
        }) : null == ret ? ret = {} : "object" == typeof ret && ("from" in ret || "to" in ret) && (diffRes = function(base, other) {
            var res;
            if (!base.isValid() || !other.isValid()) return {
                milliseconds: 0,
                months: 0
            };
            other = cloneWithOffset(other, base), base.isBefore(other) ? res = positiveMomentsDifference(base, other) : ((res = positiveMomentsDifference(other, base)).milliseconds = -res.milliseconds, 
            res.months = -res.months);
            return res;
        }(createLocal(ret.from), createLocal(ret.to)), (ret = {}).ms = diffRes.milliseconds, 
        ret.M = diffRes.months), ret = new Duration(ret), isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), 
        ret;
    }
    function parseIso(res, sign) {
        res = res && parseFloat(res.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), 
        base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), 
        res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var tmp;
            return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), 
            tmp = val, val = period, period = tmp), addSubtract(this, createDuration(val = "string" == typeof val ? +val : val, period), direction), 
            this;
        };
    }
    function addSubtract(mom, months, isAdding, updateOffset) {
        var milliseconds = months._milliseconds, days = absRound(months._days), months = absRound(months._months);
        mom.isValid() && (updateOffset = null == updateOffset || updateOffset, months && setMonth(mom, get(mom, "Month") + months * isAdding), 
        days && set$1(mom, "Date", get(mom, "Date") + days * isAdding), milliseconds && mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding), 
        updateOffset && hooks.updateOffset(mom, days || months));
    }
    createDuration.fn = Duration.prototype, createDuration.invalid = function() {
        return createDuration(NaN);
    };
    asWeeks = createAdder(1, "add"), milliseconds = createAdder(-1, "subtract");
    function monthDiff(a, b) {
        var wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()), adjust = a.clone().add(wholeMonthDiff, "months"), adjust = b - adjust < 0 ? (b - adjust) / (adjust - a.clone().add(wholeMonthDiff - 1, "months")) : (b - adjust) / (a.clone().add(1 + wholeMonthDiff, "months") - adjust);
        return -(wholeMonthDiff + adjust) || 0;
    }
    function locale(newLocaleData) {
        return void 0 === newLocaleData ? this._locale._abbr : (null != (newLocaleData = getLocale(newLocaleData)) && (this._locale = newLocaleData), 
        this);
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        return void 0 === key ? this.localeData() : this.locale(key);
    });
    function localeData() {
        return this._locale;
    }
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        return null == input ? weekOfYear(this, dow, doy).year : (weeksTarget = weeksInYear(input, dow, doy), 
        function(weekYear, week, weekday, dow, date) {
            date = dayOfYearFromWeeks(weekYear, week, weekday, dow, date), date = createUTCDate(date.year, 0, date.dayOfYear);
            return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), 
            this;
        }.call(this, input, week = weeksTarget < week ? weeksTarget : week, weekday, dow, doy));
    }
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    }), addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    }), addWeekYearFormatToken("gggg", "weekYear"), addWeekYearFormatToken("ggggg", "weekYear"), 
    addWeekYearFormatToken("GGGG", "isoWeekYear"), addWeekYearFormatToken("GGGGG", "isoWeekYear"), 
    addUnitAlias("weekYear", "gg"), addUnitAlias("isoWeekYear", "GG"), addUnitPriority("weekYear", 1), 
    addUnitPriority("isoWeekYear", 1), addRegexToken("G", matchSigned), addRegexToken("g", matchSigned), 
    addRegexToken("GG", match1to2, asMinutes), addRegexToken("gg", match1to2, asMinutes), 
    addRegexToken("GGGG", days, proto), addRegexToken("gggg", days, proto), addRegexToken("GGGGG", proto$2, asMilliseconds), 
    addRegexToken("ggggg", proto$2, asMilliseconds), addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    }), addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    }), addFormatToken("Q", 0, "Qo", "quarter"), addUnitAlias("quarter", "Q"), addUnitPriority("quarter", 7), 
    addRegexToken("Q", asSeconds), addParseToken("Q", function(input, array) {
        array[MONTH] = 3 * (toInt(input) - 1);
    }), addFormatToken("D", [ "DD", 2 ], "Do", "date"), addUnitAlias("date", "D"), addUnitPriority("date", 9), 
    addRegexToken("D", match1to2), addRegexToken("DD", match1to2, asMinutes), addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    }), addParseToken([ "D", "DD" ], DATE), addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });
    months = makeGetSet("Date", !0);
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear"), addUnitAlias("dayOfYear", "DDD"), 
    addUnitPriority("dayOfYear", 4), addRegexToken("DDD", asHours), addRegexToken("DDDD", asDays), 
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    }), addFormatToken("m", [ "mm", 2 ], 0, "minute"), addUnitAlias("minute", "m"), 
    addUnitPriority("minute", 14), addRegexToken("m", match1to2), addRegexToken("mm", match1to2, asMinutes), 
    addParseToken([ "m", "mm" ], MINUTE);
    minutes = makeGetSet("Minutes", !1);
    addFormatToken("s", [ "ss", 2 ], 0, "second"), addUnitAlias("second", "s"), addUnitPriority("second", 15), 
    addRegexToken("s", match1to2), addRegexToken("ss", match1to2, asMinutes), addParseToken([ "s", "ss" ], SECOND);
    var token, hours = makeGetSet("Seconds", !1);
    for (addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    }), addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    }), addFormatToken(0, [ "SSS", 3 ], 0, "millisecond"), addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return 10 * this.millisecond();
    }), addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return 100 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return 1e3 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return 1e4 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return 1e5 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return 1e6 * this.millisecond();
    }), addUnitAlias("millisecond", "ms"), addUnitPriority("millisecond", 16), addRegexToken("S", asHours, asSeconds), 
    addRegexToken("SS", asHours, asMinutes), addRegexToken("SSS", asHours, asDays), 
    token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(1e3 * ("0." + input));
    }
    for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);
    days = makeGetSet("Milliseconds", !1);
    addFormatToken("z", 0, 0, "zoneAbbr"), addFormatToken("zz", 0, 0, "zoneName");
    proto = Moment.prototype;
    function preParsePostFormat(string) {
        return string;
    }
    proto.add = asWeeks, proto.calendar = function(format, output) {
        var now = format || createLocal(), format = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, format) || "sameElse", output = output && (isFunction(output[format]) ? output[format].call(this, now) : output[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }, proto.clone = function() {
        return new Moment(this);
    }, proto.diff = function(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) return NaN;
        if (!(that = cloneWithOffset(input, this)).isValid()) return NaN;
        switch (zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset()), units = normalizeUnits(units)) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;

          case "month":
            output = monthDiff(this, that);
            break;

          case "quarter":
            output = monthDiff(this, that) / 3;
            break;

          case "second":
            output = (this - that) / 1e3;
            break;

          case "minute":
            output = (this - that) / 6e4;
            break;

          case "hour":
            output = (this - that) / 36e5;
            break;

          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;

          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;

          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
    }, proto.endOf = function(units) {
        return void 0 === (units = normalizeUnits(units)) || "millisecond" === units ? this : ("date" === units && (units = "day"), 
        this.startOf(units).add(1, "isoWeek" === units ? "week" : units).subtract(1, "ms"));
    }, proto.format = function(output) {
        return output = output || (this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat), 
        output = formatMoment(this, output), this.localeData().postformat(output);
    }, proto.from = function(time, withoutSuffix) {
        return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
            to: this,
            from: time
        }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }, proto.fromNow = function(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }, proto.to = function(time, withoutSuffix) {
        return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
            from: this,
            to: time
        }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }, proto.toNow = function(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }, proto.get = function(units) {
        return isFunction(this[units = normalizeUnits(units)]) ? this[units]() : this;
    }, proto.invalidAt = function() {
        return getParsingFlags(this).overflow;
    }, proto.isAfter = function(localInput, units) {
        return localInput = isMoment(localInput) ? localInput : createLocal(localInput), 
        !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(void 0 !== units ? units : "millisecond")) ? this.valueOf() > localInput.valueOf() : localInput.valueOf() < this.clone().startOf(units).valueOf());
    }, proto.isBefore = function(localInput, units) {
        return localInput = isMoment(localInput) ? localInput : createLocal(localInput), 
        !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(void 0 !== units ? units : "millisecond")) ? this.valueOf() < localInput.valueOf() : this.clone().endOf(units).valueOf() < localInput.valueOf());
    }, proto.isBetween = function(from, to, units, inclusivity) {
        return ("(" === (inclusivity = inclusivity || "()")[0] ? this.isAfter(from, units) : !this.isBefore(from, units)) && (")" === inclusivity[1] ? this.isBefore(to, units) : !this.isAfter(to, units));
    }, proto.isSame = function(inputMs, units) {
        return inputMs = isMoment(inputMs) ? inputMs : createLocal(inputMs), !(!this.isValid() || !inputMs.isValid()) && ("millisecond" === (units = normalizeUnits(units || "millisecond")) ? this.valueOf() === inputMs.valueOf() : (inputMs = inputMs.valueOf(), 
        this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf()));
    }, proto.isSameOrAfter = function(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }, proto.isSameOrBefore = function(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }, proto.isValid = function() {
        return isValid(this);
    }, proto.lang = lang, proto.locale = locale, proto.localeData = localeData, proto.max = asMonths, 
    proto.min = asYears, proto.parsingFlags = function() {
        return extend({}, getParsingFlags(this));
    }, proto.set = function(units, value) {
        if ("object" == typeof units) for (var prioritized = function(unitsObj) {
            var u, units = [];
            for (u in unitsObj) units.push({
                unit: u,
                priority: priorities[u]
            });
            return units.sort(function(a, b) {
                return a.priority - b.priority;
            }), units;
        }(units = normalizeObjectUnits(units)), i = 0; i < prioritized.length; i++) this[prioritized[i].unit](units[prioritized[i].unit]); else if (isFunction(this[units = normalizeUnits(units)])) return this[units](value);
        return this;
    }, proto.startOf = function(units) {
        switch (units = normalizeUnits(units)) {
          case "year":
            this.month(0);

          case "quarter":
          case "month":
            this.date(1);

          case "week":
          case "isoWeek":
          case "day":
          case "date":
            this.hours(0);

          case "hour":
            this.minutes(0);

          case "minute":
            this.seconds(0);

          case "second":
            this.milliseconds(0);
        }
        return "week" === units && this.weekday(0), "isoWeek" === units && this.isoWeekday(1), 
        "quarter" === units && this.month(3 * Math.floor(this.month() / 3)), this;
    }, proto.subtract = milliseconds, proto.toArray = function() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }, proto.toObject = function() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }, proto.toDate = function() {
        return new Date(this.valueOf());
    }, proto.toISOString = function() {
        if (!this.isValid()) return null;
        var m = this.clone().utc();
        return m.year() < 0 || 9999 < m.year() ? formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : isFunction(Date.prototype.toISOString) ? this.toDate().toISOString() : formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
    }, proto.inspect = function() {
        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
        var year = "moment", suffix = "";
        this.isLocal() || (year = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", 
        suffix = "Z");
        var prefix = "[" + year + '("]', year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", suffix = suffix + '[")]';
        return this.format(prefix + year + "-MM-DD[T]HH:mm:ss.SSS" + suffix);
    }, proto.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
    }, proto.toString = function() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }, proto.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
    }, proto.valueOf = function() {
        return this._d.valueOf() - 6e4 * (this._offset || 0);
    }, proto.creationData = function() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }, proto.year = years, proto.isLeapYear = function() {
        return isLeapYear(this.year());
    }, proto.weekYear = function(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }, proto.isoWeekYear = function(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }, proto.quarter = proto.quarters = function(input) {
        return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3);
    }, proto.month = getSetMonth, proto.daysInMonth = function() {
        return daysInMonth(this.year(), this.month());
    }, proto.week = proto.weeks = function(input) {
        var week = this.localeData().week(this);
        return null == input ? week : this.add(7 * (input - week), "d");
    }, proto.isoWeek = proto.isoWeeks = function(input) {
        var week = weekOfYear(this, 1, 4).week;
        return null == input ? week : this.add(7 * (input - week), "d");
    }, proto.weeksInYear = function() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }, proto.isoWeeksInYear = function() {
        return weeksInYear(this.year(), 1, 4);
    }, proto.date = months, proto.day = proto.days = function(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        return null != input ? (input = function(input, locale) {
            return "string" != typeof input ? input : isNaN(input) ? "number" == typeof (input = locale.weekdaysParse(input)) ? input : null : parseInt(input, 10);
        }(input, this.localeData()), this.add(input - day, "d")) : day;
    }, proto.weekday = function(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return null == input ? weekday : this.add(input - weekday, "d");
    }, proto.isoWeekday = function(weekday) {
        return this.isValid() ? null == weekday ? this.day() || 7 : (weekday = function(input, locale) {
            return "string" == typeof input ? locale.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input;
        }(weekday, this.localeData()), this.day(this.day() % 7 ? weekday : weekday - 7)) : null != weekday ? this : NaN;
    }, proto.dayOfYear = function(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return null == input ? dayOfYear : this.add(input - dayOfYear, "d");
    }, proto.hour = proto.hours = seconds, proto.minute = proto.minutes = minutes, proto.second = proto.seconds = hours, 
    proto.millisecond = proto.milliseconds = days, proto.utcOffset = function(input, keepLocalTime, keepMinutes) {
        var localAdjust, offset = this._offset || 0;
        if (!this.isValid()) return null != input ? this : NaN;
        if (null == input) return this._isUTC ? offset : getDateOffset(this);
        if ("string" == typeof input) {
            if (null === (input = offsetFromString(matchShortOffset, input))) return this;
        } else Math.abs(input) < 16 && !keepMinutes && (input *= 60);
        return !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)), this._offset = input, 
        this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addSubtract(this, createDuration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, 
        hooks.updateOffset(this, !0), this._changeInProgress = null)), this;
    }, proto.utc = function(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }, proto.local = function(keepLocalTime) {
        return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(getDateOffset(this), "m")), 
        this;
    }, proto.parseZone = function() {
        var tZone;
        return null != this._tzm ? this.utcOffset(this._tzm, !1, !0) : "string" == typeof this._i && (null != (tZone = offsetFromString(matchOffset, this._i)) ? this.utcOffset(tZone) : this.utcOffset(0, !0)), 
        this;
    }, proto.hasAlignedHourOffset = function(input) {
        return !!this.isValid() && (input = input ? createLocal(input).utcOffset() : 0, 
        (this.utcOffset() - input) % 60 == 0);
    }, proto.isDST = function() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }, proto.isLocal = function() {
        return !!this.isValid() && !this._isUTC;
    }, proto.isUtcOffset = function() {
        return !!this.isValid() && this._isUTC;
    }, proto.isUtc = isUtc, proto.isUTC = isUtc, proto.zoneAbbr = function() {
        return this._isUTC ? "UTC" : "";
    }, proto.zoneName = function() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }, proto.dates = deprecate("dates accessor is deprecated. Use date instead.", months), 
    proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth), 
    proto.years = deprecate("years accessor is deprecated. Use year instead", years), 
    proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(input, keepLocalTime) {
        return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), 
        this) : -this.utcOffset();
    }), proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
        if (void 0 !== this._isDSTShifted) return this._isDSTShifted;
        var other, c = {};
        return copyConfig(c, this), (c = prepareConfig(c))._a ? (other = (c._isUTC ? createUTC : createLocal)(c._a), 
        this._isDSTShifted = this.isValid() && 0 < compareArrays(c._a, other.toArray())) : this._isDSTShifted = !1, 
        this._isDSTShifted;
    });
    proto$2 = Locale.prototype;
    function get$1(format, utc, field, setter) {
        var locale = getLocale(), utc = createUTC().set(setter, utc);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format) && (index = format, format = void 0), format = format || "", 
        null != index) return get$1(format, index, field, "month");
        for (var out = [], i = 0; i < 12; i++) out[i] = get$1(format, i, field, "month");
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        format = ("boolean" == typeof localeSorted ? isNumber(format) && (index = format, 
        format = void 0) : (format = localeSorted, localeSorted = !1, isNumber(index = format) && (index = format, 
        format = void 0)), format || "");
        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0;
        if (null != index) return get$1(format, (index + shift) % 7, field, "day");
        for (var out = [], i = 0; i < 7; i++) out[i] = get$1(format, (i + shift) % 7, field, "day");
        return out;
    }
    proto$2.calendar = function(output, mom, now) {
        return isFunction(output = this._calendar[output] || this._calendar.sameElse) ? output.call(mom, now) : output;
    }, proto$2.longDateFormat = function(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        return format || !formatUpper ? format : (this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        }), this._longDateFormat[key]);
    }, proto$2.invalidDate = function() {
        return this._invalidDate;
    }, proto$2.ordinal = function(number) {
        return this._ordinal.replace("%d", number);
    }, proto$2.preparse = preParsePostFormat, proto$2.postformat = preParsePostFormat, 
    proto$2.relativeTime = function(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }, proto$2.pastFuture = function(format, output) {
        return isFunction(format = this._relativeTime[0 < format ? "future" : "past"]) ? format(output) : format.replace(/%s/i, output);
    }, proto$2.set = function(config) {
        var prop, i;
        for (i in config) isFunction(prop = config[i]) ? this[i] = prop : this["_" + i] = prop;
        this._config = config, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }, proto$2.months = function(m, format) {
        return m ? (isArray(this._months) ? this._months : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"])[m.month()] : isArray(this._months) ? this._months : this._months.standalone;
    }, proto$2.monthsShort = function(m, format) {
        return m ? (isArray(this._monthsShort) ? this._monthsShort : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"])[m.month()] : isArray(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
    }, proto$2.monthsParse = function(monthName, format, strict) {
        var i, regex;
        if (this._monthsParseExact) return function(llc, format, strict) {
            var i, ii, mom, llc = llc.toLocaleLowerCase();
            if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], 
            this._shortMonthsParse = [], i = 0; i < 12; ++i) mom = createUTC([ 2e3, i ]), this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase(), 
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            return strict ? "MMM" === format ? -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) ? ii : null : "MMM" === format ? -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) || -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) || -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) ? ii : null;
        }.call(this, monthName, format, strict);
        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), 
        i = 0; i < 12; i++) {
            if (regex = createUTC([ 2e3, i ]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(regex, "").replace(".", "") + "$", "i"), 
            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(regex, "").replace(".", "") + "$", "i")), 
            strict || this._monthsParse[i] || (regex = "^" + this.months(regex, "") + "|^" + this.monthsShort(regex, ""), 
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i;
            if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i;
            if (!strict && this._monthsParse[i].test(monthName)) return i;
        }
    }, proto$2.monthsRegex = function(isStrict) {
        return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
        isStrict ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), 
        this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex);
    }, proto$2.monthsShortRegex = function(isStrict) {
        return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
        isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), 
        this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }, proto$2.week = function(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }, proto$2.firstDayOfYear = function() {
        return this._week.doy;
    }, proto$2.firstDayOfWeek = function() {
        return this._week.dow;
    }, proto$2.weekdays = function(m, format) {
        return m ? (isArray(this._weekdays) ? this._weekdays : this._weekdays[this._weekdays.isFormat.test(format) ? "format" : "standalone"])[m.day()] : isArray(this._weekdays) ? this._weekdays : this._weekdays.standalone;
    }, proto$2.weekdaysMin = function(m) {
        return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }, proto$2.weekdaysShort = function(m) {
        return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }, proto$2.weekdaysParse = function(weekdayName, format, strict) {
        var i, regex;
        if (this._weekdaysParseExact) return function(llc, format, strict) {
            var i, ii, mom, llc = llc.toLocaleLowerCase();
            if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], 
            this._minWeekdaysParse = [], i = 0; i < 7; ++i) mom = createUTC([ 2e3, 1 ]).day(i), 
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase(), 
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            return strict ? "dddd" === format ? -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) ? ii : null : "ddd" === format ? -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : "dddd" === format ? -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : "ddd" === format ? -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) ? ii : null;
        }.call(this, weekdayName, format, strict);
        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], 
        this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
            if (regex = createUTC([ 2e3, 1 ]).day(i), strict && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(regex, "").replace(".", ".?") + "$", "i"), 
            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(regex, "").replace(".", ".?") + "$", "i"), 
            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(regex, "").replace(".", ".?") + "$", "i")), 
            this._weekdaysParse[i] || (regex = "^" + this.weekdays(regex, "") + "|^" + this.weekdaysShort(regex, "") + "|^" + this.weekdaysMin(regex, ""), 
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "dddd" === format && this._fullWeekdaysParse[i].test(weekdayName)) return i;
            if (strict && "ddd" === format && this._shortWeekdaysParse[i].test(weekdayName)) return i;
            if (strict && "dd" === format && this._minWeekdaysParse[i].test(weekdayName)) return i;
            if (!strict && this._weekdaysParse[i].test(weekdayName)) return i;
        }
    }, proto$2.weekdaysRegex = function(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), 
        this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }, proto$2.weekdaysShortRegex = function(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), 
        this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }, proto$2.weekdaysMinRegex = function(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), 
        this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }, proto$2.isPM = function(input) {
        return "p" === (input + "").toLowerCase().charAt(0);
    }, proto$2.meridiem = function(hours, minutes, isLower) {
        return 11 < hours ? isLower ? "pm" : "PM" : isLower ? "am" : "AM";
    }, getSetGlobalLocale("en", {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 === toInt(number % 100 / 10) ? "th" : 1 == b ? "st" : 2 == b ? "nd" : 3 == b ? "rd" : "th");
        }
    }), hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale), 
    hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
    var mathAbs = Math.abs;
    function addSubtract$1(duration, input, other, direction) {
        other = createDuration(input, other);
        return duration._milliseconds += direction * other._milliseconds, duration._days += direction * other._days, 
        duration._months += direction * other._months, duration._bubble();
    }
    function absCeil(number) {
        return number < 0 ? Math.floor(number) : Math.ceil(number);
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), 
    asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), 
    asYears = makeAs("y");
    function makeGetter(name) {
        return function() {
            return this.isValid() ? this._data[name] : NaN;
        };
    }
    milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), 
    hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), 
    years = makeGetter("years");
    var round = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    };
    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var a = createDuration(posNegDuration).abs(), seconds = round(a.as("s")), minutes = round(a.as("m")), hours = round(a.as("h")), days = round(a.as("d")), months = round(a.as("M")), a = round(a.as("y")), a = (seconds <= thresholds.ss ? [ "s", seconds ] : seconds < thresholds.s && [ "ss", seconds ]) || minutes <= 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours <= 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days <= 1 && [ "d" ] || days < thresholds.d && [ "dd", days ] || months <= 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || a <= 1 && [ "y" ] || [ "yy", a ];
        return a[2] = withoutSuffix, a[3] = 0 < +posNegDuration, a[4] = locale, function(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }.apply(null, a);
    }
    var abs$1 = Math.abs;
    function sign(x) {
        return (0 < x) - (x < 0) || +x;
    }
    function toISOString$1() {
        if (!this.isValid()) return this.localeData().invalidDate();
        var daysSign = abs$1(this._milliseconds) / 1e3, hmsSign = abs$1(this._days), s = abs$1(this._months), ymSign = absFloor(daysSign / 60), totalSign = absFloor(ymSign / 60);
        daysSign %= 60, ymSign %= 60;
        var Y = absFloor(s / 12), M = s %= 12, D = hmsSign, h = totalSign, m = ymSign, s = daysSign ? daysSign.toFixed(3).replace(/\.?0+$/, "") : "", hmsSign = this.asSeconds();
        if (!hmsSign) return "P0D";
        totalSign = hmsSign < 0 ? "-" : "", ymSign = sign(this._months) !== sign(hmsSign) ? "-" : "", 
        daysSign = sign(this._days) !== sign(hmsSign) ? "-" : "", hmsSign = sign(this._milliseconds) !== sign(hmsSign) ? "-" : "";
        return totalSign + "P" + (Y ? ymSign + Y + "Y" : "") + (M ? ymSign + M + "M" : "") + (D ? daysSign + D + "D" : "") + (h || m || s ? "T" : "") + (h ? hmsSign + h + "H" : "") + (m ? hmsSign + m + "M" : "") + (s ? hmsSign + s + "S" : "");
    }
    proto$2 = Duration.prototype;
    return proto$2.isValid = function() {
        return this._isValid;
    }, proto$2.abs = function() {
        var data = this._data;
        return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), 
        this._months = mathAbs(this._months), data.milliseconds = mathAbs(data.milliseconds), 
        data.seconds = mathAbs(data.seconds), data.minutes = mathAbs(data.minutes), data.hours = mathAbs(data.hours), 
        data.months = mathAbs(data.months), data.years = mathAbs(data.years), this;
    }, proto$2.add = function(input, value) {
        return addSubtract$1(this, input, value, 1);
    }, proto$2.subtract = function(input, value) {
        return addSubtract$1(this, input, value, -1);
    }, proto$2.as = function(units) {
        if (!this.isValid()) return NaN;
        var days, months, milliseconds = this._milliseconds;
        if ("month" === (units = normalizeUnits(units)) || "year" === units) return days = this._days + milliseconds / 864e5, 
        months = this._months + 4800 * days / 146097, "month" === units ? months : months / 12;
        switch (days = this._days + Math.round(146097 * this._months / 4800), units) {
          case "week":
            return days / 7 + milliseconds / 6048e5;

          case "day":
            return days + milliseconds / 864e5;

          case "hour":
            return 24 * days + milliseconds / 36e5;

          case "minute":
            return 1440 * days + milliseconds / 6e4;

          case "second":
            return 86400 * days + milliseconds / 1e3;

          case "millisecond":
            return Math.floor(864e5 * days) + milliseconds;

          default:
            throw new Error("Unknown unit " + units);
        }
    }, proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, proto$2.asMinutes = asMinutes, 
    proto$2.asHours = asHours, proto$2.asDays = asDays, proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, 
    proto$2.asYears = asYears, proto$2.valueOf = function() {
        return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12) : NaN;
    }, proto$2._bubble = function() {
        var years = this._milliseconds, days = this._days, months = this._months, data = this._data;
        return 0 <= years && 0 <= days && 0 <= months || years <= 0 && days <= 0 && months <= 0 || (years += 864e5 * absCeil(146097 * months / 4800 + days), 
        months = days = 0), data.milliseconds = years % 1e3, years = absFloor(years / 1e3), 
        data.seconds = years % 60, years = absFloor(years / 60), data.minutes = years % 60, 
        years = absFloor(years / 60), data.hours = years % 24, days += absFloor(years / 24), 
        months += years = absFloor(4800 * days / 146097), days -= absCeil(146097 * years / 4800), 
        years = absFloor(months / 12), months %= 12, data.days = days, data.months = months, 
        data.years = years, this;
    }, proto$2.clone = function() {
        return createDuration(this);
    }, proto$2.get = function(units) {
        return units = normalizeUnits(units), this.isValid() ? this[units + "s"]() : NaN;
    }, proto$2.milliseconds = milliseconds, proto$2.seconds = seconds, proto$2.minutes = minutes, 
    proto$2.hours = hours, proto$2.days = days, proto$2.weeks = function() {
        return absFloor(this.days() / 7);
    }, proto$2.months = months, proto$2.years = years, proto$2.humanize = function(withSuffix) {
        if (!this.isValid()) return this.localeData().invalidDate();
        var locale = this.localeData(), output = relativeTime$1(this, !withSuffix, locale);
        return withSuffix && (output = locale.pastFuture(+this, output)), locale.postformat(output);
    }, proto$2.toISOString = toISOString$1, proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, 
    proto$2.locale = locale, proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), 
    proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), 
    addRegexToken("x", matchSigned), addRegexToken("X", /[+-]?\d+(\.\d{1,3})?/), addParseToken("X", function(input, array, config) {
        config._d = new Date(1e3 * parseFloat(input, 10));
    }), addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    }), hooks.version = "2.19.3", hookCallback = createLocal, hooks.fn = proto, hooks.min = function() {
        return pickBy("isBefore", [].slice.call(arguments, 0));
    }, hooks.max = function() {
        return pickBy("isAfter", [].slice.call(arguments, 0));
    }, hooks.now = function() {
        return Date.now ? Date.now() : +new Date();
    }, hooks.utc = createUTC, hooks.unix = function(input) {
        return createLocal(1e3 * input);
    }, hooks.months = function(format, index) {
        return listMonthsImpl(format, index, "months");
    }, hooks.isDate = isDate, hooks.locale = getSetGlobalLocale, hooks.invalid = createInvalid, 
    hooks.duration = createDuration, hooks.isMoment = isMoment, hooks.weekdays = function(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdays");
    }, hooks.parseZone = function() {
        return createLocal.apply(null, arguments).parseZone();
    }, hooks.localeData = getLocale, hooks.isDuration = isDuration, hooks.monthsShort = function(format, index) {
        return listMonthsImpl(format, index, "monthsShort");
    }, hooks.weekdaysMin = function(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
    }, hooks.defineLocale = defineLocale, hooks.updateLocale = function(name, locale) {
        var parentConfig, tmpLocale;
        return null != locale ? (parentConfig = baseConfig, (locale = new Locale(locale = mergeConfigs(parentConfig = null != (tmpLocale = loadLocale(name)) ? tmpLocale._config : parentConfig, locale))).parentLocale = locales[name], 
        locales[name] = locale, getSetGlobalLocale(name)) : null != locales[name] && (null != locales[name].parentLocale ? locales[name] = locales[name].parentLocale : null != locales[name] && delete locales[name]), 
        locales[name];
    }, hooks.locales = function() {
        return keys(locales);
    }, hooks.weekdaysShort = function(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
    }, hooks.normalizeUnits = normalizeUnits, hooks.relativeTimeRounding = function(roundingFunction) {
        return void 0 === roundingFunction ? round : "function" == typeof roundingFunction && (round = roundingFunction, 
        !0);
    }, hooks.relativeTimeThreshold = function(threshold, limit) {
        return void 0 !== thresholds[threshold] && (void 0 === limit ? thresholds[threshold] : (thresholds[threshold] = limit, 
        "s" === threshold && (thresholds.ss = limit - 1), !0));
    }, hooks.calendarFormat = function(myMoment, diff) {
        return (diff = myMoment.diff(diff, "days", !0)) < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
    }, hooks.prototype = proto, hooks;
}), function() {
    "use strict";
    function isUndefinedOrNull(val) {
        return angular.isUndefined(val) || null === val;
    }
    function angularMoment(angular, moment) {
        if (void 0 === moment) {
            if ("function" != typeof require) throw new Error("Moment cannot be found by angular-moment! Please reference to: https://github.com/urish/angular-moment");
            moment = function() {
                try {
                    return require("moment");
                } catch (e) {
                    throw new Error("Please install moment via npm. Please reference to: https://github.com/urish/angular-moment");
                }
            }();
        }
        return angular.module("angularMoment", []).constant("angularMomentConfig", {
            preprocess: null,
            timezone: null,
            format: null,
            statefulFilters: !0
        }).constant("moment", moment).constant("amTimeAgoConfig", {
            withoutSuffix: !1,
            serverTime: null,
            titleFormat: null,
            fullDateThreshold: null,
            fullDateFormat: null,
            fullDateThresholdUnit: "day"
        }).directive("amTimeAgo", [ "$window", "moment", "amMoment", "amTimeAgoConfig", function($window, moment, amMoment, amTimeAgoConfig) {
            return function(scope, element, attr) {
                var currentValue, currentFrom, activeTimeout = null, withoutSuffix = amTimeAgoConfig.withoutSuffix, titleFormat = amTimeAgoConfig.titleFormat, fullDateThreshold = amTimeAgoConfig.fullDateThreshold, fullDateFormat = amTimeAgoConfig.fullDateFormat, fullDateThresholdUnit = amTimeAgoConfig.fullDateThresholdUnit, localDate = new Date().getTime(), modelName = attr.amTimeAgo, isTimeElement = "TIME" === element[0].nodeName.toUpperCase(), setTitleTime = !element.attr("title");
                function getNow() {
                    var nowMillis;
                    return currentFrom || (amTimeAgoConfig.serverTime ? (nowMillis = new Date().getTime() - localDate + amTimeAgoConfig.serverTime, 
                    moment(nowMillis)) : moment());
                }
                function cancelTimer() {
                    activeTimeout && ($window.clearTimeout(activeTimeout), activeTimeout = null);
                }
                function updateDateTimeAttr(value) {
                    isTimeElement && element.attr("datetime", value);
                }
                function updateMoment() {
                    var momentValue;
                    cancelTimer(), currentValue && (function updateTime(momentInstance) {
                        var secondsUntilUpdate = getNow().diff(momentInstance, fullDateThresholdUnit), howOld = fullDateThreshold && fullDateThreshold <= secondsUntilUpdate;
                        howOld ? element.text(momentInstance.format(fullDateFormat)) : element.text(momentInstance.from(getNow(), withoutSuffix)), 
                        titleFormat && setTitleTime && element.attr("title", momentInstance.format(titleFormat)), 
                        howOld || (secondsUntilUpdate = 3600, (howOld = Math.abs(getNow().diff(momentInstance, "minute"))) < 1 ? secondsUntilUpdate = 1 : howOld < 60 ? secondsUntilUpdate = 30 : howOld < 180 && (secondsUntilUpdate = 300), 
                        activeTimeout = $window.setTimeout(function() {
                            updateTime(momentInstance);
                        }, 1e3 * secondsUntilUpdate));
                    }(momentValue = amMoment.preprocessDate(currentValue)), updateDateTimeAttr(momentValue.toISOString()));
                }
                scope.$watch(modelName, function(value) {
                    return isUndefinedOrNull(value) || "" === value ? (cancelTimer(), void (currentValue && (element.text(""), 
                    updateDateTimeAttr(""), currentValue = null))) : (currentValue = value, void updateMoment());
                }), angular.isDefined(attr.amFrom) && scope.$watch(attr.amFrom, function(value) {
                    currentFrom = isUndefinedOrNull(value) || "" === value ? null : moment(value), updateMoment();
                }), angular.isDefined(attr.amWithoutSuffix) && scope.$watch(attr.amWithoutSuffix, function(value) {
                    "boolean" == typeof value ? (withoutSuffix = value, updateMoment()) : withoutSuffix = amTimeAgoConfig.withoutSuffix;
                }), attr.$observe("amFullDateThreshold", function(newValue) {
                    fullDateThreshold = newValue, updateMoment();
                }), attr.$observe("amFullDateFormat", function(newValue) {
                    fullDateFormat = newValue, updateMoment();
                }), attr.$observe("amFullDateThresholdUnit", function(newValue) {
                    fullDateThresholdUnit = newValue, updateMoment();
                }), scope.$on("$destroy", function() {
                    cancelTimer();
                }), scope.$on("amMoment:localeChanged", function() {
                    updateMoment();
                });
            };
        } ]).service("amMoment", [ "moment", "$rootScope", "$log", "angularMomentConfig", function(moment, $rootScope, $log, angularMomentConfig) {
            var defaultTimezone = null;
            this.changeLocale = function(locale, result) {
                result = moment.locale(locale, result);
                return angular.isDefined(locale) && $rootScope.$broadcast("amMoment:localeChanged"), 
                result;
            }, this.changeTimezone = function(timezone) {
                moment.tz && moment.tz.setDefault ? (moment.tz.setDefault(timezone), $rootScope.$broadcast("amMoment:timezoneChanged")) : $log.warn("angular-moment: changeTimezone() works only with moment-timezone.js v0.3.0 or greater."), 
                angularMomentConfig.timezone = timezone, defaultTimezone = timezone;
            }, this.preprocessDate = function(value) {
                return defaultTimezone !== angularMomentConfig.timezone && this.changeTimezone(angularMomentConfig.timezone), 
                angularMomentConfig.preprocess ? angularMomentConfig.preprocess(value) : !isNaN(parseFloat(value)) && isFinite(value) ? moment(parseInt(value, 10)) : moment(value);
            };
        } ]).filter("amParse", [ "moment", function(moment) {
            return function(value, format) {
                return moment(value, format);
            };
        } ]).filter("amFromUnix", [ "moment", function(moment) {
            return function(value) {
                return moment.unix(value);
            };
        } ]).filter("amUtc", [ "moment", function(moment) {
            return function(value) {
                return moment.utc(value);
            };
        } ]).filter("amUtcOffset", [ "amMoment", function(amMoment) {
            return function(value, offset) {
                return amMoment.preprocessDate(value).utcOffset(offset);
            };
        } ]).filter("amLocal", [ "moment", function(moment) {
            return function(value) {
                return moment.isMoment(value) ? value.local() : null;
            };
        } ]).filter("amTimezone", [ "amMoment", "angularMomentConfig", "$log", function(amMoment, angularMomentConfig, $log) {
            return function(aMoment, timezone) {
                return aMoment = amMoment.preprocessDate(aMoment), timezone ? aMoment.tz ? aMoment.tz(timezone) : ($log.warn("angular-moment: named timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js ?"), 
                aMoment) : aMoment;
            };
        } ]).filter("amCalendar", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amCalendarFilter(date, referenceTime, formats) {
                if (isUndefinedOrNull(date)) return "";
                date = amMoment.preprocessDate(date);
                return date.isValid() ? date.calendar(referenceTime, formats) : "";
            }
            return amCalendarFilter.$stateful = angularMomentConfig.statefulFilters, amCalendarFilter;
        } ]).filter("amDifference", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDifferenceFilter(date, date2, unit, usePrecision) {
                if (isUndefinedOrNull(date)) return "";
                date = amMoment.preprocessDate(date), date2 = isUndefinedOrNull(date2) ? moment() : amMoment.preprocessDate(date2);
                return date.isValid() && date2.isValid() ? date.diff(date2, unit, usePrecision) : "";
            }
            return amDifferenceFilter.$stateful = angularMomentConfig.statefulFilters, amDifferenceFilter;
        } ]).filter("amDateFormat", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDateFormatFilter(date, format) {
                if (isUndefinedOrNull(date)) return "";
                date = amMoment.preprocessDate(date);
                return date.isValid() ? date.format(format) : "";
            }
            return amDateFormatFilter.$stateful = angularMomentConfig.statefulFilters, amDateFormatFilter;
        } ]).filter("amDurationFormat", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amDurationFormatFilter(value, format, suffix) {
                return isUndefinedOrNull(value) ? "" : moment.duration(value, format).humanize(suffix);
            }
            return amDurationFormatFilter.$stateful = angularMomentConfig.statefulFilters, amDurationFormatFilter;
        } ]).filter("amTimeAgo", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amTimeAgoFilter(dateFrom, suffix, from) {
                var date;
                return isUndefinedOrNull(dateFrom) ? "" : (dateFrom = amMoment.preprocessDate(dateFrom), 
                (date = moment(dateFrom)).isValid() ? (dateFrom = moment(from), !isUndefinedOrNull(from) && dateFrom.isValid() ? date.from(dateFrom, suffix) : date.fromNow(suffix)) : "");
            }
            return amTimeAgoFilter.$stateful = angularMomentConfig.statefulFilters, amTimeAgoFilter;
        } ]).filter("amSubtract", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amSubtractFilter(value, amount, type) {
                return isUndefinedOrNull(value) ? "" : moment(value).subtract(parseInt(amount, 10), type);
            }
            return amSubtractFilter.$stateful = angularMomentConfig.statefulFilters, amSubtractFilter;
        } ]).filter("amAdd", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amAddFilter(value, amount, type) {
                return isUndefinedOrNull(value) ? "" : moment(value).add(parseInt(amount, 10), type);
            }
            return amAddFilter.$stateful = angularMomentConfig.statefulFilters, amAddFilter;
        } ]).filter("amStartOf", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amStartOfFilter(value, type) {
                return isUndefinedOrNull(value) ? "" : moment(value).startOf(type);
            }
            return amStartOfFilter.$stateful = angularMomentConfig.statefulFilters, amStartOfFilter;
        } ]).filter("amEndOf", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amEndOfFilter(value, type) {
                return isUndefinedOrNull(value) ? "" : moment(value).endOf(type);
            }
            return amEndOfFilter.$stateful = angularMomentConfig.statefulFilters, amEndOfFilter;
        } ]), "angularMoment";
    }
    var isElectron = window && window.process && window.process.type;
    "function" == typeof define && define.amd ? define([ "angular", "moment" ], angularMoment) : "undefined" != typeof module && module && module.exports && "function" == typeof require && !isElectron ? module.exports = angularMoment(require("angular"), require("moment")) : angularMoment(angular, ("undefined" != typeof global && void 0 !== global.moment ? global : window).moment);
}(), "undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), 
function(angular, undefined) {
    "use strict";
    var $$UMFP, isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, toJson = angular.toJson;
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        return forEach(arguments, function(obj) {
            obj !== dst && forEach(obj, function(value, key) {
                dst.hasOwnProperty(key) || (dst[key] = value);
            });
        }), dst;
    }
    function objectKeys(object) {
        if (Object.keys) return Object.keys(object);
        var result = [];
        return forEach(object, function(val, key) {
            result.push(key);
        }), result;
    }
    function indexOf(array, value, argument_2) {
        if (Array.prototype.indexOf) return array.indexOf(value, Number(argument_2) || 0);
        var len = array.length >>> 0, from = Number(argument_2) || 0;
        for ((from = from < 0 ? Math.ceil(from) : Math.floor(from)) < 0 && (from += len); from < len; from++) if (from in array && array[from] === value) return from;
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parentParams, i, parents = function(first, second) {
            var n, path = [];
            for (n in first.path) {
                if (first.path[n] !== second.path[n]) break;
                path.push(first.path[n]);
            }
            return path;
        }($current, $to), inherited = {}, inheritList = [];
        for (i in parents) if (parents[i] && parents[i].params && (parentParams = objectKeys(parents[i].params)).length) for (var j in parentParams) 0 <= indexOf(inheritList, parentParams[j]) || (inheritList.push(parentParams[j]), 
        inherited[parentParams[j]] = currentParams[parentParams[j]]);
        return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
        if (!keys) for (var n in keys = [], a) keys.push(n);
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return !1;
        }
        return !0;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        return forEach(keys, function(name) {
            filtered[name] = values[name];
        }), filtered;
    }
    function pick(obj) {
        var copy = {}, keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        return forEach(keys, function(key) {
            key in obj && (copy[key] = obj[key]);
        }), copy;
    }
    function omit(obj) {
        var key, copy = {}, keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (key in obj) -1 == indexOf(keys, key) && (copy[key] = obj[key]);
        return copy;
    }
    function filter(collection, callback) {
        var array = isArray(collection), result = array ? [] : {};
        return forEach(collection, function(val, i) {
            callback(val, i) && (result[array ? result.length : i] = val);
        }), result;
    }
    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        return forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        }), result;
    }
    function silenceUncaughtInPromise(promise) {
        return promise.then(undefined, function() {}) && promise;
    }
    function $Resolve($q, $injector) {
        var NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {}), plan = [], cycle = [], visited = {};
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            return forEach(invocables, function visit(value, key) {
                if (2 !== visited[key]) {
                    if (cycle.push(key), 1 === visited[key]) throw cycle.splice(0, indexOf(cycle, key)), 
                    new Error("Cyclic dependency: " + cycle.join(" -> "));
                    var params;
                    visited[key] = 1, isString(value) ? plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES) : (params = $injector.annotate(value), forEach(params, function(param) {
                        param !== key && invocables.hasOwnProperty(param) && visit(invocables[param], param);
                    }), plan.push(key, value, params)), cycle.pop(), visited[key] = 2;
                }
            }), invocables = cycle = visited = null, function(locals, parent, self) {
                if (isResolve(locals) && self === undefined && (self = parent, parent = locals, 
                locals = null), locals) {
                    if (!isObject(locals)) throw new Error("'locals' must be an object");
                } else locals = NO_LOCALS;
                if (parent) {
                    if (!isResolve(parent)) throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                } else parent = NO_PARENT;
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = !1;
                function done() {
                    --wait || (merged || merge(values, parent.$$values), result.$$values = values, result.$$promises = result.$$promises || !0, 
                    delete result.$$inheritedValues, resolution.resolve(values));
                }
                function fail(reason) {
                    result.$$failure = reason, resolution.reject(reason);
                }
                if (isDefined(parent.$$failure)) return fail(parent.$$failure), result;
                parent.$$inheritedValues && merge(values, omit(parent.$$inheritedValues, invocableKeys)), 
                extend(promises, parent.$$promises), parent.$$values ? (merged = merge(values, omit(parent.$$values, invocableKeys)), 
                result.$$inheritedValues = omit(parent.$$values, invocableKeys), done()) : (parent.$$inheritedValues && (result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys)), 
                parent.then(done, fail));
                for (var i = 0, ii = plan.length; i < ii; i += 3) locals.hasOwnProperty(plan[i]) ? done() : function(key, invocable, params) {
                    var invocation = $q.defer(), waitParams = 0;
                    function onfailure(reason) {
                        invocation.reject(reason), fail(reason);
                    }
                    function proceed() {
                        if (!isDefined(result.$$failure)) try {
                            invocation.resolve($injector.invoke(invocable, self, values)), invocation.promise.then(function(result) {
                                values[key] = result, done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    forEach(params, function(dep) {
                        promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep) && (waitParams++, promises[dep].then(function(result) {
                            values[dep] = result, --waitParams || proceed();
                        }, onfailure));
                    }), waitParams || proceed(), promises[key] = invocation.promise;
                }(plan[i], plan[i + 1], plan[i + 2]);
                return result;
            };
        }, this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        }, this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        }, this.fromUrl = function(url, params) {
            return null == (url = isFunction(url) ? url(params) : url) ? null : $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            });
        }, this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    function UrlMatcher(pattern, config, i) {
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var m, p, param, placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = "^", last = 0, segments = this.segments = [], parentParams = i ? i.params : {}, params = this.params = i ? i.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
        function addParameter(id, type, config, location) {
            if (paramNames.push(id), parentParams[id]) return parentParams[id];
            if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            return params[id] = new $$UMFP.Param(id, type, config, location), params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
              case !1:
                surroundPattern = [ "(", ")" + (optional ? "?" : "") ];
                break;

              case !0:
                result = result.replace(/\/$/, ""), surroundPattern = [ "(?:/(", ")|/)?" ];
                break;

              default:
                surroundPattern = [ "(" + squash + "|", ")?" ];
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        function matchDetails(regexp, isSearch) {
            var type, id = regexp[2] || regexp[3], cfg = config.params[id], segment = pattern.substring(last, regexp.index), regexp = isSearch ? regexp[4] : regexp[4] || ("*" == regexp[1] ? ".*" : null);
            return {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type = regexp ? $$UMFP.type(regexp) || inherit($$UMFP.type("string"), {
                    pattern: new RegExp(regexp, config.caseInsensitive ? "i" : undefined)
                }) : type,
                cfg: cfg
            };
        }
        for (this.source = pattern; (m = placeholder.exec(pattern)) && !(0 <= (p = matchDetails(m, !1)).segment.indexOf("?")); ) param = addParameter(p.id, p.type, p.cfg, "path"), 
        compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional), 
        segments.push(p.segment), last = placeholder.lastIndex;
        i = (segment = pattern.substring(last)).indexOf("?");
        if (0 <= i) {
            var search = this.sourceSearch = segment.substring(i), segment = segment.substring(0, i);
            if (this.sourcePath = pattern.substring(0, last + i), 0 < search.length) for (last = 0; m = searchPlaceholder.exec(search); ) param = addParameter((p = matchDetails(m, !0)).id, p.type, p.cfg, "search"), 
            last = placeholder.lastIndex;
        } else this.sourcePath = pattern, this.sourceSearch = "";
        compiled += quoteRegExp(segment) + (!1 === config.strict ? "/?" : "") + "$", segments.push(segment), 
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined), this.prefix = segments[0], 
        this.$$paramNames = paramNames;
    }
    function Type(config) {
        extend(this, config);
    }
    function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = !1, isStrictMode = !0, defaultSquashPolicy = !1;
        function valToString(val) {
            return null != val ? val.toString().replace(/(~|\/)/g, function(m) {
                return {
                    "~": "~~",
                    "/": "~2F"
                }[m];
            }) : val;
        }
        var injector, $types = {}, enqueue = !0, typeQueue = [], defaultTypes = {
            string: {
                encode: valToString,
                decode: function(val) {
                    return null != val ? val.toString().replace(/(~~|~2F)/g, function(m) {
                        return {
                            "~~": "~",
                            "~2F": "/"
                        }[m];
                    }) : val;
                },
                is: function(val) {
                    return null == val || !isDefined(val) || "string" == typeof val;
                },
                pattern: /[^/]*/
            },
            int: {
                encode: valToString,
                decode: function(val) {
                    return parseInt(val, 10);
                },
                is: function(val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(val) {
                    return val ? 1 : 0;
                },
                decode: function(val) {
                    return 0 !== parseInt(val, 10);
                },
                is: function(val) {
                    return !0 === val || !1 === val;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(val) {
                    return this.is(val) ? [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-") : undefined;
                },
                decode: function(match) {
                    if (this.is(match)) return match;
                    match = this.capture.exec(match);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };
        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
        }
        function flushTypeQueue() {
            for (;typeQueue.length; ) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        function ParamSet(params) {
            extend(this, params || {});
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        }, this.caseInsensitive = function(value) {
            return isCaseInsensitive = isDefined(value) ? value : isCaseInsensitive;
        }, this.strictMode = function(value) {
            return isStrictMode = isDefined(value) ? value : isStrictMode;
        }, this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (!0 !== value && !1 !== value && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return defaultSquashPolicy = value;
        }, this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend({
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            }, config));
        }, this.isMatcher = function(o) {
            if (!isObject(o)) return !1;
            var result = !0;
            return forEach(UrlMatcher.prototype, function(val, name) {
                isFunction(val) && (result = result && isDefined(o[name]) && isFunction(o[name]));
            }), result;
        }, this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            return $types[name] = new Type(extend({
                name: name
            }, definition)), definitionFn && (typeQueue.push({
                name: name,
                def: definitionFn
            }), enqueue || flushTypeQueue()), this;
        }, forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        }), $types = inherit($types, {}), this.$get = [ "$injector", function($injector) {
            return injector = $injector, enqueue = !1, flushTypeQueue(), forEach(defaultTypes, function(type, name) {
                $types[name] || ($types[name] = new Type(type));
            }), this;
        } ], this.Param = function(id, type, config, location) {
            var self = this;
            config = function(config) {
                var keys = isObject(config) ? objectKeys(config) : [];
                -1 === indexOf(keys, "value") && -1 === indexOf(keys, "type") && -1 === indexOf(keys, "squash") && -1 === indexOf(keys, "array") && (config = {
                    value: config
                });
                return config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                }, config;
            }(config), type = function(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                return urlType || (config.type ? angular.isString(config.type) ? $types[config.type] : config.type instanceof Type ? config.type : new Type(config.type) : "config" === location ? $types.any : $types.string);
            }(config, type, location);
            var arrayDefaults, arrayParamNomenclature, arrayMode = (arrayDefaults = {
                array: "search" === location && "auto"
            }, arrayParamNomenclature = id.match(/\[\]$/) ? {
                array: !0
            } : {}, extend(arrayDefaults, arrayParamNomenclature, config).array);
            "string" !== (type = arrayMode ? type.$asArray(arrayMode, "search" === location) : type).name || arrayMode || "path" !== location || config.value !== undefined || (config.value = "");
            var isOptional = config.value !== undefined, squash = function(squash, isOptional) {
                squash = squash.squash;
                if (!isOptional || !1 === squash) return !1;
                if (!isDefined(squash) || null == squash) return defaultSquashPolicy;
                if (!0 === squash || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }(config, isOptional), replace = function(replace, defaultPolicy, isOptional, squash) {
                var configuredKeys, defaultPolicy = [ {
                    from: "",
                    to: isOptional || defaultPolicy ? undefined : ""
                }, {
                    from: null,
                    to: isOptional || defaultPolicy ? undefined : ""
                } ];
                replace = isArray(replace.replace) ? replace.replace : [], isString(squash) && replace.push({
                    from: squash,
                    to: undefined
                });
                return configuredKeys = map(replace, function(item) {
                    return item.from;
                }), filter(defaultPolicy, function(item) {
                    return -1 === indexOf(configuredKeys, item.from);
                }).concat(replace);
            }(config, arrayMode, isOptional, squash);
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: function(value) {
                    return value = function(value) {
                        var val, replacement = map(filter(self.replace, (val = value, function(obj) {
                            return obj.from === val;
                        })), function(obj) {
                            return obj.to;
                        });
                        return replacement.length ? replacement[0] : value;
                    }(value), isDefined(value) ? self.type.$normalize(value) : function() {
                        if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                        var defaultValue = injector.invoke(config.$$fn);
                        if (null !== defaultValue && defaultValue !== undefined && !self.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                        return defaultValue;
                    }();
                },
                dynamic: undefined,
                config: config,
                toString: function() {
                    return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
                }
            });
        }, ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                for (var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype); parent; ) chain.push(parent), 
                parent = parent.$$parent;
                return chain.reverse(), forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        -1 === indexOf(keys, key) && -1 === indexOf(ignore, key) && keys.push(key);
                    });
                }), keys;
            },
            $$values: function(paramValues) {
                var values = {}, self = this;
                return forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                }), values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = !0, self = this;
                return forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    self[key].type.equals(left, right) || (equal = !1);
                }), equal;
            },
            $$validates: function(paramValues) {
                for (var param, rawVal, encoded, keys = this.$$keys(), i = 0; i < keys.length && (param = this[keys[i]], 
                (rawVal = paramValues[keys[i]]) !== undefined && null !== rawVal || !param.isOptional); i++) {
                    if (encoded = param.type.$normalize(rawVal), !param.type.is(encoded)) return !1;
                    if (encoded = param.type.encode(encoded), angular.isString(encoded) && !param.type.pattern.exec(encoded)) return !1;
                }
                return !0;
            },
            $$parent: undefined
        }, this.ParamSet = ParamSet;
    }
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var listener, rules = [], otherwise = null, interceptDeferred = !1;
        function handleIfMatch($injector, handler, result) {
            if (!result) return !1;
            result = $injector.invoke(handler, handler, {
                $match: result
            });
            return !isDefined(result) || result;
        }
        function $get($location, $rootScope, $injector, $browser, $sniffer) {
            var lastPushedUrl, baseHref = $browser.baseHref(), location = $location.url();
            function update(evt) {
                if (!evt || !evt.defaultPrevented) {
                    lastPushedUrl && $location.url();
                    lastPushedUrl = undefined;
                    for (var n = rules.length, i = 0; i < n; i++) if (check(rules[i])) return;
                    otherwise && check(otherwise);
                }
                function check(handled) {
                    handled = handled($injector, $location);
                    return handled && (isString(handled) && $location.replace().url(handled), 1);
                }
            }
            function listen() {
                return listener = listener || $rootScope.$on("$locationChangeSuccess", update);
            }
            return interceptDeferred || listen(), {
                sync: function() {
                    update();
                },
                listen: listen,
                update: function(read) {
                    read ? location = $location.url() : $location.url() !== location && ($location.url(location), 
                    $location.replace());
                },
                push: function(url, params, options) {
                    url = url.format(params || {});
                    null !== url && params && params["#"] && (url += "#" + params["#"]), $location.url(url), 
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined, 
                    options && options.replace && $location.replace();
                },
                href: function(url, params, slash) {
                    if (!url.validates(params)) return null;
                    var port = $locationProvider.html5Mode(), port = (port = angular.isObject(port) ? port.enabled : port) && $sniffer.history, url = url.format(params);
                    if (slash = slash || {}, null !== (url = !port && null !== url ? "#" + $locationProvider.hashPrefix() + url : url) && params && params["#"] && (url += "#" + params["#"]), 
                    url = function(url, isHtml5, absolute) {
                        return "/" === baseHref ? url : isHtml5 ? baseHref.slice(0, -1) + url : absolute ? baseHref.slice(1) + url : url;
                    }(url, port, slash.absolute), !slash.absolute || !url) return url;
                    slash = !port && url ? "/" : "", port = 80 === (port = $location.port()) || 443 === port ? "" : ":" + port;
                    return [ $location.protocol(), "://", $location.host(), port, slash, url ].join("");
                }
            };
        }
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return rules.push(rule), this;
        }, this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return otherwise = rule, this;
        }, this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what) && (what = $urlMatcherFactory.compile(what)), !handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var n, strategies = {
                matcher: function(what, handler) {
                    return handlerIsString && (redirect = $urlMatcherFactory.compile(handler), handler = [ "$match", function($match) {
                        return redirect.format($match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    return handlerIsString && (redirect = handler, handler = [ "$match", function($match) {
                        return match = $match, redirect.replace(/\$(\$|\d{1,2})/, function(m, what) {
                            return match["$" === what ? 0 : Number(what)];
                        });
                        var match;
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: null != (prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec((prefix = what).source)) ? prefix[1].replace(/\\(.)/g, "$1") : ""
                    });
                    var prefix;
                }
            }, check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (n in check) if (check[n]) return this.rule(strategies[n](what, handler));
            throw new Error("invalid 'what' in when()");
        }, this.deferIntercept = function(defer) {
            interceptDeferred = defer = defer === undefined ? !0 : defer;
        }, (this.$get = $get).$inject = [ "$location", "$rootScope", "$injector", "$browser", "$sniffer" ];
    }
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root, $state, states = {}, queue = {}, abstractKey = "abstract", stateBuilder = {
            parent: function(compositeName) {
                if (isDefined(compositeName.parent) && compositeName.parent) return findState(compositeName.parent);
                compositeName = /^(.+)\.[^.]+$/.exec(compositeName.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                return state.parent && state.parent.data && (state.data = state.self.data = inherit(state.parent.data, state.data)), 
                state.data;
            },
            url: function(state) {
                var url = state.url, config = {
                    params: state.params || {}
                };
                if (isString(url)) return "^" == url.charAt(0) ? $urlMatcherFactory.compile(url.substring(1), config) : (state.parent.navigable || root).url.concat(url, config);
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                return forEach(state.params || {}, function(config, id) {
                    params[id] || (params[id] = new $$UMFP.Param(id, null, config, "config"));
                }), params;
            },
            params: function(state) {
                var ownParams = pick(state.ownParams, state.ownParams.$$keys());
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                return forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    name.indexOf("@") < 0 && (name += "@" + state.parent.name), view.resolveAs = view.resolveAs || state.resolveAs || "$resolve", 
                    views[name] = view;
                }), views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                return includes[state.name] = !0, includes;
            },
            $delegates: {}
        };
        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name;
            if (0 === (state = name).indexOf(".") || 0 === state.indexOf("^")) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                for (var rel = name.split("."), i = 0, pathLength = rel.length, current = base; i < pathLength; i++) if ("" !== rel[i] || 0 !== i) {
                    if ("^" !== rel[i]) break;
                    if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                    current = current.parent;
                } else current = base;
                rel = rel.slice(i).join("."), name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            return !state || !isStr && (isStr || state !== stateOrName && state.self !== stateOrName) ? undefined : state;
        }
        function registerState(state) {
            var name = (state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            })).name;
            if (!isString(name) || 0 <= name.indexOf("@")) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");
            var key, parentName = -1 !== name.indexOf(".") ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
            if (parentName && !states[parentName]) return function(parentName, state) {
                queue[parentName] || (queue[parentName] = []), queue[parentName].push(state);
            }(parentName, state.self);
            for (key in stateBuilder) isFunction(stateBuilder[key]) && (state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]));
            return !(states[name] = state)[abstractKey] && state.url && $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                $state.$current.navigable == state && equalForKeys($match, $stateParams) || $state.transitionTo(state, $match, {
                    inherit: !0,
                    location: !1
                });
            } ]), function() {
                for (var queued = queue[name] || []; queued.length; ) registerState(queued.shift());
            }(), state;
        }
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            var TransitionSupersededError = new Error("transition superseded"), TransitionSuperseded = silenceUncaughtInPromise($q.reject(TransitionSupersededError)), TransitionPrevented = silenceUncaughtInPromise($q.reject(new Error("transition prevented"))), TransitionAborted = silenceUncaughtInPromise($q.reject(new Error("transition aborted"))), TransitionFailed = silenceUncaughtInPromise($q.reject(new Error("transition failed")));
            return root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            }, ($state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null,
                reload: function(state) {
                    return $state.transitionTo($state.current, $stateParams, {
                        reload: state || !0,
                        inherit: !1,
                        notify: !0
                    });
                },
                go: function(to, params, options) {
                    return $state.transitionTo(to, params, extend({
                        inherit: !0,
                        relative: $state.$current
                    }, options));
                }
            }).transitionTo = function(to, toParams, options) {
                toParams = toParams || {}, options = extend({
                    location: !0,
                    inherit: !1,
                    relative: null,
                    notify: !0,
                    reload: !1,
                    $retry: !1
                }, options || {});
                var from = $state.$current, fromParams = $state.params, fromPath = from.path, toState = findState(to, options.relative), hash = toParams["#"];
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    }, redirectResult = function(redirect, state, params, options) {
                        var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                        if (evt.defaultPrevented) return $urlRouter.update(), TransitionAborted;
                        if (!evt.retry) return null;
                        if (options.$retry) return $urlRouter.update(), TransitionFailed;
                        var retryTransition = $state.transition = $q.when(evt.retry);
                        return retryTransition.then(function() {
                            return retryTransition !== $state.transition ? ($rootScope.$broadcast("$stateChangeCancel", redirect.to, redirect.toParams, state, params), 
                            TransitionSuperseded) : (redirect.options.$retry = !0, $state.transitionTo(redirect.to, redirect.toParams, redirect.options));
                        }, function() {
                            return TransitionAborted;
                        }), $urlRouter.update(), retryTransition;
                    }(redirect, from.self, fromParams, options);
                    if (redirectResult) return redirectResult;
                    if (toParams = redirect.toParams, toState = findState(to = redirect.to, (options = redirect.options).relative), 
                    !isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit && (toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState)), 
                !toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams);
                var toPath = (to = toState).path, keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                if (options.reload) {
                    if (isString(options.reload) || isObject(options.reload)) {
                        if (isObject(options.reload) && !options.reload.name) throw new Error("Invalid reload state object");
                        var reloadState = !0 === options.reload ? fromPath[0] : findState(options.reload);
                        if (options.reload && !reloadState) throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                        for (;state && state === fromPath[keep] && state !== reloadState; ) locals = toLocals[keep] = state.locals, 
                        state = toPath[++keep];
                    }
                } else for (;state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams); ) locals = toLocals[keep] = state.locals, 
                state = toPath[++keep];
                if (function(to, toParams, from, fromParams, locals, options) {
                    if (!options.reload && to === from && (locals === from.locals || !1 === to.self.reloadOnSearch && function(fromAndToState, fromParams, toParams) {
                        var nonQueryParams = fromAndToState.params.$$keys().filter(function(key) {
                            return "search" != fromAndToState.params[key].location;
                        }), nonQueryParams = pick.apply({}, [ fromAndToState.params ].concat(nonQueryParams));
                        return new $$UMFP.ParamSet(nonQueryParams).$$equals(fromParams, toParams);
                    }(from, fromParams, toParams))) return !0;
                }(to, toParams, from, fromParams, locals, options)) return hash && (toParams["#"] = hash), 
                $state.params = toParams, copy($state.params, $stateParams), copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams), 
                options.location && to.navigable && to.navigable.url && ($urlRouter.push(to.navigable.url, toParams, {
                    $$avoidResync: !0,
                    replace: "replace" === options.location
                }), $urlRouter.update(!0)), $state.transition = null, $q.when($state.current);
                if (toParams = filterByKeys(to.params.$$keys(), toParams || {}), hash && (toParams["#"] = hash), 
                options.notify && $rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams, options).defaultPrevented) return $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                null == $state.transition && $urlRouter.update(), TransitionPrevented;
                for (var resolved = $q.when(locals), l = keep; l < toPath.length; state = toPath[++l]) locals = toLocals[l] = inherit(locals), 
                resolved = function(state, promises, paramsAreFiltered, inherited, dst, options) {
                    var $stateParams = paramsAreFiltered ? promises : filterByKeys(state.params.$$keys(), promises), promises = {
                        $stateParams: $stateParams
                    };
                    dst.resolve = $resolve.resolve(state.resolve, promises, dst.resolve, state);
                    promises = [ dst.resolve.then(function(globals) {
                        dst.globals = globals;
                    }) ];
                    inherited && promises.push(inherited);
                    return $q.all(promises).then(function() {
                        var viewsPromises = [];
                        return forEach(state.views, function(view, name) {
                            var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                            injectables.$template = [ function() {
                                return $view.load(name, {
                                    view: view,
                                    locals: dst.globals,
                                    params: $stateParams,
                                    notify: options.notify
                                }) || "";
                            } ], viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                                var injectLocals;
                                isFunction(view.controllerProvider) || isArray(view.controllerProvider) ? (injectLocals = angular.extend({}, injectables, dst.globals), 
                                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals)) : result.$$controller = view.controller, 
                                result.$$state = state, result.$$controllerAs = view.controllerAs, result.$$resolveAs = view.resolveAs, 
                                dst[name] = result;
                            }));
                        }), $q.all(viewsPromises).then(function() {
                            return dst.globals;
                        });
                    }).then(function(values) {
                        return dst;
                    });
                }(state, toParams, state === to, resolved, locals, options);
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                    TransitionSuperseded;
                    for (l = fromPath.length - 1; keep <= l; l--) (exiting = fromPath[l]).self.onExit && $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals), 
                    exiting.locals = null;
                    for (l = keep; l < toPath.length; l++) (entering = toPath[l]).locals = toLocals[l], 
                    entering.self.onEnter && $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                    return $state.transition !== transition ? ($rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                    TransitionSuperseded) : ($state.$current = to, $state.current = to.self, $state.params = toParams, 
                    copy($state.params, $stateParams), $state.transition = null, options.location && to.navigable && $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                        $$avoidResync: !0,
                        replace: "replace" === options.location
                    }), options.notify && $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams), 
                    $urlRouter.update(!0), $state.current);
                }).then(null, function(error) {
                    return error === TransitionSupersededError ? TransitionSuperseded : $state.transition !== transition ? ($rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                    TransitionSuperseded) : ($state.transition = null, $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error).defaultPrevented || $urlRouter.update(), 
                    $q.reject(error));
                });
                return transition;
            }, $state.is = function(stateOrName, params, state) {
                state = findState(stateOrName, (state = extend({
                    relative: $state.$current
                }, state || {})).relative);
                return isDefined(state) ? $state.$current === state && (!params || equalForKeys(state.params.$$values(params), $stateParams)) : undefined;
            }, $state.includes = function(stateOrName, params, options) {
                if (options = extend({
                    relative: $state.$current
                }, options || {}), isString(stateOrName) && -1 < stateOrName.indexOf("*")) {
                    if (!function(glob) {
                        for (var globSegments = glob.split("."), segments = $state.$current.name.split("."), i = 0, l = globSegments.length; i < l; i++) "*" === globSegments[i] && (segments[i] = "*");
                        return "**" === globSegments[0] && (segments = segments.slice(indexOf(segments, globSegments[1]))).unshift("**"), 
                        "**" === globSegments[globSegments.length - 1] && (segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE), 
                        segments.push("**")), globSegments.length == segments.length && segments.join("") === globSegments.join("");
                    }(stateOrName)) return !1;
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return undefined;
                if (!isDefined($state.$current.includes[state.name])) return !1;
                if (!params) return !0;
                for (var keys = objectKeys(params), i = 0; i < keys.length; i++) {
                    var key = keys[i], paramDef = state.params[key];
                    if (paramDef && !paramDef.type.equals($stateParams[key], params[key])) return !1;
                }
                return !0;
            }, $state.href = function(nav, params, options) {
                var state = findState(nav, (options = extend({
                    lossy: !0,
                    inherit: !0,
                    absolute: !1,
                    relative: $state.$current
                }, options || {})).relative);
                if (!isDefined(state)) return null;
                options.inherit && (params = inheritParams($stateParams, params || {}, $state.$current, state));
                nav = state && options.lossy ? state.navigable : state;
                return nav && nav.url !== undefined && null !== nav.url ? $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat("#"), params || {}), {
                    absolute: options.absolute
                }) : null;
            }, $state.get = function(stateOrName, state) {
                if (0 === arguments.length) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                state = findState(stateOrName, state || $state.$current);
                return state && state.self ? state.self : null;
            }, $state;
        }
        (root = registerState({
            name: "",
            url: "^",
            views: null,
            abstract: !0
        })).navigable = null, this.decorator = function(name, func) {
            if (isString(name) && !isDefined(func)) return stateBuilder[name];
            if (!isFunction(func) || !isString(name)) return this;
            stateBuilder[name] && !stateBuilder.$delegates[name] && (stateBuilder.$delegates[name] = stateBuilder[name]);
            return stateBuilder[name] = func, this;
        }, this.state = function(name, definition) {
            isObject(name) ? definition = name : definition.name = name;
            return registerState(definition), this;
        }, (this.$get = $get).$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
    }
    function $ViewProvider() {
        function $get($rootScope, $templateFactory) {
            return {
                load: function(name, options) {
                    var result;
                    return result = (options = extend({
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: !0,
                        async: !0,
                        params: {}
                    }, options)).view ? $templateFactory.fromConfig(options.view, options.params, options.locals) : result;
                }
            };
        }
        (this.$get = $get).$inject = [ "$rootScope", "$templateFactory" ];
    }
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate, $q) {
        var service = $injector.has ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
        } : function(service) {
            try {
                return $injector.get(service);
            } catch (e) {
                return null;
            }
        }, $animator = service("$animator"), $animate = service("$animate");
        return {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = function(attrs, scope) {
                        if ($animate) return {
                            enter: function(element, target, cb) {
                                2 < angular.version.minor ? $animate.enter(element, null, target).then(cb) : $animate.enter(element, null, target, cb);
                            },
                            leave: function(element, cb) {
                                2 < angular.version.minor ? $animate.leave(element).then(cb) : $animate.leave(element, cb);
                            }
                        };
                        if ($animator) {
                            var animate = $animator && $animator(scope, attrs);
                            return {
                                enter: function(element, target, cb) {
                                    animate.enter(element, null, target), cb();
                                },
                                leave: function(element, cb) {
                                    animate.leave(element), cb();
                                }
                            };
                        }
                        return {
                            enter: function(element, target, cb) {
                                target.after(element), cb();
                            },
                            leave: function(element, cb) {
                                element.remove(), cb();
                            }
                        };
                    }(attrs, scope);
                    $element.inheritedData("$uiView");
                    function updateView(firstTime) {
                        var name = getUiViewName(scope, attrs, $element, $interpolate), newScope = name && $state.$current && $state.$current.locals[name];
                        !firstTime && newScope === latestLocals || (newScope = scope.$new(), latestLocals = $state.$current.locals[name], 
                        newScope.$emit("$viewContentLoading", name), currentEl = $transclude(newScope, function(clone) {
                            var $uiViewData, animEnter = $q.defer(), viewAnimData = $q.defer(), viewAnimData = {
                                $animEnter: animEnter.promise,
                                $animLeave: viewAnimData.promise,
                                $$animLeave: viewAnimData
                            };
                            clone.data("$uiViewAnim", viewAnimData), renderer.enter(clone, $element, function() {
                                animEnter.resolve(), currentScope && currentScope.$emit("$viewContentAnimationEnded"), 
                                (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) && $uiViewScroll(clone);
                            }), previousEl && (previousEl.remove(), previousEl = null), currentScope && (currentScope.$destroy(), 
                            currentScope = null), currentEl && ($uiViewData = currentEl.data("$uiViewAnim"), 
                            renderer.leave(currentEl, function() {
                                $uiViewData.$$animLeave.resolve(), previousEl = null;
                            }), previousEl = currentEl, currentEl = null);
                        }), (currentScope = newScope).$emit("$viewContentLoaded", name), currentScope.$eval(onloadExp));
                    }
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(!1);
                    }), updateView(!0);
                };
            }
        };
    }
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, resolveData) {
                    var link = $state.$current, controller = getUiViewName(scope, resolveData, $element, $interpolate), locals = link && link.locals[controller];
                    locals && ($element.data("$uiView", {
                        name: controller,
                        state: locals.$$state
                    }), $element.html(locals.$template || initial), resolveData = angular.extend({}, locals), 
                    scope[locals.$$resolveAs] = resolveData, link = $compile($element.contents()), locals.$$controller && (locals.$scope = scope, 
                    locals.$element = $element, controller = $controller(locals.$$controller, locals), 
                    locals.$$controllerAs && (scope[locals.$$controllerAs] = controller, scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData), 
                    isFunction(controller.$onInit) && controller.$onInit(), $element.data("$ngControllerController", controller), 
                    $element.children().data("$ngControllerController", controller)), link(scope));
                };
            }
        };
    }
    function getUiViewName(name, attrs, uiViewCreatedBy, $interpolate) {
        name = $interpolate(attrs.uiView || attrs.name || "")(name), uiViewCreatedBy = uiViewCreatedBy.inheritedData("$uiView");
        return 0 <= name.indexOf("@") ? name : name + "@" + (uiViewCreatedBy ? uiViewCreatedBy.state.name : "");
    }
    function parseStateRef(ref, current) {
        var parsed = ref.match(/^\s*({[^}]*})\s*$/);
        if (!(parsed = (ref = parsed ? current + "(" + parsed[1] + ")" : ref).replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/)) || 4 !== parsed.length) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(stateData) {
        stateData = stateData.parent().inheritedData("$uiView");
        if (stateData && stateData.state && stateData.state.name) return stateData.state;
    }
    function getTypeInfo(el) {
        var isSvg = "[object SVGAnimatedString]" === Object.prototype.toString.call(el.prop("href")), isForm = "FORM" === el[0].nodeName;
        return {
            attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
            isAnchor: "A" === el.prop("tagName").toUpperCase(),
            clickable: !isForm
        };
    }
    function clickHook(el, $state, $timeout, type, current) {
        return function(e) {
            var transition, ignorePreventDefaultCount, button = e.which || e.button, target = current();
            1 < button || e.ctrlKey || e.metaKey || e.shiftKey || el.attr("target") || (transition = $timeout(function() {
                $state.go(target.state, target.params, target.options);
            }), e.preventDefault(), ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0, 
            e.preventDefault = function() {
                ignorePreventDefaultCount-- <= 0 && $timeout.cancel(transition);
            });
        };
    }
    function $StateRefDirective($state, $timeout) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var hookFn, ref = parseStateRef(attrs.uiSref, $state.current.name), def = {
                    state: ref.state,
                    href: null,
                    params: null
                }, type = getTypeInfo(element), active = uiSrefActive[1] || uiSrefActive[0], unlinkInfoFn = null;
                def.options = extend(function(el, $state) {
                    return {
                        relative: stateContext(el) || $state.$current,
                        inherit: !0
                    };
                }(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
                function update(val) {
                    val && (def.params = angular.copy(val)), def.href = $state.href(ref.state, def.params, def.options), 
                    unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(ref.state, def.params)), 
                    null !== def.href && attrs.$set(type.attr, def.href);
                }
                ref.paramExpr && (scope.$watch(ref.paramExpr, function(val) {
                    val !== def.params && update(val);
                }, !0), def.params = angular.copy(scope.$eval(ref.paramExpr))), update(), type.clickable && (hookFn = clickHook(element, $state, $timeout, type, function() {
                    return def;
                }), element[element.on ? "on" : "bind"]("click", hookFn), scope.$on("$destroy", function() {
                    element[element.off ? "off" : "unbind"]("click", hookFn);
                }));
            }
        };
    }
    function $StateRefDynamicDirective($state, $timeout) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, watch) {
                var hookFn, type = getTypeInfo(element), active = watch[1] || watch[0], watch = "[" + [ attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null ].map(function(val) {
                    return val || "null";
                }).join(", ") + "]", def = {
                    state: null,
                    params: null,
                    options: null,
                    href: null
                }, unlinkInfoFn = null;
                function runStateRefLink(group) {
                    def.state = group[0], def.params = group[1], def.options = group[2], def.href = $state.href(def.state, def.params, def.options), 
                    unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(def.state, def.params)), 
                    def.href && attrs.$set(type.attr, def.href);
                }
                scope.$watch(watch, runStateRefLink, !0), runStateRefLink(scope.$eval(watch)), type.clickable && (hookFn = clickHook(element, $state, $timeout, type, function() {
                    return def;
                }), element[element.on ? "on" : "bind"]("click", hookFn), scope.$on("$destroy", function() {
                    element[element.off ? "off" : "unbind"]("click", hookFn);
                }));
            }
        };
    }
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", "$timeout", function($scope, $element, $attrs, $timeout) {
                var uiSrefActive, states = [], activeClasses = {}, activeEqClass = $interpolate($attrs.uiSrefActiveEq || "", !1)($scope);
                try {
                    uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                } catch (e) {}
                function addState(stateName, stateParams, activeClass) {
                    var state = $state.get(stateName, stateContext($element)), stateHash = function(state, params) {
                        if (!isString(state)) throw new Error("state should be a string");
                        if (isObject(params)) return state + toJson(params);
                        if (params = $scope.$eval(params), isObject(params)) return state + toJson(params);
                        return state;
                    }(stateName, stateParams), stateInfo = {
                        state: state || {
                            name: stateName
                        },
                        params: stateParams,
                        hash: stateHash
                    };
                    return states.push(stateInfo), activeClasses[stateHash] = activeClass, function() {
                        var idx = states.indexOf(stateInfo);
                        -1 !== idx && states.splice(idx, 1);
                    };
                }
                function update() {
                    for (var state, params, i = 0; i < states.length; i++) state = states[i].state, 
                    params = states[i].params, ($state.includes(state.name, params) ? addClass : removeClass)($element, activeClasses[states[i].hash]), 
                    (!function(state, params) {
                        return $state.is(state.name, params);
                    }(states[i].state, states[i].params) ? removeClass : addClass)($element, activeEqClass);
                }
                function addClass(el, className) {
                    $timeout(function() {
                        el.addClass(className);
                    });
                }
                function removeClass(el, className) {
                    el.removeClass(className);
                }
                uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || "", !1)($scope), 
                isObject(uiSrefActive) && forEach(uiSrefActive, function(ref, activeClass) {
                    isString(ref) && addState((ref = parseStateRef(ref, $state.current.name)).state, $scope.$eval(ref.paramExpr), activeClass);
                }), this.$$addStateInfo = function(newState, deregister) {
                    if (!(isObject(uiSrefActive) && 0 < states.length)) {
                        deregister = addState(newState, deregister, uiSrefActive);
                        return update(), deregister;
                    }
                }, $scope.$on("$stateChangeSuccess", update), update();
            } ]
        };
    }
    function $IsStateFilter($state) {
        function isFilter(state, params) {
            return $state.is(state, params);
        }
        return isFilter.$stateful = !0, isFilter;
    }
    function $IncludedByStateFilter($state) {
        function includesFilter(state, params, options) {
            return $state.includes(state, params, options);
        }
        return includesFilter.$stateful = !0, includesFilter;
    }
    angular.module("ui.router.util", [ "ng" ]), angular.module("ui.router.router", [ "ui.router.util" ]), 
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]), angular.module("ui.router", [ "ui.router.state" ]), 
    angular.module("ui.router.compat", [ "ui.router" ]), $Resolve.$inject = [ "$q", "$injector" ], 
    angular.module("ui.router.util").service("$resolve", $Resolve), $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ], 
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory), 
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    }, UrlMatcher.prototype.toString = function() {
        return this.source;
    }, UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var i, j, paramName, param, paramVal, allReversed, paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {};
        if (nPath != m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        for (i = 0; i < nPath; i++) {
            for (paramName = paramNames[i], param = this.params[paramName], paramVal = m[i + 1], 
            j = 0; j < param.replace.length; j++) param.replace[j].from === paramVal && (paramVal = param.replace[j].to);
            paramVal && !0 === param.array && (allReversed = map(reverseString(allReversed = paramVal).split(/-(?!\\)/), reverseString), 
            paramVal = map(allReversed, function(str) {
                return str.replace(/\\-/g, "-");
            }).reverse()), isDefined(paramVal) && (paramVal = param.type.decode(paramVal)), 
            values[paramName] = param.value(paramVal);
        }
        function reverseString(str) {
            return str.split("").reverse().join("");
        }
        for (;i < nTotal; i++) {
            for (values[paramName = paramNames[i]] = this.params[paramName].value(searchParams[paramName]), 
            param = this.params[paramName], paramVal = searchParams[paramName], j = 0; j < param.replace.length; j++) param.replace[j].from === paramVal && (paramVal = param.replace[j].to);
            isDefined(paramVal) && (paramVal = param.type.decode(paramVal)), values[paramName] = param.value(paramVal);
        }
        return values;
    }, UrlMatcher.prototype.parameters = function(param) {
        return isDefined(param) ? this.params[param] || null : this.$$paramNames;
    }, UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    }, UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = !1, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        for (i = 0; i < nTotal; i++) {
            var nextSegment, capture = i < nPath, name = params[i], param = paramset[name], isFinalPathParam = param.value(values[name]), isDefaultValue = param.isOptional && param.type.equals(param.value(), isFinalPathParam), squash = !!isDefaultValue && param.squash, encoded = param.type.encode(isFinalPathParam);
            capture ? (nextSegment = segments[i + 1], isFinalPathParam = i + 1 === nPath, !1 === squash ? (null != encoded && (isArray(encoded) ? result += map(encoded, encodeDashes).join("-") : result += encodeURIComponent(encoded)), 
            result += nextSegment) : !0 === squash ? (capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/, 
            result += nextSegment.match(capture)[1]) : isString(squash) && (result += squash + nextSegment), 
            isFinalPathParam && !0 === param.squash && "/" === result.slice(-1) && (result = result.slice(0, -1))) : null == encoded || isDefaultValue && !1 !== squash || 0 !== (encoded = !isArray(encoded) ? [ encoded ] : encoded).length && (result += (search ? "&" : "?") + name + "=" + (encoded = map(encoded, encodeURIComponent).join("&" + name + "=")), 
            search = !0);
        }
        return result;
    }, Type.prototype.is = function(val, key) {
        return !0;
    }, Type.prototype.encode = function(val, key) {
        return val;
    }, Type.prototype.decode = function(val, key) {
        return val;
    }, Type.prototype.equals = function(a, b) {
        return a == b;
    }, Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    }, Type.prototype.pattern = /.*/, Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    }, Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
    }, Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode) return this;
        if ("auto" === mode && !isSearch) throw new Error("'auto' array mode is for query parameters only");
        return new function(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }
            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [ val ] : [];
            }
            function falsey(val) {
                return !val;
            }
            function arrayHandler(callback, allTruthyMode) {
                return function(result) {
                    if (isArray(result) && 0 === result.length) return result;
                    result = map(result = arrayWrap(result), callback);
                    return !0 === allTruthyMode ? 0 === filter(result, falsey).length : function(val) {
                        switch (val.length) {
                          case 0:
                            return undefined;

                          case 1:
                            return "auto" === mode ? val[0] : val;

                          default:
                            return val;
                        }
                    }(result);
                };
            }
            var callback;
            this.encode = arrayHandler(bindTo(type, "encode")), this.decode = arrayHandler(bindTo(type, "decode")), 
            this.is = arrayHandler(bindTo(type, "is"), !0), this.equals = (callback = bindTo(type, "equals"), 
            function(val1, val2) {
                var left = arrayWrap(val1), right = arrayWrap(val2);
                if (left.length !== right.length) return !1;
                for (var i = 0; i < left.length; i++) if (!callback(left[i], right[i])) return !1;
                return !0;
            }), this.pattern = type.pattern, this.$normalize = arrayHandler(bindTo(type, "$normalize")), 
            this.name = type.name, this.$arrayMode = mode;
        }(this, mode);
    }, angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory), 
    angular.module("ui.router.util").run([ "$urlMatcherFactory", function($urlMatcherFactory) {} ]), 
    $UrlRouterProvider.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ], 
    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider), $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ], 
    angular.module("ui.router.state").factory("$stateParams", function() {
        return {};
    }).constant("$state.runtime", {
        autoinject: !0
    }).provider("$state", $StateProvider).run([ "$injector", function($injector) {
        $injector.get("$state.runtime").autoinject && $injector.get("$state");
    } ]), $ViewProvider.$inject = [], angular.module("ui.router.state").provider("$view", $ViewProvider), 
    angular.module("ui.router.state").provider("$uiViewScroll", function() {
        var useAnchorScroll = !1;
        this.useAnchorScroll = function() {
            useAnchorScroll = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            return useAnchorScroll ? $anchorScroll : function($element) {
                return $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }), $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate", "$q" ], 
    $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiView", $ViewDirective), angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill), 
    $StateRefDirective.$inject = [ "$state", "$timeout" ], $StateRefDynamicDirective.$inject = [ "$state", "$timeout" ], 
    $StateRefActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective).directive("uiState", $StateRefDynamicDirective), 
    $IsStateFilter.$inject = [ "$state" ], $IncludedByStateFilter.$inject = [ "$state" ], 
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
}((window, window.angular)), function(window, angular) {
    "use strict";
    var TRANSITION_PROP, ANIMATION_PROP, ELEMENT_NODE = 1, ADD_CLASS_SUFFIX = "-add", REMOVE_CLASS_SUFFIX = "-remove", EVENT_CLASS_PREFIX = "ng-", TRANSITIONEND_EVENT = void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend ? (TRANSITION_PROP = "WebkitTransition", 
    "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", "transitionend"), ANIMATIONEND_EVENT = void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend ? (ANIMATION_PROP = "WebkitAnimation", 
    "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", "animationend"), ANIMATION_PLAYSTATE_KEY = "PlayState", ANIMATION_DELAY_PROP = ANIMATION_PROP + "Delay", ANIMATION_DURATION_PROP = ANIMATION_PROP + "Duration", TRANSITION_DELAY_PROP = TRANSITION_PROP + "Delay", $$AnimationProvider = TRANSITION_PROP + "Duration", ngMinErr = angular.$$minErr("ng");
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (a = isArray(a) ? a.join(" ") : a) + " " + (b = isArray(b) ? b.join(" ") : b) : a : b : "";
    }
    function pendClasses(classes, fix, isPrefix) {
        var className = "";
        return classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [], 
        forEach(classes, function(klass, i) {
            klass && 0 < klass.length && (className += 0 < i ? " " : "", className += isPrefix ? fix + klass : klass + fix);
        }), className;
    }
    function stripCommentsFromElement(element) {
        if (element instanceof jqLite) switch (element.length) {
          case 0:
            return element;

          case 1:
            if (element[0].nodeType === ELEMENT_NODE) return element;
            break;

          default:
            return jqLite(extractElementNode(element));
        }
        if (element.nodeType === ELEMENT_NODE) return jqLite(element);
    }
    function extractElementNode(element) {
        if (!element[0]) return element;
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
            options.addClass && (function($$jqLite, element, className) {
                forEach(element, function(elm) {
                    $$jqLite.addClass(elm, className);
                });
            }($$jqLite, element, options.addClass), options.addClass = null), options.removeClass && (function($$jqLite, element, className) {
                forEach(element, function(elm) {
                    $$jqLite.removeClass(elm, className);
                });
            }($$jqLite, element, options.removeClass), options.removeClass = null);
        };
    }
    function prepareAnimationOptions(options) {
        var domOperation;
        return (options = options || {}).$$prepared || (domOperation = options.domOperation || noop, 
        options.domOperation = function() {
            options.$$domOperationFired = !0, domOperation(), domOperation = noop;
        }, options.$$prepared = !0), options;
    }
    function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options);
    }
    function applyAnimationFromStyles(element, options) {
        options.from && (element.css(options.from), options.from = null);
    }
    function applyAnimationToStyles(element, options) {
        options.to && (element.css(options.to), options.to = null);
    }
    function mergeAnimationDetails(element, oldAnimation, realDomOperation) {
        var target = oldAnimation.options || {}, newOptions = realDomOperation.options || {}, classes = (target.addClass || "") + " " + (newOptions.addClass || ""), realDomOperation = (target.removeClass || "") + " " + (newOptions.removeClass || ""), classes = function(existing, toAdd, toRemove) {
            var flags = {};
            existing = splitClassesToLookup(existing), toAdd = splitClassesToLookup(toAdd), 
            forEach(toAdd, function(value, key) {
                flags[key] = 1;
            }), toRemove = splitClassesToLookup(toRemove), forEach(toRemove, function(value, key) {
                flags[key] = 1 === flags[key] ? null : -1;
            });
            var classes = {
                addClass: "",
                removeClass: ""
            };
            function splitClassesToLookup(classes) {
                isString(classes) && (classes = classes.split(" "));
                var obj = {};
                return forEach(classes, function(klass) {
                    klass.length && (obj[klass] = !0);
                }), obj;
            }
            return forEach(flags, function(val, klass) {
                var prop, allow;
                1 === val ? (prop = "addClass", allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX]) : -1 === val && (prop = "removeClass", 
                allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX]), allow && (classes[prop].length && (classes[prop] += " "), 
                classes[prop] += klass);
            }), classes;
        }(element.attr("class"), classes, realDomOperation);
        newOptions.preparationClasses && (target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses), 
        delete newOptions.preparationClasses);
        realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        return extend(target, newOptions), realDomOperation && (target.domOperation = realDomOperation), 
        classes.addClass ? target.addClass = classes.addClass : target.addClass = null, 
        classes.removeClass ? target.removeClass = classes.removeClass : target.removeClass = null, 
        oldAnimation.addClass = target.addClass, oldAnimation.removeClass = target.removeClass, 
        target;
    }
    function getDomNode(element) {
        return element instanceof jqLite ? element[0] : element;
    }
    function blockKeyframeAnimations(node, key) {
        var value = key ? "paused" : "", key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        return applyInlineStyle(node, [ key, value ]), [ key, value ];
    }
    function applyInlineStyle(node, value) {
        var prop = value[0], value = value[1];
        node.style[prop] = value;
    }
    function concatWithSpace(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    var helpers_blockTransitions = function(node, value) {
        value = value ? "-" + value + "s" : "";
        return applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]), [ TRANSITION_DELAY_PROP, value ];
    }, $$AnimateChildrenDirective = [ "$interpolate", function($interpolate) {
        return {
            link: function(scope, element, attrs) {
                var val = attrs.ngAnimateChildren;
                function setData(value) {
                    value = "on" === value || "true" === value, element.data("$$ngAnimateChildren", value);
                }
                isString(val) && 0 === val.length ? element.data("$$ngAnimateChildren", !0) : (setData($interpolate(val)(scope)), 
                attrs.$observe("ngAnimateChildren", setData));
            }
        };
    } ], DETECT_CSS_PROPERTIES = {
        transitionDuration: $$AnimationProvider,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + "Property",
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + "IterationCount"
    }, DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: $$AnimationProvider,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
    };
    function getCssDelayStyle(delay, isKeyframeAnimation) {
        return [ isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP, delay + "s" ];
    }
    function computeCssStyles($window, element, properties) {
        var styles = Object.create(null), detectedStyles = $window.getComputedStyle(element) || {};
        return forEach(properties, function(values, actualStyleName) {
            var maxValue, val = detectedStyles[values];
            val && (("-" === (values = val.charAt(0)) || "+" === values || 0 <= values) && (maxValue = 0, 
            values = (values = val).split(/\s*,\s*/), forEach(values, function(value) {
                "s" === value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), 
                value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value;
            }), val = maxValue), 0 === val && (val = null), styles[actualStyleName] = val);
        }), styles;
    }
    function truthyTimingValue(val) {
        return 0 === val || null != val;
    }
    function getCssTransitionDurationStyle(value, applyOnlyDuration) {
        var style = TRANSITION_PROP, value = value + "s";
        return applyOnlyDuration ? style += "Duration" : value += " linear all", [ style, value ];
    }
    function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
            backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
    }
    var copy, extend, forEach, isArray, isDefined, isElement, isFunction, isObject, isString, isUndefined, jqLite, noop, $AnimateCssProvider = [ "$animateProvider", function($animateProvider) {
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$animateCache", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function($window, $$jqLite, $$AnimateRunner, $timeout, $$animateCache, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            var rafWaitQueue = [];
            function waitUntilQuiet(callback) {
                rafWaitQueue.push(callback), $$rAFScheduler.waitUntilQuiet(function() {
                    $$animateCache.flush();
                    for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                    rafWaitQueue.length = 0;
                });
            }
            function computeTimings(timings, className, aD, tD) {
                timings = function(node, cacheKey, hasDuration, properties) {
                    var timings = $$animateCache.get(cacheKey);
                    return timings || "infinite" === (timings = computeCssStyles($window, node, properties)).animationIterationCount && (timings.animationIterationCount = 1), 
                    hasDuration = hasDuration || 0 < timings.transitionDuration || 0 < timings.animationDuration, 
                    $$animateCache.put(cacheKey, timings, hasDuration), timings;
                }(timings, aD, tD, DETECT_CSS_PROPERTIES), aD = timings.animationDelay, tD = timings.transitionDelay;
                return timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD, timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration), 
                timings;
            }
            return function(element, addRemoveClassName) {
                var options = addRemoveClassName || {};
                options.$$prepared || (options = prepareAnimationOptions(copy(options)));
                var restoreStyles = {}, node = getDomNode(element);
                if (!node || !node.parentNode || !$$animateQueue.enabled()) return closeAndReturnNoopAnimator();
                var animationClosed, animationPaused, animationCompleted, runner, runnerHost, maxDelayTime, maxDurationTime, startTime, temporaryStyles = [], hasToStyles = element.attr("class"), staggerVal = function(options) {
                    var styles = {};
                    return options && (options.to || options.from) && (styles.to = options.to, styles.from = options.from), 
                    styles;
                }(options), events = [];
                if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions) return closeAndReturnNoopAnimator();
                var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event, isStructural = method && options.structural, structuralClassName = "", addRemoveClassName = "";
                isStructural ? structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, !0) : method && (structuralClassName = method), 
                options.addClass && (addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX)), 
                options.removeClass && (addRemoveClassName.length && (addRemoveClassName += " "), 
                addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)), options.applyClassesEarly && addRemoveClassName.length && applyAnimationClasses(element, options);
                var preparationClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim(), hasToStyles = staggerVal.to && 0 < Object.keys(staggerVal.to).length;
                if (!(0 < (options.keyframeStyle || "").length) && !hasToStyles && !preparationClasses) return closeAndReturnNoopAnimator();
                var stagger, applyOnlyDuration, durationStyle, cacheKey = $$animateCache.cacheKey(node, method, options.addClass, options.removeClass);
                if ($$animateCache.containsCachedAnimationWithoutDuration(cacheKey)) return preparationClasses = null, 
                closeAndReturnNoopAnimator();
                stagger = 0 < options.stagger ? {
                    transitionDelay: staggerVal = parseFloat(options.stagger),
                    animationDelay: staggerVal,
                    transitionDuration: 0,
                    animationDuration: 0
                } : function(node, staggerClassName, cacheKey, properties) {
                    var stagger, staggerCacheKey = "stagger-" + cacheKey;
                    return 0 < $$animateCache.count(cacheKey) && ((stagger = $$animateCache.get(staggerCacheKey)) || (staggerClassName = pendClasses(staggerClassName, "-stagger"), 
                    $$jqLite.addClass(node, staggerClassName), (stagger = computeCssStyles($window, node, properties)).animationDuration = Math.max(stagger.animationDuration, 0), 
                    stagger.transitionDuration = Math.max(stagger.transitionDuration, 0), $$jqLite.removeClass(node, staggerClassName), 
                    $$animateCache.put(staggerCacheKey, stagger, !0))), stagger || {};
                }(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES), options.$$skipPreparationClasses || $$jqLite.addClass(element, preparationClasses), 
                options.transitionStyle && (durationStyle = [ TRANSITION_PROP, options.transitionStyle ], 
                applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle)), 0 <= options.duration && (applyOnlyDuration = 0 < node.style[TRANSITION_PROP].length, 
                durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration), 
                applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle)), options.keyframeStyle && (isFirst = [ ANIMATION_PROP, options.keyframeStyle ], 
                applyInlineStyle(node, isFirst), temporaryStyles.push(isFirst));
                var itemIndex = stagger ? 0 <= options.staggerIndex ? options.staggerIndex : $$animateCache.count(cacheKey) : 0, isFirst = 0 === itemIndex;
                isFirst && !options.skipBlocking && helpers_blockTransitions(node, 9999);
                var timings = computeTimings(node, 0, cacheKey, !isStructural), relativeDelay = timings.maxDelay, maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration, flags = {};
                if (flags.hasTransitions = 0 < timings.transitionDuration, flags.hasAnimations = 0 < timings.animationDuration, 
                flags.hasTransitionAll = flags.hasTransitions && "all" === timings.transitionProperty, 
                flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions), 
                flags.applyAnimationDuration = options.duration && flags.hasAnimations, flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions), 
                flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations, 
                flags.recalculateTimingStyles = 0 < addRemoveClassName.length, (flags.applyTransitionDuration || flags.applyAnimationDuration) && (maxDuration = options.duration ? parseFloat(options.duration) : maxDuration, 
                flags.applyTransitionDuration && (flags.hasTransitions = !0, timings.transitionDuration = maxDuration, 
                applyOnlyDuration = 0 < node.style[TRANSITION_PROP + "Property"].length, temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))), 
                flags.applyAnimationDuration && (flags.hasAnimations = !0, timings.animationDuration = maxDuration, 
                temporaryStyles.push([ ANIMATION_DURATION_PROP, maxDuration + "s" ]))), 0 === maxDuration && !flags.recalculateTimingStyles) return closeAndReturnNoopAnimator();
                var delayStyle, activeClasses = pendClasses(preparationClasses, "-active");
                return null != options.delay && ("boolean" != typeof options.delay && (delayStyle = parseFloat(options.delay), 
                maxDelay = Math.max(delayStyle, 0)), flags.applyTransitionDelay && temporaryStyles.push(getCssDelayStyle(delayStyle)), 
                flags.applyAnimationDelay && temporaryStyles.push(getCssDelayStyle(delayStyle, !0))), 
                null == options.duration && 0 < timings.transitionDuration && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst), 
                maxDelayTime = 1e3 * maxDelay, maxDurationTime = 1e3 * maxDuration, options.skipBlocking || (flags.blockTransition = 0 < timings.transitionDuration, 
                flags.blockKeyframeAnimation = 0 < timings.animationDuration && 0 < stagger.animationDelay && 0 === stagger.animationDuration), 
                options.from && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.from)), 
                applyAnimationFromStyles(element, options)), flags.blockTransition || flags.blockKeyframeAnimation ? applyBlocking(maxDuration) : options.skipBlocking || helpers_blockTransitions(node, !1), 
                {
                    $$willAnimate: !0,
                    end: endFn,
                    start: function() {
                        if (!animationClosed) return runner = new $$AnimateRunner(runnerHost = {
                            end: endFn,
                            cancel: cancelFn,
                            resume: null,
                            pause: null
                        }), waitUntilQuiet(start), runner;
                    }
                };
                function endFn() {
                    close();
                }
                function cancelFn() {
                    close(!0);
                }
                function close(rejected) {
                    var animationTimerData;
                    animationClosed || animationCompleted && animationPaused || (animationPaused = !(animationClosed = !0), 
                    preparationClasses && !options.$$skipPreparationClasses && $$jqLite.removeClass(element, preparationClasses), 
                    activeClasses && $$jqLite.removeClass(element, activeClasses), blockKeyframeAnimations(node, !1), 
                    helpers_blockTransitions(node, !1), forEach(temporaryStyles, function(entry) {
                        node.style[entry[0]] = "";
                    }), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                    Object.keys(restoreStyles).length && forEach(restoreStyles, function(value, prop) {
                        value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                    }), options.onDone && options.onDone(), events && events.length && element.off(events.join(" "), onAnimationProgress), 
                    (animationTimerData = element.data("$$animateCss")) && ($timeout.cancel(animationTimerData[0].timer), 
                    element.removeData("$$animateCss")), runner && runner.complete(!rejected));
                }
                function applyBlocking(duration) {
                    flags.blockTransition && helpers_blockTransitions(node, duration), flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration);
                }
                function closeAndReturnNoopAnimator() {
                    return runner = new $$AnimateRunner({
                        end: endFn,
                        cancel: cancelFn
                    }), waitUntilQuiet(noop), close(), {
                        $$willAnimate: !1,
                        start: function() {
                            return runner;
                        },
                        end: endFn
                    };
                }
                function onAnimationProgress(timeStamp) {
                    timeStamp.stopPropagation();
                    var elapsedTime = timeStamp.originalEvent || timeStamp;
                    elapsedTime.target === node && (timeStamp = elapsedTime.$manualTimeStamp || Date.now(), 
                    elapsedTime = parseFloat(elapsedTime.elapsedTime.toFixed(3)), Math.max(timeStamp - startTime, 0) >= maxDelayTime && maxDuration <= elapsedTime && (animationCompleted = !0, 
                    close()));
                }
                function start() {
                    var playPause, maxStagger;
                    function triggerAnimationStart() {
                        if (!animationClosed) {
                            if (applyBlocking(!1), forEach(temporaryStyles, function(value) {
                                var key = value[0], value = value[1];
                                node.style[key] = value;
                            }), applyAnimationClasses(element, options), $$jqLite.addClass(element, activeClasses), 
                            flags.recalculateTimingStyles) {
                                if (node.getAttribute("class"), cacheKey = $$animateCache.cacheKey(node, method, options.addClass, options.removeClass), 
                                timings = computeTimings(node, 0, cacheKey, !1), relativeDelay = timings.maxDelay, 
                                maxDelay = Math.max(relativeDelay, 0), 0 === (maxDuration = timings.maxDuration)) return void close();
                                flags.hasTransitions = 0 < timings.transitionDuration, flags.hasAnimations = 0 < timings.animationDuration;
                            }
                            flags.applyAnimationDelay && (relativeDelay = "boolean" != typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay, 
                            maxDelay = Math.max(relativeDelay, 0), timings.animationDelay = relativeDelay, delayStyle = getCssDelayStyle(relativeDelay, !0), 
                            temporaryStyles.push(delayStyle), node.style[delayStyle[0]] = delayStyle[1]), maxDelayTime = 1e3 * maxDelay, 
                            maxDurationTime = 1e3 * maxDuration, options.easing && (currentTimerData = options.easing, 
                            flags.hasTransitions && (setupFallbackTimer = TRANSITION_PROP + "TimingFunction", 
                            temporaryStyles.push([ setupFallbackTimer, currentTimerData ]), node.style[setupFallbackTimer] = currentTimerData), 
                            flags.hasAnimations && (setupFallbackTimer = ANIMATION_PROP + "TimingFunction", 
                            temporaryStyles.push([ setupFallbackTimer, currentTimerData ]), node.style[setupFallbackTimer] = currentTimerData)), 
                            timings.transitionDuration && events.push(TRANSITIONEND_EVENT), timings.animationDuration && events.push(ANIMATIONEND_EVENT), 
                            startTime = Date.now();
                            var currentTimerData, timer = maxDelayTime + 1.5 * maxDurationTime, endTime = startTime + timer, animationsData = element.data("$$animateCss") || [], setupFallbackTimer = !0;
                            animationsData.length && ((setupFallbackTimer = endTime > (currentTimerData = animationsData[0]).expectedEndTime) ? $timeout.cancel(currentTimerData.timer) : animationsData.push(close)), 
                            setupFallbackTimer && (timer = $timeout(onAnimationExpired, timer, !1), animationsData[0] = {
                                timer: timer,
                                expectedEndTime: endTime
                            }, animationsData.push(close), element.data("$$animateCss", animationsData)), events.length && element.on(events.join(" "), onAnimationProgress), 
                            options.to && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.to)), 
                            applyAnimationToStyles(element, options));
                        }
                    }
                    function onAnimationExpired() {
                        var animationsData = element.data("$$animateCss");
                        if (animationsData) {
                            for (var i = 1; i < animationsData.length; i++) animationsData[i]();
                            element.removeData("$$animateCss");
                        }
                    }
                    animationClosed || (node.parentNode ? (playPause = function(arr) {
                        var val, index;
                        animationCompleted ? animationPaused && arr && (animationPaused = !1, close()) : (animationPaused = !arr, 
                        timings.animationDuration && (index = blockKeyframeAnimations(node, animationPaused), 
                        animationPaused ? temporaryStyles.push(index) : (val = index, index = (arr = temporaryStyles).indexOf(val), 
                        0 <= val && arr.splice(index, 1))));
                    }, (maxStagger = 0 < itemIndex && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay)) ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * 1e3), !1) : triggerAnimationStart(), 
                    runnerHost.resume = function() {
                        playPause(!0);
                    }, runnerHost.pause = function() {
                        playPause(!1);
                    }) : close());
                }
            };
        } ];
    } ], $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateCssDriver");
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function($animateCss, $rootScope, $$AnimateRunner, node, $sniffer, $$jqLite, rootNode) {
            if (!$sniffer.animations && !$sniffer.transitions) return noop;
            var bodyNode = rootNode[0].body, rootNode = getDomNode(node), rootBodyElement = jqLite((node = rootNode).parentNode && 11 === node.parentNode.nodeType || bodyNode.contains(rootNode) ? rootNode : bodyNode);
            return function(animationDetails) {
                return animationDetails.from && animationDetails.to ? (from = animationDetails.from, 
                to = animationDetails.to, animationDetails.classes, anchors = animationDetails.anchors, 
                fromAnimation = prepareRegularAnimation(from), toAnimation = prepareRegularAnimation(to), 
                anchorAnimations = [], forEach(anchors, function(animator) {
                    animator = function(outAnchor, inAnchor) {
                        var clone = jqLite(getDomNode(outAnchor).cloneNode(!0)), startingClasses = filterCssClasses(getClassVal(clone));
                        outAnchor.addClass("ng-animate-shim"), inAnchor.addClass("ng-animate-shim"), clone.addClass("ng-anchor"), 
                        rootBodyElement.append(clone);
                        var animatorIn, animatorOut = function() {
                            var animator = $animateCss(clone, {
                                addClass: "ng-anchor-out",
                                delay: !0,
                                from: calculateAnchorStyles(outAnchor)
                            });
                            return animator.$$willAnimate ? animator : null;
                        }();
                        if (!animatorOut && !(animatorIn = prepareInAnimation())) return end();
                        var startingAnimator = animatorOut || animatorIn;
                        return {
                            start: function() {
                                var runner, currentAnimation = startingAnimator.start();
                                return currentAnimation.done(function() {
                                    return currentAnimation = null, !animatorIn && (animatorIn = prepareInAnimation()) ? ((currentAnimation = animatorIn.start()).done(function() {
                                        currentAnimation = null, end(), runner.complete();
                                    }), currentAnimation) : (end(), void runner.complete());
                                }), runner = new $$AnimateRunner({
                                    end: endFn,
                                    cancel: endFn
                                });
                                function endFn() {
                                    currentAnimation && currentAnimation.end();
                                }
                            }
                        };
                        function calculateAnchorStyles(anchor) {
                            var styles = {}, coords = getDomNode(anchor).getBoundingClientRect();
                            return forEach([ "width", "height", "top", "left" ], function(key) {
                                var value = coords[key];
                                switch (key) {
                                  case "top":
                                    value += bodyNode.scrollTop;
                                    break;

                                  case "left":
                                    value += bodyNode.scrollLeft;
                                }
                                styles[key] = Math.floor(value) + "px";
                            }), styles;
                        }
                        function getClassVal(element) {
                            return element.attr("class") || "";
                        }
                        function prepareInAnimation() {
                            var animator = filterCssClasses(getClassVal(inAnchor)), toAdd = getUniqueValues(animator, startingClasses), animator = getUniqueValues(startingClasses, animator), animator = $animateCss(clone, {
                                to: calculateAnchorStyles(inAnchor),
                                addClass: "ng-anchor-in " + toAdd,
                                removeClass: "ng-anchor-out " + animator,
                                delay: !0
                            });
                            return animator.$$willAnimate ? animator : null;
                        }
                        function end() {
                            clone.remove(), outAnchor.removeClass("ng-animate-shim"), inAnchor.removeClass("ng-animate-shim");
                        }
                    }(animator.out, animator.in);
                    animator && anchorAnimations.push(animator);
                }), fromAnimation || toAnimation || 0 !== anchorAnimations.length ? {
                    start: function() {
                        var animationRunners = [];
                        fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                        forEach(anchorAnimations, function(animation) {
                            animationRunners.push(animation.start());
                        });
                        var runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                        return $$AnimateRunner.all(animationRunners, function(status) {
                            runner.complete(status);
                        }), runner;
                        function endFn() {
                            forEach(animationRunners, function(runner) {
                                runner.end();
                            });
                        }
                    }
                } : void 0) : prepareRegularAnimation(animationDetails);
                var from, to, anchors, fromAnimation, toAnimation, anchorAnimations;
            };
            function filterCssClasses(classes) {
                return classes.replace(/\bng-\S+\b/g, "");
            }
            function getUniqueValues(a, b) {
                return isString(a) && (a = a.split(" ")), isString(b) && (b = b.split(" ")), a.filter(function(val) {
                    return -1 === b.indexOf(val);
                }).join(" ");
            }
            function prepareRegularAnimation(animationDetails) {
                var element = animationDetails.element, animator = animationDetails.options || {};
                animationDetails.structural && (animator.event = animationDetails.event, animator.structural = !0, 
                animator.applyClassesEarly = !0, "leave" === animationDetails.event && (animator.onDone = animator.domOperation)), 
                animator.preparationClasses && (animator.event = concatWithSpace(animator.event, animator.preparationClasses));
                animator = $animateCss(element, animator);
                return animator.$$willAnimate ? animator : null;
            }
        } ];
    } ], $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function($injector, $$AnimateRunner, $$jqLite) {
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, afterFn, options) {
                var animationClosed = !1;
                3 === arguments.length && isObject(afterFn) && (options = afterFn, afterFn = null), 
                options = prepareAnimationOptions(options), afterFn || (afterFn = element.attr("class") || "", 
                options.addClass && (afterFn += " " + options.addClass), options.removeClass && (afterFn += " " + options.removeClass));
                var before, after, beforeFn, runner, classesToAdd = options.addClass, classesToRemove = options.removeClass, animations = function(classes) {
                    classes = isArray(classes) ? classes : classes.split(" ");
                    for (var matches = [], flagMap = {}, i = 0; i < classes.length; i++) {
                        var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                        animationFactory && !flagMap[klass] && (matches.push($injector.get(animationFactory)), 
                        flagMap[klass] = !0);
                    }
                    return matches;
                }(afterFn);
                if (animations.length && (afterFn = "leave" === event ? (beforeFn = "leave", "afterLeave") : (beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1), 
                event), "enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn)), 
                after = packageAnimations(element, event, options, animations, afterFn)), before || after) return {
                    $$willAnimate: !0,
                    end: function() {
                        return runner ? runner.end() : (close(), (runner = new $$AnimateRunner()).complete(!0)), 
                        runner;
                    },
                    start: function() {
                        if (runner) return runner;
                        var closeActiveAnimations;
                        runner = new $$AnimateRunner();
                        var chain = [];
                        return before && chain.push(function(fn) {
                            closeActiveAnimations = before(fn);
                        }), chain.length ? chain.push(function(fn) {
                            applyOptions(), fn(!0);
                        }) : applyOptions(), after && chain.push(function(fn) {
                            closeActiveAnimations = after(fn);
                        }), runner.setHost({
                            end: function() {
                                endAnimations();
                            },
                            cancel: function() {
                                endAnimations(!0);
                            }
                        }), $$AnimateRunner.chain(chain, onComplete), runner;
                        function onComplete(success) {
                            close(), runner.complete(success);
                        }
                        function endAnimations(cancelled) {
                            animationClosed || ((closeActiveAnimations || noop)(cancelled), onComplete(cancelled));
                        }
                    }
                };
                function applyOptions() {
                    options.domOperation(), applyAnimationClasses(element, options);
                }
                function close() {
                    animationClosed = !0, applyOptions(), applyAnimationStyles(element, options);
                }
                function groupEventedAnimations(element, event, options, animations, fnName) {
                    var operations = [];
                    return forEach(animations, function(ani) {
                        var animation = ani[fnName];
                        animation && operations.push(function() {
                            function onAnimationComplete(rejected) {
                                resolved || (resolved = !0, (endProgressCb || noop)(rejected), runner.complete(!rejected));
                            }
                            var resolved = !1, runner = new $$AnimateRunner({
                                end: function() {
                                    onAnimationComplete();
                                },
                                cancel: function() {
                                    onAnimationComplete(!0);
                                }
                            }), endProgressCb = function(value, element, event, options, onDone) {
                                var args;
                                switch (event) {
                                  case "animate":
                                    args = [ element, options.from, options.to, onDone ];
                                    break;

                                  case "setClass":
                                    args = [ element, classesToAdd, classesToRemove, onDone ];
                                    break;

                                  case "addClass":
                                    args = [ element, classesToAdd, onDone ];
                                    break;

                                  case "removeClass":
                                    args = [ element, classesToRemove, onDone ];
                                    break;

                                  default:
                                    args = [ element, onDone ];
                                }
                                if (args.push(options), value = value.apply(value, args)) if ((value = isFunction(value.start) ? value.start() : value) instanceof $$AnimateRunner) value.done(onDone); else if (isFunction(value)) return value;
                                return noop;
                            }(animation, element, event, options, function(result) {
                                onAnimationComplete(!1 === result);
                            });
                            return runner;
                        });
                    }), operations;
                }
                function packageAnimations(element, event, options, animations, fnName) {
                    var a, b, operations = groupEventedAnimations(element, event, options, animations, fnName);
                    if (0 === operations.length && ("beforeSetClass" === fnName ? (a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass"), 
                    b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")) : "setClass" === fnName && (a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass"), 
                    b = groupEventedAnimations(element, "addClass", options, animations, "addClass")), 
                    a && (operations = operations.concat(a)), b && (operations = operations.concat(b))), 
                    0 !== operations.length) return function(callback) {
                        var runners = [];
                        return operations.length && forEach(operations, function(animateFn) {
                            runners.push(animateFn());
                        }), runners.length ? $$AnimateRunner.all(runners, callback) : callback(), function(reject) {
                            forEach(runners, function(runner) {
                                reject ? runner.cancel() : runner.end();
                            });
                        };
                    };
                }
            };
        } ];
    } ], $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver"), this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
            return function(animationDetails) {
                if (!animationDetails.from || !animationDetails.to) return prepareAnimation(animationDetails);
                var fromAnimation = prepareAnimation(animationDetails.from), toAnimation = prepareAnimation(animationDetails.to);
                return fromAnimation || toAnimation ? {
                    start: function() {
                        var animationRunners = [];
                        fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                        $$AnimateRunner.all(animationRunners, function(status) {
                            runner.complete(status);
                        });
                        var runner = new $$AnimateRunner({
                            end: endFnFactory(),
                            cancel: endFnFactory()
                        });
                        return runner;
                        function endFnFactory() {
                            return function() {
                                forEach(animationRunners, function(runner) {
                                    runner.end();
                                });
                            };
                        }
                    }
                } : void 0;
            };
            function prepareAnimation(classes) {
                var element = classes.element, event = classes.event, options = classes.options, classes = classes.classes;
                return $$animateJs(element, event, classes, options);
            }
        } ];
    } ], $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
        var ONE_SPACE = " ", rules = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        function getEventData(options) {
            return {
                addClass: options.addClass,
                removeClass: options.removeClass,
                from: options.from,
                to: options.to
            };
        }
        function hasMatchingClasses(newClassString, currentClassString) {
            if (newClassString && currentClassString) {
                var currentClassMap = function(keys) {
                    if (!keys) return null;
                    var keys = keys.split(ONE_SPACE), map = Object.create(null);
                    return forEach(keys, function(key) {
                        map[key] = !0;
                    }), map;
                }(currentClassString);
                return newClassString.split(ONE_SPACE).some(function(className) {
                    return currentClassMap[className];
                });
            }
        }
        function isAllowed(ruleType, currentAnimation, previousAnimation) {
            return rules[ruleType].some(function(fn) {
                return fn(currentAnimation, previousAnimation);
            });
        }
        function hasAnimationClasses(b, and) {
            var a = 0 < (b.addClass || "").length, b = 0 < (b.removeClass || "").length;
            return and ? a && b : a || b;
        }
        rules.join.push(function(newAnimation, currentAnimation) {
            return !newAnimation.structural && hasAnimationClasses(newAnimation);
        }), rules.skip.push(function(newAnimation, currentAnimation) {
            return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        }), rules.skip.push(function(newAnimation, currentAnimation) {
            return "leave" === currentAnimation.event && newAnimation.structural;
        }), rules.skip.push(function(newAnimation, currentAnimation) {
            return currentAnimation.structural && 2 === currentAnimation.state && !newAnimation.structural;
        }), rules.cancel.push(function(newAnimation, currentAnimation) {
            return currentAnimation.structural && newAnimation.structural;
        }), rules.cancel.push(function(newAnimation, currentAnimation) {
            return 2 === currentAnimation.state && newAnimation.structural;
        }), rules.cancel.push(function(cA, cR) {
            if (cR.structural) return !1;
            var nA = cA.addClass, nR = cA.removeClass, cA = cR.addClass, cR = cR.removeClass;
            return !(isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR)) && (hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA));
        }), this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$Map", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function($$rAF, $rootScope, $rootElement, $document, returnTrue, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden) {
            var activeAnimationsLookup = new returnTrue(), disabledElementsLookup = new returnTrue(), animationsEnabled = null;
            function removeFromDisabledElementsLookup(evt) {
                disabledElementsLookup.delete(evt.target);
            }
            var deregisterWatch = $rootScope.$watch(function() {
                return 0 === $templateRequest.totalPendingRequests;
            }, function(isEmpty) {
                isEmpty && (deregisterWatch(), $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        null === animationsEnabled && (animationsEnabled = !0);
                    });
                }));
            }), callbackRegistry = Object.create(null), customFilter = $animateProvider.customFilter(), classNameFilter = $animateProvider.classNameFilter(), returnTrue = function() {
                return !0;
            }, isAnimatableByFilter = customFilter || returnTrue, isAnimatableClassName = classNameFilter ? function(node, className) {
                className = [ node.getAttribute("class"), className.addClass, className.removeClass ].join(" ");
                return classNameFilter.test(className);
            } : returnTrue, applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            function normalizeAnimationDetails(element, animation) {
                return mergeAnimationDetails(element, animation, {});
            }
            var contains = window.Node.prototype.contains || function(arg) {
                return this === arg || !!(16 & this.compareDocumentPosition(arg));
            };
            function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                    return !(entry.node === containerNode && (!matchCallback || entry.callback === matchCallback));
                });
            }
            function cleanupEventListeners(phase, node) {
                "close" !== phase || node.parentNode || $animate.off(node);
            }
            var $animate = {
                on: function(event, container, callback) {
                    var node = extractElementNode(container);
                    callbackRegistry[event] = callbackRegistry[event] || [], callbackRegistry[event].push({
                        node: node,
                        callback: callback
                    }), jqLite(container).on("$destroy", function() {
                        activeAnimationsLookup.get(node) || $animate.off(event, container, callback);
                    });
                },
                off: function(event, container, callback) {
                    if (1 !== arguments.length || isString(event)) {
                        var entries = callbackRegistry[event];
                        entries && (callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback));
                    } else for (var eventType in container = event, callbackRegistry) callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                },
                pin: function(element, parentElement) {
                    assertArg(isElement(element), "element", "not an element"), assertArg(isElement(parentElement), "parentElement", "not an element"), 
                    element.data("$ngAnimatePin", parentElement);
                },
                push: function(element, event, options, domOperation) {
                    return (options = options || {}).domOperation = domOperation, function(originalElement, event, hasExistingAnimation) {
                        var options = copy(hasExistingAnimation), element = stripCommentsFromElement(originalElement), node = getDomNode(element), parentNode = node && node.parentNode;
                        options = prepareAnimationOptions(options);
                        var runner = new $$AnimateRunner(), runInNextPostDigestOrNow = function() {
                            var postDigestCalled = !1;
                            return function(fn) {
                                postDigestCalled ? fn() : $rootScope.$$postDigest(function() {
                                    postDigestCalled = !0, fn();
                                });
                            };
                        }();
                        isArray(options.addClass) && (options.addClass = options.addClass.join(" "));
                        options.addClass && !isString(options.addClass) && (options.addClass = null);
                        isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" "));
                        options.removeClass && !isString(options.removeClass) && (options.removeClass = null);
                        options.from && !isObject(options.from) && (options.from = null);
                        options.to && !isObject(options.to) && (options.to = null);
                        if (!(animationsEnabled && node && isAnimatableByFilter(node, event, hasExistingAnimation) && isAnimatableClassName(node, options))) return close(), 
                        runner;
                        var isStructural = 0 <= [ "enter", "move", "leave" ].indexOf(event), newAnimation = $$isDocumentHidden(), skipAnimations = newAnimation || disabledElementsLookup.get(node), existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {}, hasExistingAnimation = !!existingAnimation.state;
                        skipAnimations || hasExistingAnimation && 1 === existingAnimation.state || (skipAnimations = !function(node, parentNode) {
                            var animateChildren, bodyNode = $document[0].body, rootNode = getDomNode($rootElement), bodyNodeDetected = node === bodyNode || "HTML" === node.nodeName, rootNodeDetected = node === rootNode, parentAnimationDetected = !1, elementDisabled = disabledElementsLookup.get(node), parentHost = jqLite.data(node, "$ngAnimatePin");
                            parentHost && (parentNode = getDomNode(parentHost));
                            for (;parentNode && (rootNodeDetected = rootNodeDetected || parentNode === rootNode, 
                            parentNode.nodeType === ELEMENT_NODE); ) {
                                var value = activeAnimationsLookup.get(parentNode) || {};
                                if (!parentAnimationDetected) {
                                    var parentNodeDisabled = disabledElementsLookup.get(parentNode);
                                    if (!0 === parentNodeDisabled && !1 !== elementDisabled) {
                                        elementDisabled = !0;
                                        break;
                                    }
                                    !1 === parentNodeDisabled && (elementDisabled = !1), parentAnimationDetected = value.structural;
                                }
                                if (!isUndefined(animateChildren) && !0 !== animateChildren || (value = jqLite.data(parentNode, "$$ngAnimateChildren"), 
                                isDefined(value) && (animateChildren = value)), parentAnimationDetected && !1 === animateChildren) break;
                                if ((bodyNodeDetected = bodyNodeDetected || parentNode === bodyNode) && rootNodeDetected) break;
                                parentNode = rootNodeDetected || !(parentHost = jqLite.data(parentNode, "$ngAnimatePin")) ? parentNode.parentNode : getDomNode(parentHost);
                            }
                            return (!parentAnimationDetected || animateChildren) && !0 !== elementDisabled && rootNodeDetected && bodyNodeDetected;
                        }(node, parentNode));
                        if (skipAnimations) return newAnimation && notifyProgress(runner, event, "start", getEventData(options)), 
                        close(), newAnimation && notifyProgress(runner, event, "close", getEventData(options)), 
                        runner;
                        isStructural && function(children) {
                            children = children.querySelectorAll("[data-ng-animate]"), forEach(children, function(child) {
                                var state = parseInt(child.getAttribute("data-ng-animate"), 10), animationDetails = activeAnimationsLookup.get(child);
                                if (animationDetails) switch (state) {
                                  case 2:
                                    animationDetails.runner.end();

                                  case 1:
                                    activeAnimationsLookup.delete(child);
                                }
                            });
                        }(node);
                        newAnimation = {
                            structural: isStructural,
                            element: element,
                            event: event,
                            addClass: options.addClass,
                            removeClass: options.removeClass,
                            close: close,
                            options: options,
                            runner: runner
                        };
                        if (hasExistingAnimation) {
                            if (isAllowed("skip", newAnimation, existingAnimation)) return 2 === existingAnimation.state ? (close(), 
                            runner) : (mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner);
                            var isValidAnimation = isAllowed("cancel", newAnimation, existingAnimation);
                            if (isValidAnimation) if (2 === existingAnimation.state) existingAnimation.runner.end(); else {
                                if (!existingAnimation.structural) return mergeAnimationDetails(element, existingAnimation, newAnimation), 
                                existingAnimation.runner;
                                existingAnimation.close();
                            } else if (isAllowed("join", newAnimation, existingAnimation)) {
                                if (2 !== existingAnimation.state) return function(element, event, options) {
                                    var classes = "";
                                    event && (classes = pendClasses(event, EVENT_CLASS_PREFIX, !0)), options.addClass && (classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX))), 
                                    (classes = options.removeClass ? concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)) : classes).length && (options.preparationClasses = classes, 
                                    element.addClass(classes));
                                }(element, isStructural ? event : null, options), event = newAnimation.event = existingAnimation.event, 
                                options = mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner;
                                normalizeAnimationDetails(element, newAnimation);
                            }
                        } else normalizeAnimationDetails(element, newAnimation);
                        isValidAnimation = newAnimation.structural;
                        isValidAnimation = isValidAnimation || ("animate" === newAnimation.event && 0 < Object.keys(newAnimation.options.to || {}).length || hasAnimationClasses(newAnimation));
                        if (!isValidAnimation) return close(), clearElementAnimationState(node), runner;
                        var counter = (existingAnimation.counter || 0) + 1;
                        return newAnimation.counter = counter, markElementAnimationState(node, 1, newAnimation), 
                        $rootScope.$$postDigest(function() {
                            element = stripCommentsFromElement(originalElement);
                            var animationCancelled = !(realRunner = activeAnimationsLookup.get(node)), realRunner = realRunner || {}, isValidAnimation = 0 < (element.parent() || []).length && ("animate" === realRunner.event || realRunner.structural || hasAnimationClasses(realRunner));
                            if (animationCancelled || realRunner.counter !== counter || !isValidAnimation) return animationCancelled && (applyAnimationClasses(element, options), 
                            applyAnimationStyles(element, options)), (animationCancelled || isStructural && realRunner.event !== event) && (options.domOperation(), 
                            runner.end()), void (isValidAnimation || clearElementAnimationState(node));
                            event = !realRunner.structural && hasAnimationClasses(realRunner, !0) ? "setClass" : realRunner.event, 
                            markElementAnimationState(node, 2);
                            realRunner = $$animation(element, event, realRunner.options);
                            runner.setHost(realRunner), notifyProgress(runner, event, "start", getEventData(options)), 
                            realRunner.done(function(animationDetails) {
                                close(!animationDetails);
                                animationDetails = activeAnimationsLookup.get(node);
                                animationDetails && animationDetails.counter === counter && clearElementAnimationState(node), 
                                notifyProgress(runner, event, "close", getEventData(options));
                            });
                        }), runner;
                        function notifyProgress(runner, event, phase, data) {
                            runInNextPostDigestOrNow(function() {
                                var callbacks = function(targetParentNode, targetNode, event) {
                                    var matches = [], entries = callbackRegistry[event];
                                    return entries && forEach(entries, function(entry) {
                                        (contains.call(entry.node, targetNode) || "leave" === event && contains.call(entry.node, targetParentNode)) && matches.push(entry.callback);
                                    }), matches;
                                }(parentNode, node, event);
                                callbacks.length ? $$rAF(function() {
                                    forEach(callbacks, function(callback) {
                                        callback(element, phase, data);
                                    }), cleanupEventListeners(phase, node);
                                }) : cleanupEventListeners(phase, node);
                            }), runner.progress(event, phase, data);
                        }
                        function close(reject) {
                            !function(element, options) {
                                options.preparationClasses && (element.removeClass(options.preparationClasses), 
                                options.preparationClasses = null), options.activeClasses && (element.removeClass(options.activeClasses), 
                                options.activeClasses = null);
                            }(element, options), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                            options.domOperation(), runner.complete(!reject);
                        }
                    }(element, event, options);
                },
                enabled: function(element, bool) {
                    var node, argCount = arguments.length;
                    return 0 === argCount ? bool = !!animationsEnabled : isElement(element) ? (node = getDomNode(element), 
                    1 === argCount ? bool = !disabledElementsLookup.get(node) : (disabledElementsLookup.has(node) || jqLite(element).on("$destroy", removeFromDisabledElementsLookup), 
                    disabledElementsLookup.set(node, !bool))) : bool = animationsEnabled = !!element, 
                    bool;
                }
            };
            return $animate;
            function clearElementAnimationState(node) {
                node.removeAttribute("data-ng-animate"), activeAnimationsLookup.delete(node);
            }
            function markElementAnimationState(node, oldValue, newValue) {
                (newValue = newValue || {}).state = oldValue, node.setAttribute("data-ng-animate", oldValue);
                oldValue = activeAnimationsLookup.get(node), newValue = oldValue ? extend(oldValue, newValue) : newValue;
                activeAnimationsLookup.set(node, newValue);
            }
        } ];
    } ], $$AnimationProvider = [ "$animateProvider", function($animateProvider) {
        var drivers = this.drivers = [], RUNNER_STORAGE_KEY = "$$animationRunner";
        function getRunner(element) {
            return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$Map", "$$rAFScheduler", "$$animateCache", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler, $$animateCache) {
            var animationQueue = [], applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            function sortAnimations(animations) {
                for (var tree = {
                    children: []
                }, lookup = new $$Map(), i = 0; i < animations.length; i++) {
                    var animation = animations[i];
                    lookup.set(animation.domNode, animations[i] = {
                        domNode: animation.domNode,
                        element: animation.element,
                        fn: animation.fn,
                        children: []
                    });
                }
                for (i = 0; i < animations.length; i++) !function processNode(entry) {
                    if (entry.processed) return entry;
                    entry.processed = !0;
                    var elementNode = entry.domNode;
                    var parentNode = elementNode.parentNode;
                    lookup.set(elementNode, entry);
                    var parentEntry;
                    for (;parentNode; ) {
                        if (parentEntry = lookup.get(parentNode)) {
                            parentEntry.processed || (parentEntry = processNode(parentEntry));
                            break;
                        }
                        parentNode = parentNode.parentNode;
                    }
                    (parentEntry || tree).children.push(entry);
                    return entry;
                }(animations[i]);
                return function(tree) {
                    var i, result = [], queue = [];
                    for (i = 0; i < tree.children.length; i++) queue.push(tree.children[i]);
                    var remainingLevelEntries = queue.length, nextLevelEntries = 0, row = [];
                    for (i = 0; i < queue.length; i++) {
                        var entry = queue[i];
                        remainingLevelEntries <= 0 && (remainingLevelEntries = nextLevelEntries, nextLevelEntries = 0, 
                        result.push(row), row = []), row.push(entry), entry.children.forEach(function(childEntry) {
                            nextLevelEntries++, queue.push(childEntry);
                        }), remainingLevelEntries--;
                    }
                    row.length && result.push(row);
                    return result;
                }(tree);
            }
            return function(element, event, options) {
                options = prepareAnimationOptions(options);
                var isStructural = 0 <= [ "enter", "move", "leave" ].indexOf(event), runner = new $$AnimateRunner({
                    end: function() {
                        close();
                    },
                    cancel: function() {
                        close(!0);
                    }
                });
                if (!drivers.length) return close(), runner;
                var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass)), tempClasses = options.tempClasses;
                return tempClasses && (classes += " " + tempClasses, options.tempClasses = null), 
                isStructural && element.data("$$animatePrepareClasses", "ng-" + event + "-prepare"), 
                function(element, runner) {
                    element.data(RUNNER_STORAGE_KEY, runner);
                }(element, runner), animationQueue.push({
                    element: element,
                    classes: classes,
                    event: event,
                    structural: isStructural,
                    options: options,
                    beforeStart: function() {
                        tempClasses = (tempClasses ? tempClasses + " " : "") + "ng-animate", $$jqLite.addClass(element, tempClasses);
                        var prepareClassName = element.data("$$animatePrepareClasses");
                        prepareClassName && ($$jqLite.removeClass(element, prepareClassName), prepareClassName = null);
                    },
                    close: close
                }), element.on("$destroy", handleDestroyedElement), 1 < animationQueue.length || $rootScope.$$postDigest(function() {
                    var animations = [];
                    forEach(animationQueue, function(entry) {
                        getRunner(entry.element) ? animations.push(entry) : entry.close();
                    }), animationQueue.length = 0;
                    var groupedAnimations = function(animations) {
                        var preparedAnimations = [], refLookup = {};
                        forEach(animations, function(animation, index) {
                            var anchorNodes, anchors, direction, node = getDomNode(animation.element), enterOrMove = animation.event, enterOrMove = 0 <= [ "enter", "move" ].indexOf(enterOrMove), anchorNodes = animation.structural ? (anchorNodes = (anchorNodes = node).hasAttribute("ng-animate-ref") ? [ anchorNodes ] : anchorNodes.querySelectorAll("[ng-animate-ref]"), 
                            anchors = [], forEach(anchorNodes, function(node) {
                                var attr = node.getAttribute("ng-animate-ref");
                                attr && attr.length && anchors.push(node);
                            }), anchors) : [];
                            anchorNodes.length ? (direction = enterOrMove ? "to" : "from", forEach(anchorNodes, function(anchor) {
                                var key = anchor.getAttribute("ng-animate-ref");
                                refLookup[key] = refLookup[key] || {}, refLookup[key][direction] = {
                                    animationID: index,
                                    element: jqLite(anchor)
                                };
                            })) : preparedAnimations.push(animation);
                        });
                        var usedIndicesLookup = {}, anchorGroups = {};
                        return forEach(refLookup, function(group, key) {
                            var fromAnimation, toAnimation, lookupKey, index = group.from, indexKey = group.to;
                            index && indexKey ? (fromAnimation = animations[index.animationID], toAnimation = animations[indexKey.animationID], 
                            lookupKey = index.animationID.toString(), anchorGroups[lookupKey] || ((group = anchorGroups[lookupKey] = {
                                structural: !0,
                                beforeStart: function() {
                                    fromAnimation.beforeStart(), toAnimation.beforeStart();
                                },
                                close: function() {
                                    fromAnimation.close(), toAnimation.close();
                                },
                                classes: function(a, b) {
                                    a = a.split(" "), b = b.split(" ");
                                    for (var matches = [], i = 0; i < a.length; i++) {
                                        var aa = a[i];
                                        if ("ng-" !== aa.substring(0, 3)) for (var j = 0; j < b.length; j++) if (aa === b[j]) {
                                            matches.push(aa);
                                            break;
                                        }
                                    }
                                    return matches.join(" ");
                                }(fromAnimation.classes, toAnimation.classes),
                                from: fromAnimation,
                                to: toAnimation,
                                anchors: []
                            }).classes.length ? preparedAnimations.push(group) : (preparedAnimations.push(fromAnimation), 
                            preparedAnimations.push(toAnimation))), anchorGroups[lookupKey].anchors.push({
                                out: index.element,
                                in: indexKey.element
                            })) : (indexKey = (index = (index || indexKey).animationID).toString(), usedIndicesLookup[indexKey] || (usedIndicesLookup[indexKey] = !0, 
                            preparedAnimations.push(animations[index])));
                        }), preparedAnimations;
                    }(animations), toBeSortedAnimations = [];
                    forEach(groupedAnimations, function(animationEntry) {
                        var element = (animationEntry.from || animationEntry).element, extraClasses = ((extraClasses = options.addClass) ? extraClasses + " " : "") + "ng-animate", cacheKey = $$animateCache.cacheKey(element[0], animationEntry.event, extraClasses, options.removeClass);
                        toBeSortedAnimations.push({
                            element: element,
                            domNode: getDomNode(element),
                            fn: function() {
                                var operation, animation, newRunner, closeFn = animationEntry.close;
                                function update(runner) {
                                    runner = getRunner(runner);
                                    runner && runner.setHost(newRunner);
                                }
                                $$animateCache.containsCachedAnimationWithoutDuration(cacheKey) ? closeFn() : (animationEntry.beforeStart(), 
                                !getRunner(animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element) || (operation = function(animationDetails) {
                                    for (var i = drivers.length - 1; 0 <= i; i--) {
                                        var driver = drivers[i], driver = $injector.get(driver)(animationDetails);
                                        if (driver) return driver;
                                    }
                                }(animationEntry)) && (animation = operation.start), animation ? ((animation = animation()).done(function(status) {
                                    closeFn(!status);
                                }), newRunner = animation, (animation = animationEntry).from && animation.to ? (update(animation.from.element), 
                                update(animation.to.element)) : update(animation.element)) : closeFn());
                            }
                        });
                    });
                    for (var finalAnimations = sortAnimations(toBeSortedAnimations), i = 0; i < finalAnimations.length; i++) for (var innerArray = finalAnimations[i], j = 0; j < innerArray.length; j++) {
                        var prepareClassName = innerArray[j], element = prepareClassName.element;
                        finalAnimations[i][j] = prepareClassName.fn, 0 !== i ? (prepareClassName = element.data("$$animatePrepareClasses")) && $$jqLite.addClass(element, prepareClassName) : element.removeData("$$animatePrepareClasses");
                    }
                    $$rAFScheduler(finalAnimations);
                }), runner;
                function handleDestroyedElement() {
                    var runner = getRunner(element);
                    !runner || "leave" === event && options.$$domOperationFired || runner.end();
                }
                function close(rejected) {
                    element.off("$destroy", handleDestroyedElement), function(element) {
                        element.removeData(RUNNER_STORAGE_KEY);
                    }(element), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                    options.domOperation(), tempClasses && $$jqLite.removeClass(element, tempClasses), 
                    runner.complete(!rejected);
                }
            };
        } ];
    } ];
    angular.module("ngAnimate", [], function() {
        noop = angular.noop, copy = angular.copy, extend = angular.extend, jqLite = angular.element, 
        forEach = angular.forEach, isArray = angular.isArray, isString = angular.isString, 
        isObject = angular.isObject, isUndefined = angular.isUndefined, isDefined = angular.isDefined, 
        isFunction = angular.isFunction, isElement = angular.isElement;
    }).info({
        angularVersion: "1.8.2"
    }).directive("ngAnimateSwap", [ "$animate", function($animate) {
        return {
            restrict: "A",
            transclude: "element",
            terminal: !0,
            priority: 550,
            link: function(scope, $element, attrs, ctrl, $transclude) {
                var previousElement, previousScope;
                scope.$watchCollection(attrs.ngAnimateSwap || attrs.for, function(value) {
                    previousElement && $animate.leave(previousElement), previousScope && (previousScope.$destroy(), 
                    previousScope = null), !value && 0 !== value || $transclude(function(clone, childScope) {
                        previousElement = clone, previousScope = childScope, $animate.enter(clone, null, $element);
                    });
                });
            }
        };
    } ]).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", [ "$$rAF", function($$rAF) {
        var queue, cancelFn;
        function scheduler(tasks) {
            queue = queue.concat(tasks), nextTick();
        }
        return queue = scheduler.queue = [], scheduler.waitUntilQuiet = function(fn) {
            cancelFn && cancelFn(), cancelFn = $$rAF(function() {
                cancelFn = null, fn(), nextTick();
            });
        }, scheduler;
        function nextTick() {
            if (queue.length) {
                for (var items = queue.shift(), i = 0; i < items.length; i++) items[i]();
                cancelFn || $$rAF(function() {
                    cancelFn || nextTick();
                });
            }
        }
    } ]).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animateCache", function() {
        var KEY = "$$ngAnimateParentKey", parentCounter = 0, cache = Object.create(null);
        this.$get = [ function() {
            return {
                cacheKey: function(parts, method, addClass, removeClass) {
                    var parentNode = parts.parentNode, parts = [ parentNode[KEY] || (parentNode[KEY] = ++parentCounter), method, parts.getAttribute("class") ];
                    return addClass && parts.push(addClass), removeClass && parts.push(removeClass), 
                    parts.join(" ");
                },
                containsCachedAnimationWithoutDuration: function(entry) {
                    entry = cache[entry];
                    return entry && !entry.isValid || !1;
                },
                flush: function() {
                    cache = Object.create(null);
                },
                count: function(entry) {
                    entry = cache[entry];
                    return entry ? entry.total : 0;
                },
                get: function(entry) {
                    entry = cache[entry];
                    return entry && entry.value;
                },
                put: function(key, value, isValid) {
                    cache[key] ? (cache[key].total++, cache[key].value = value) : cache[key] = {
                        total: 1,
                        value: value,
                        isValid: isValid
                    };
                }
            };
        } ];
    }).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
}(window, window.angular), function(angular) {
    "use strict";
    var $resourceMinErr = angular.$$minErr("$resource"), MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
    function lookupDottedPath(obj, path) {
        if (!function(path) {
            return null != path && "" !== path && "hasOwnProperty" !== path && MEMBER_NAME_REGEX.test("." + path);
        }(path)) throw $resourceMinErr("badmember", 'Dotted member path "@{0}" is invalid.', path);
        for (var keys = path.split("."), i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {
            var key = keys[i];
            obj = null !== obj ? obj[key] : void 0;
        }
        return obj;
    }
    function shallowClearAndCopy(src, dst) {
        for (var key in dst = dst || {}, angular.forEach(dst, function(value, key) {
            delete dst[key];
        }), src) !src.hasOwnProperty(key) || "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
        return dst;
    }
    angular.module("ngResource", [ "ng" ]).info({
        angularVersion: "1.8.2"
    }).provider("$resource", function() {
        var PROTOCOL_AND_IPV6_REGEX = /^https?:\/\/\[[^\]]*][^/]*/, provider = this;
        this.defaults = {
            stripTrailingSlashes: !0,
            cancellable: !1,
            actions: {
                get: {
                    method: "GET"
                },
                save: {
                    method: "POST"
                },
                query: {
                    method: "GET",
                    isArray: !0
                },
                remove: {
                    method: "DELETE"
                },
                delete: {
                    method: "DELETE"
                }
            }
        }, this.$get = [ "$http", "$log", "$q", "$timeout", function($http, $log, $q, $timeout) {
            var noop = angular.noop, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, isArray = angular.isArray, isDefined = angular.isDefined, isFunction = angular.isFunction, isNumber = angular.isNumber, encodeUriQuery = angular.$$encodeUriQuery, encodeUriSegment = angular.$$encodeUriSegment;
            function Route(template, defaults) {
                this.template = template, this.defaults = extend({}, provider.defaults, defaults), 
                this.urlParams = {};
            }
            return Route.prototype = {
                setUrlParams: function(config, params, actionUrl) {
                    var val, encodedVal, self = this, url = actionUrl || self.template, protocolAndIpv6 = "", urlParams = self.urlParams = Object.create(null);
                    forEach(url.split(/\W/), function(param) {
                        if ("hasOwnProperty" === param) throw $resourceMinErr("badname", "hasOwnProperty is not a valid parameter name.");
                        !new RegExp("^\\d+$").test(param) && param && new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url) && (urlParams[param] = {
                            isQueryParamValue: new RegExp("\\?.*=:" + param + "(?:\\W|$)").test(url)
                        });
                    }), url = (url = url.replace(/\\:/g, ":")).replace(PROTOCOL_AND_IPV6_REGEX, function(match) {
                        return protocolAndIpv6 = match, "";
                    }), params = params || {}, forEach(self.urlParams, function(paramInfo, urlParam) {
                        val = (params.hasOwnProperty(urlParam) ? params : self.defaults)[urlParam], url = isDefined(val) && null !== val ? (encodedVal = paramInfo.isQueryParamValue ? encodeUriQuery(val, !0) : encodeUriSegment(val), 
                        url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                            return encodedVal + p1;
                        })) : url.replace(new RegExp("(/?):" + urlParam + "(\\W|$)", "g"), function(match, leadingSlashes, tail) {
                            return "/" === tail.charAt(0) ? tail : leadingSlashes + tail;
                        });
                    }), url = (url = self.defaults.stripTrailingSlashes ? url.replace(/\/+$/, "") || "/" : url).replace(/\/\.(?=\w+($|\?))/, "."), 
                    config.url = protocolAndIpv6 + url.replace(/\/(\\|%5C)\./, "/."), forEach(params, function(value, key) {
                        self.urlParams[key] || (config.params = config.params || {}, config.params[key] = value);
                    });
                }
            }, function(url, paramDefaults, actions, options) {
                var route = new Route(url, options);
                function defaultResponseInterceptor(response) {
                    return response.resource;
                }
                function Resource(value) {
                    shallowClearAndCopy(value || {}, this);
                }
                return actions = extend({}, provider.defaults.actions, actions), Resource.prototype.toJSON = function() {
                    var data = extend({}, this);
                    return delete data.$promise, delete data.$resolved, delete data.$cancelRequest, 
                    data;
                }, forEach(actions, function(action, name) {
                    var hasBody = !0 === action.hasBody || !1 !== action.hasBody && /^(POST|PUT|PATCH)$/i.test(action.method), numericTimeout = action.timeout, cancellable = (isDefined(action.cancellable) ? action : route.defaults).cancellable;
                    numericTimeout && !isNumber(numericTimeout) && ($log.debug("ngResource:\n  Only numeric values are allowed as `timeout`.\n  Promises are not supported in $resource, because the same value would be used for multiple requests. If you are looking for a way to cancel requests, you should use the `cancellable` option."), 
                    delete action.timeout, numericTimeout = null), Resource[name] = function(a1, a2, a3, a4) {
                        var data, onSuccess, onError, params = {};
                        switch (arguments.length) {
                          case 4:
                            onError = a4, onSuccess = a3;

                          case 3:
                          case 2:
                            if (!isFunction(a2)) {
                                params = a1, data = a2, onSuccess = a3;
                                break;
                            }
                            if (isFunction(a1)) {
                                onSuccess = a1, onError = a2;
                                break;
                            }
                            onSuccess = a2, onError = a3;

                          case 1:
                            isFunction(a1) ? onSuccess = a1 : hasBody ? data = a1 : params = a1;
                            break;

                          case 0:
                            break;

                          default:
                            throw $resourceMinErr("badargs", "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length);
                        }
                        var timeoutDeferred, numericTimeoutPromise, response, isInstanceCall = this instanceof Resource, value = isInstanceCall ? data : action.isArray ? [] : new Resource(data), httpConfig = {}, requestInterceptor = action.interceptor && action.interceptor.request || void 0, requestErrorInterceptor = action.interceptor && action.interceptor.requestError || void 0, responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor, responseErrorInterceptor = action.interceptor && action.interceptor.responseError || $q.reject, successCallback = onSuccess ? function(val) {
                            onSuccess(val, response.headers, response.status, response.statusText);
                        } : void 0, errorCallback = onError || void 0;
                        forEach(action, function(value, key) {
                            switch (key) {
                              default:
                                httpConfig[key] = copy(value);
                                break;

                              case "params":
                              case "isArray":
                              case "interceptor":
                              case "cancellable":
                            }
                        }), !isInstanceCall && cancellable && (timeoutDeferred = $q.defer(), httpConfig.timeout = timeoutDeferred.promise, 
                        numericTimeout && (numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout))), 
                        hasBody && (httpConfig.data = data), route.setUrlParams(httpConfig, extend({}, function(data, actionParams) {
                            var ids = {};
                            return actionParams = extend({}, paramDefaults, actionParams), forEach(actionParams, function(value, key) {
                                isFunction(value) && (value = value(data)), ids[key] = value && value.charAt && "@" === value.charAt(0) ? lookupDottedPath(data, value.substr(1)) : value;
                            }), ids;
                        }(data, action.params || {}), params), action.url);
                        var promise = $q.resolve(httpConfig).then(requestInterceptor).catch(requestErrorInterceptor).then($http);
                        return (promise = (promise = promise.then(function(resp) {
                            var promise, data = resp.data;
                            if (data) {
                                if (isArray(data) !== !!action.isArray) throw $resourceMinErr("badcfg", "Error in resource configuration for action `{0}`. Expected response to contain an {1} but got an {2} (Request: {3} {4})", name, action.isArray ? "array" : "object", isArray(data) ? "array" : "object", httpConfig.method, httpConfig.url);
                                action.isArray ? (value.length = 0, forEach(data, function(item) {
                                    "object" == typeof item ? value.push(new Resource(item)) : value.push(item);
                                })) : (promise = value.$promise, shallowClearAndCopy(data, value), value.$promise = promise);
                            }
                            return resp.resource = value, responseInterceptor(response = resp);
                        }, function(rejectionOrResponse) {
                            return rejectionOrResponse.resource = value, responseErrorInterceptor(response = rejectionOrResponse);
                        })).finally(function() {
                            value.$resolved = !0, !isInstanceCall && cancellable && (value.$cancelRequest = noop, 
                            $timeout.cancel(numericTimeoutPromise), timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null);
                        })).then(successCallback, errorCallback), isInstanceCall ? promise : (value.$promise = promise, 
                        value.$resolved = !1, cancellable && (value.$cancelRequest = function(value) {
                            promise.catch(noop), null !== timeoutDeferred && timeoutDeferred.resolve(value);
                        }), value);
                    }, Resource.prototype["$" + name] = function(params, success, result) {
                        isFunction(params) && (result = success, success = params, params = {});
                        result = Resource[name].call(this, params, this, success, result);
                        return result.$promise || result;
                    };
                }), Resource;
            };
        } ];
    });
}((window, window.angular)), angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.transition", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdownToggle", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead" ]), 
angular.module("ui.bootstrap.tpls", [ "template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/popup.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html" ]), 
angular.module("ui.bootstrap.transition", []).factory("$transition", [ "$q", "$timeout", "$rootScope", function($q, $timeout, $rootScope) {
    var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer(), endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"], transitionEndHandler = function(event) {
            $rootScope.$apply(function() {
                element.unbind(endEventName, transitionEndHandler), deferred.resolve(element);
            });
        };
        return endEventName && element.bind(endEventName, transitionEndHandler), $timeout(function() {
            angular.isString(trigger) ? element.addClass(trigger) : angular.isFunction(trigger) ? trigger(element) : angular.isObject(trigger) && element.css(trigger), 
            endEventName || deferred.resolve(element);
        }), deferred.promise.cancel = function() {
            endEventName && element.unbind(endEventName, transitionEndHandler), deferred.reject("Transition cancelled");
        }, deferred.promise;
    }, transElement = document.createElement("trans");
    function findEndEventName(endEventNames) {
        for (var name in endEventNames) if (void 0 !== transElement.style[name]) return endEventNames[name];
    }
    return $transition.transitionEndEventName = findEndEventName({
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
    }), $transition.animationEndEventName = findEndEventName({
        WebkitTransition: "webkitAnimationEnd",
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        transition: "animationend"
    }), $transition;
} ]), angular.module("ui.bootstrap.collapse", [ "ui.bootstrap.transition" ]).directive("collapse", [ "$transition", function($transition, $timeout) {
    return {
        link: function(scope, element, attrs) {
            var currentTransition, initialAnimSkip = !0;
            function doTransition(change) {
                var newTransition = $transition(element, change);
                return currentTransition && currentTransition.cancel(), (currentTransition = newTransition).then(newTransitionDone, newTransitionDone), 
                newTransition;
                function newTransitionDone() {
                    currentTransition === newTransition && (currentTransition = void 0);
                }
            }
            function expandDone() {
                element.removeClass("collapsing"), element.addClass("collapse in"), element.css({
                    height: "auto"
                });
            }
            function collapseDone() {
                element.removeClass("collapsing"), element.addClass("collapse");
            }
            scope.$watch(attrs.collapse, function(shouldCollapse) {
                shouldCollapse ? initialAnimSkip ? (initialAnimSkip = !1, collapseDone(), element.css({
                    height: 0
                })) : (element.css({
                    height: element[0].scrollHeight + "px"
                }), element[0].offsetWidth, element.removeClass("collapse in").addClass("collapsing"), 
                doTransition({
                    height: 0
                }).then(collapseDone)) : initialAnimSkip ? (initialAnimSkip = !1, expandDone()) : (element.removeClass("collapse").addClass("collapsing"), 
                doTransition({
                    height: element[0].scrollHeight + "px"
                }).then(expandDone));
            });
        }
    };
} ]), angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse" ]).constant("accordionConfig", {
    closeOthers: !0
}).controller("AccordionController", [ "$scope", "$attrs", "accordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [], this.closeOthers = function(openGroup) {
        (angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers) && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1);
        });
    }, this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope), groupScope.$on("$destroy", function(event) {
            that.removeGroup(groupScope);
        });
    }, this.removeGroup = function(group) {
        -1 !== this.groups.indexOf(group) && this.groups.splice(this.groups.indexOf(group), 1);
    };
} ]).directive("accordion", function() {
    return {
        restrict: "EA",
        controller: "AccordionController",
        transclude: !0,
        replace: !1,
        templateUrl: "template/accordion/accordion.html"
    };
}).directive("accordionGroup", [ "$parse", function($parse) {
    return {
        require: "^accordion",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/accordion/accordion-group.html",
        scope: {
            heading: "@"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, getIsOpen, accordionCtrl) {
            var setIsOpen;
            accordionCtrl.addGroup(scope), scope.isOpen = !1, getIsOpen.isOpen && (getIsOpen = $parse(getIsOpen.isOpen), 
            setIsOpen = getIsOpen.assign, scope.$parent.$watch(getIsOpen, function(value) {
                scope.isOpen = !!value;
            })), scope.$watch("isOpen", function(value) {
                value && accordionCtrl.closeOthers(scope), setIsOpen && setIsOpen(scope.$parent, value);
            });
        }
    };
} ]).directive("accordionHeading", function() {
    return {
        restrict: "EA",
        transclude: !0,
        template: "",
        replace: !0,
        require: "^accordionGroup",
        compile: function(element, attr, transclude) {
            return function(scope, element, attr, accordionGroupCtrl) {
                accordionGroupCtrl.setHeading(transclude(scope, function() {}));
            };
        }
    };
}).directive("accordionTransclude", function() {
    return {
        require: "^accordionGroup",
        link: function(scope, element, attr, controller) {
            scope.$watch(function() {
                return controller[attr.accordionTransclude];
            }, function(heading) {
                heading && (element.html(""), element.append(heading));
            });
        }
    };
}), angular.module("ui.bootstrap.alert", []).controller("AlertController", [ "$scope", "$attrs", function($scope, $attrs) {
    $scope.closeable = "close" in $attrs;
} ]).directive("alert", function() {
    return {
        restrict: "EA",
        controller: "AlertController",
        templateUrl: "template/alert/alert.html",
        transclude: !0,
        replace: !0,
        scope: {
            type: "=",
            close: "&"
        }
    };
}), angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function() {
    return function(scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe), scope.$watch(attr.bindHtmlUnsafe, function(value) {
            element.html(value || "");
        });
    };
}), angular.module("ui.bootstrap.buttons", []).constant("buttonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("ButtonsController", [ "buttonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active", this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("btnRadio", function() {
    return {
        require: [ "btnRadio", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                element.hasClass(buttonsCtrl.activeClass) || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio)), ngModelCtrl.$render();
                });
            });
        }
    };
}).directive("btnCheckbox", function() {
    return {
        require: [ "btnCheckbox", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getCheckboxValue(val, defaultValue) {
                val = scope.$eval(val);
                return angular.isDefined(val) ? val : defaultValue;
            }
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getCheckboxValue(attrs.btnCheckboxFalse, !1) : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
}), angular.module("ui.bootstrap.carousel", [ "ui.bootstrap.transition" ]).controller("CarouselController", [ "$scope", "$timeout", "$transition", "$q", function($scope, $timeout, $transition, $q) {
    var currentTimeout, isPlaying, self = this, slides = self.slides = [], currentIndex = -1;
    self.currentSlide = null;
    var destroyed = !1;
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        !isNaN(interval) && 0 <= interval && (currentTimeout = $timeout(timerFn, interval));
    }
    function resetTimer() {
        currentTimeout && ($timeout.cancel(currentTimeout), currentTimeout = null);
    }
    function timerFn() {
        isPlaying ? ($scope.next(), restartTimer()) : $scope.pause();
    }
    self.select = function(nextSlide, direction) {
        var nextIndex = slides.indexOf(nextSlide);
        function goNext() {
            var next, current;
            destroyed || (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element ? (nextSlide.$element.addClass(direction), 
            nextSlide.$element[0].offsetWidth, angular.forEach(slides, function(slide) {
                angular.extend(slide, {
                    direction: "",
                    entering: !1,
                    leaving: !1,
                    active: !1
                });
            }), angular.extend(nextSlide, {
                direction: direction,
                active: !0,
                entering: !0
            }), angular.extend(self.currentSlide || {}, {
                direction: direction,
                leaving: !0
            }), $scope.$currentTransition = $transition(nextSlide.$element, {}), next = nextSlide, 
            current = self.currentSlide, $scope.$currentTransition.then(function() {
                transitionDone(next, current);
            }, function() {
                transitionDone(next, current);
            })) : transitionDone(nextSlide, self.currentSlide), self.currentSlide = nextSlide, 
            currentIndex = nextIndex, restartTimer());
        }
        function transitionDone(next, current) {
            angular.extend(next, {
                direction: "",
                active: !0,
                leaving: !1,
                entering: !1
            }), angular.extend(current || {}, {
                direction: "",
                active: !1,
                leaving: !1,
                entering: !1
            }), $scope.$currentTransition = null;
        }
        void 0 === direction && (direction = currentIndex < nextIndex ? "next" : "prev"), 
        nextSlide && nextSlide !== self.currentSlide && ($scope.$currentTransition ? ($scope.$currentTransition.cancel(), 
        $timeout(goNext)) : goNext());
    }, $scope.$on("$destroy", function() {
        destroyed = !0;
    }), self.indexOfSlide = function(slide) {
        return slides.indexOf(slide);
    }, $scope.next = function() {
        var newIndex = (currentIndex + 1) % slides.length;
        if (!$scope.$currentTransition) return self.select(slides[newIndex], "next");
    }, $scope.prev = function() {
        var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;
        if (!$scope.$currentTransition) return self.select(slides[newIndex], "prev");
    }, $scope.select = function(slide) {
        self.select(slide);
    }, $scope.isActive = function(slide) {
        return self.currentSlide === slide;
    }, $scope.slides = function() {
        return slides;
    }, $scope.$watch("interval", restartTimer), $scope.$on("$destroy", resetTimer), 
    $scope.play = function() {
        isPlaying || (isPlaying = !0, restartTimer());
    }, $scope.pause = function() {
        $scope.noPause || (isPlaying = !1, resetTimer());
    }, self.addSlide = function(slide, element) {
        slide.$element = element, slides.push(slide), 1 === slides.length || slide.active ? (self.select(slides[slides.length - 1]), 
        1 == slides.length && $scope.play()) : slide.active = !1;
    }, self.removeSlide = function(slide) {
        var index = slides.indexOf(slide);
        slides.splice(index, 1), 0 < slides.length && slide.active ? index >= slides.length ? self.select(slides[index - 1]) : self.select(slides[index]) : index < currentIndex && currentIndex--;
    };
} ]).directive("carousel", [ function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        controller: "CarouselController",
        require: "carousel",
        templateUrl: "template/carousel/carousel.html",
        scope: {
            interval: "=",
            noTransition: "=",
            noPause: "="
        }
    };
} ]).directive("slide", [ "$parse", function($parse) {
    return {
        require: "^carousel",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/carousel/slide.html",
        scope: {},
        link: function(scope, element, attrs, carouselCtrl) {
            var getActive, setActive, lastValue;
            attrs.active && (getActive = $parse(attrs.active), setActive = getActive.assign, 
            lastValue = scope.active = getActive(scope.$parent), scope.$watch(function() {
                var parentActive = getActive(scope.$parent);
                return parentActive !== scope.active && (parentActive !== lastValue ? lastValue = scope.active = parentActive : setActive(scope.$parent, parentActive = lastValue = scope.active)), 
                parentActive;
            })), carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            }), scope.$watch("active", function(active) {
                active && carouselCtrl.select(scope);
            });
        }
    };
} ]), angular.module("ui.bootstrap.position", []).factory("$position", [ "$document", "$window", function($document, $window) {
    function isStaticPositioned(el) {
        return "static" === (cssprop = "position", ((el = el).currentStyle || ($window.getComputedStyle ? $window.getComputedStyle(el) : el.style))[cssprop] || "static");
        var cssprop;
    }
    return {
        position: function(element) {
            var elBCR = this.offset(element), offsetParentBCR = {
                top: 0,
                left: 0
            }, boundingClientRect = function(element) {
                for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
                return offsetParent || docDomEl;
            }(element[0]);
            boundingClientRect != $document[0] && ((offsetParentBCR = this.offset(angular.element(boundingClientRect))).top += boundingClientRect.clientTop - boundingClientRect.scrollTop, 
            offsetParentBCR.left += boundingClientRect.clientLeft - boundingClientRect.scrollLeft);
            boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        },
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)
            };
        }
    };
} ]), angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.position" ]).constant("datepickerConfig", {
    dayFormat: "dd",
    monthFormat: "MMMM",
    yearFormat: "yyyy",
    dayHeaderFormat: "EEE",
    dayTitleFormat: "MMMM yyyy",
    monthTitleFormat: "yyyy",
    showWeeks: !0,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null
}).controller("DatepickerController", [ "$scope", "$attrs", "dateFilter", "datepickerConfig", function($scope, $attrs, dateFilter, dtConfig) {
    var format = {
        day: getValue($attrs.dayFormat, dtConfig.dayFormat),
        month: getValue($attrs.monthFormat, dtConfig.monthFormat),
        year: getValue($attrs.yearFormat, dtConfig.yearFormat),
        dayHeader: getValue($attrs.dayHeaderFormat, dtConfig.dayHeaderFormat),
        dayTitle: getValue($attrs.dayTitleFormat, dtConfig.dayTitleFormat),
        monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)
    }, startingDay = getValue($attrs.startingDay, dtConfig.startingDay), yearRange = getValue($attrs.yearRange, dtConfig.yearRange);
    function getValue(value, defaultValue) {
        return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;
    }
    function makeDate(date, format, isSelected, isSecondary) {
        return {
            date: date,
            label: dateFilter(date, format),
            selected: !!isSelected,
            secondary: !!isSecondary
        };
    }
    this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null, this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null, 
    this.modes = [ {
        name: "day",
        getVisibleDates: function(date, selected) {
            var year = date.getFullYear(), month = date.getMonth(), firstDate = new Date(year, month, 1), numDisplayedFromPreviousMonth = startingDay - firstDate.getDay(), numDisplayedFromPreviousMonth = 0 < numDisplayedFromPreviousMonth ? 7 - numDisplayedFromPreviousMonth : -numDisplayedFromPreviousMonth, firstDate = new Date(firstDate), numDates = 0;
            0 < numDisplayedFromPreviousMonth && (firstDate.setDate(1 - numDisplayedFromPreviousMonth), 
            numDates += numDisplayedFromPreviousMonth), numDates += function(year, month) {
                return new Date(year, month, 0).getDate();
            }(year, month + 1);
            for (var days = function(startDate, n) {
                for (var dates = new Array(n), current = startDate, i = 0; i < n; ) dates[i++] = new Date(current), 
                current.setDate(current.getDate() + 1);
                return dates;
            }(firstDate, numDates += (7 - numDates % 7) % 7), labels = new Array(7), i = 0; i < numDates; i++) {
                var dt = new Date(days[i]);
                days[i] = makeDate(dt, format.day, selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear(), dt.getMonth() !== month);
            }
            for (var j = 0; j < 7; j++) labels[j] = dateFilter(days[j].date, format.dayHeader);
            return {
                objects: days,
                title: dateFilter(date, format.dayTitle),
                labels: labels
            };
        },
        compare: function(date1, date2) {
            return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        },
        split: 7,
        step: {
            months: 1
        }
    }, {
        name: "month",
        getVisibleDates: function(date, selected) {
            for (var months = new Array(12), year = date.getFullYear(), i = 0; i < 12; i++) {
                var dt = new Date(year, i, 1);
                months[i] = makeDate(dt, format.month, selected && selected.getMonth() === i && selected.getFullYear() === year);
            }
            return {
                objects: months,
                title: dateFilter(date, format.monthTitle)
            };
        },
        compare: function(date1, date2) {
            return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
        },
        split: 3,
        step: {
            years: 1
        }
    }, {
        name: "year",
        getVisibleDates: function(year, selected) {
            for (var years = new Array(yearRange), year = year.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1, i = 0; i < yearRange; i++) {
                var dt = new Date(startYear + i, 0, 1);
                years[i] = makeDate(dt, format.year, selected && selected.getFullYear() === dt.getFullYear());
            }
            return {
                objects: years,
                title: [ years[0].label, years[yearRange - 1].label ].join(" - ")
            };
        },
        compare: function(date1, date2) {
            return date1.getFullYear() - date2.getFullYear();
        },
        split: 5,
        step: {
            years: yearRange
        }
    } ], this.isDisabled = function(date, currentMode) {
        currentMode = this.modes[currentMode || 0];
        return this.minDate && currentMode.compare(date, this.minDate) < 0 || this.maxDate && 0 < currentMode.compare(date, this.maxDate) || $scope.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: currentMode.name
        });
    };
} ]).directive("datepicker", [ "dateFilter", "$parse", "datepickerConfig", "$log", function(dateFilter, $parse, datepickerConfig, $log) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/datepicker.html",
        scope: {
            dateDisabled: "&"
        },
        require: [ "datepicker", "?^ngModel" ],
        controller: "DatepickerController",
        link: function(scope, element, attrs, ctrls) {
            var mode, selected, showWeeks, datepickerCtrl = ctrls[0], ngModel = ctrls[1];
            function updateShowWeekNumbers() {
                scope.showWeekNumbers = 0 === mode && showWeeks;
            }
            function refill(currentMode) {
                var date = null, data = !0;
                ngModel.$modelValue && (date = new Date(ngModel.$modelValue), isNaN(date) ? (data = !1, 
                $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : currentMode && (selected = date)), 
                ngModel.$setValidity("date", data);
                currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);
                angular.forEach(data.objects, function(obj) {
                    obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);
                }), ngModel.$setValidity("date-disabled", !date || !datepickerCtrl.isDisabled(date)), 
                scope.rows = function(arr, size) {
                    for (var arrays = []; 0 < arr.length; ) arrays.push(arr.splice(0, size));
                    return arrays;
                }(data.objects, currentMode.split), scope.labels = data.labels || [], scope.title = data.title;
            }
            function setMode(value) {
                mode = value, updateShowWeekNumbers(), refill();
            }
            ngModel && (mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks, 
            attrs.showWeeks ? scope.$parent.$watch($parse(attrs.showWeeks), function(value) {
                showWeeks = !!value, updateShowWeekNumbers();
            }) : updateShowWeekNumbers(), attrs.min && scope.$parent.$watch($parse(attrs.min), function(value) {
                datepickerCtrl.minDate = value ? new Date(value) : null, refill();
            }), attrs.max && scope.$parent.$watch($parse(attrs.max), function(value) {
                datepickerCtrl.maxDate = value ? new Date(value) : null, refill();
            }), ngModel.$render = function() {
                refill(!0);
            }, scope.select = function(date) {
                var dt;
                0 === mode ? ((dt = ngModel.$modelValue ? new Date(ngModel.$modelValue) : new Date(0, 0, 0, 0, 0, 0, 0)).setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), 
                ngModel.$setViewValue(dt), refill(!0)) : (selected = date, setMode(mode - 1));
            }, scope.move = function(direction) {
                var step = datepickerCtrl.modes[mode].step;
                selected.setMonth(selected.getMonth() + direction * (step.months || 0)), selected.setFullYear(selected.getFullYear() + direction * (step.years || 0)), 
                refill();
            }, scope.toggleMode = function() {
                setMode((mode + 1) % datepickerCtrl.modes.length);
            }, scope.getWeekNumber = function(row) {
                return 0 === mode && scope.showWeekNumbers && 7 === row.length ? function(time) {
                    var checkDate = new Date(time);
                    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                    time = checkDate.getTime();
                    return checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
                }(row[0].date) : null;
            });
        }
    };
} ]).constant("datepickerPopupConfig", {
    dateFormat: "yyyy-MM-dd",
    currentText: "Today",
    toggleWeeksText: "Weeks",
    clearText: "Clear",
    closeText: "Done",
    closeOnDateSelection: !0,
    appendToBody: !1,
    showButtonBar: !0
}).directive("datepickerPopup", [ "$compile", "$parse", "$document", "$position", "dateFilter", "datepickerPopupConfig", "datepickerConfig", function($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig, datepickerConfig) {
    return {
        restrict: "EA",
        require: "ngModel",
        link: function(originalScope, element, attrs, ngModel) {
            var dateFormat, setIsOpen, scope = originalScope.$new(), closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? originalScope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? originalScope.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
            function setOpen(value) {
                setIsOpen ? setIsOpen(originalScope, !!value) : scope.isOpen = !!value;
            }
            attrs.$observe("datepickerPopup", function(value) {
                dateFormat = value || datepickerPopupConfig.dateFormat, ngModel.$render();
            }), scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? originalScope.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar, 
            originalScope.$on("$destroy", function() {
                $popup.remove(), scope.$destroy();
            }), attrs.$observe("currentText", function(text) {
                scope.currentText = angular.isDefined(text) ? text : datepickerPopupConfig.currentText;
            }), attrs.$observe("toggleWeeksText", function(text) {
                scope.toggleWeeksText = angular.isDefined(text) ? text : datepickerPopupConfig.toggleWeeksText;
            }), attrs.$observe("clearText", function(text) {
                scope.clearText = angular.isDefined(text) ? text : datepickerPopupConfig.clearText;
            }), attrs.$observe("closeText", function(text) {
                scope.closeText = angular.isDefined(text) ? text : datepickerPopupConfig.closeText;
            }), attrs.isOpen && (datepickerOptions = $parse(attrs.isOpen), setIsOpen = datepickerOptions.assign, 
            originalScope.$watch(datepickerOptions, function(value) {
                scope.isOpen = !!value;
            })), scope.isOpen = !!datepickerOptions && datepickerOptions(originalScope);
            function documentClickBind(event) {
                scope.isOpen && event.target !== element[0] && scope.$apply(function() {
                    setOpen(!1);
                });
            }
            function elementFocusBind() {
                scope.$apply(function() {
                    setOpen(!0);
                });
            }
            var popupEl = angular.element("<div datepicker-popup-wrap><div datepicker></div></div>");
            popupEl.attr({
                "ng-model": "date",
                "ng-change": "dateSelection()"
            });
            var datepickerEl = angular.element(popupEl.children()[0]), datepickerOptions = {};
            function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {
                attribute && (originalScope.$watch($parse(attribute), function(value) {
                    scope[scopeProperty] = value;
                }), datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty));
            }
            attrs.datepickerOptions && (datepickerOptions = originalScope.$eval(attrs.datepickerOptions), 
            datepickerEl.attr(angular.extend({}, datepickerOptions))), ngModel.$parsers.unshift(function(date) {
                if (!date) return ngModel.$setValidity("date", !0), null;
                if (angular.isDate(date)) return ngModel.$setValidity("date", !0), date;
                if (angular.isString(date)) {
                    date = new Date(date);
                    if (!isNaN(date)) return ngModel.$setValidity("date", !0), date;
                    ngModel.$setValidity("date", !1);
                } else ngModel.$setValidity("date", !1);
            }), scope.dateSelection = function(dt) {
                angular.isDefined(dt) && (scope.date = dt), ngModel.$setViewValue(scope.date), ngModel.$render(), 
                closeOnDateSelection && setOpen(!1);
            }, element.bind("input change keyup", function() {
                scope.$apply(function() {
                    scope.date = ngModel.$modelValue;
                });
            }), ngModel.$render = function() {
                var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : "";
                element.val(date), scope.date = ngModel.$modelValue;
            }, addWatchableAttribute(attrs.min, "min"), addWatchableAttribute(attrs.max, "max"), 
            attrs.showWeeks ? addWatchableAttribute(attrs.showWeeks, "showWeeks", "show-weeks") : (scope.showWeeks = "show-weeks" in datepickerOptions ? datepickerOptions["show-weeks"] : datepickerConfig.showWeeks, 
            datepickerEl.attr("show-weeks", "showWeeks")), attrs.dateDisabled && datepickerEl.attr("date-disabled", attrs.dateDisabled);
            var documentBindingInitialized = !1, elementFocusInitialized = !1;
            scope.$watch("isOpen", function(value) {
                value ? (scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
                scope.position.top = scope.position.top + element.prop("offsetHeight"), $document.bind("click", documentClickBind), 
                elementFocusInitialized && element.unbind("focus", elementFocusBind), element[0].focus(), 
                documentBindingInitialized = !0) : (documentBindingInitialized && $document.unbind("click", documentClickBind), 
                element.bind("focus", elementFocusBind), elementFocusInitialized = !0), setIsOpen && setIsOpen(originalScope, value);
            }), scope.today = function() {
                scope.dateSelection(new Date());
            }, scope.clear = function() {
                scope.dateSelection(null);
            };
            var $popup = $compile(popupEl)(scope);
            appendToBody ? $document.find("body").append($popup) : element.after($popup);
        }
    };
} ]).directive("datepickerPopupWrap", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        templateUrl: "template/datepicker/popup.html",
        link: function(scope, element, attrs) {
            element.bind("click", function(event) {
                event.preventDefault(), event.stopPropagation();
            });
        }
    };
}), angular.module("ui.bootstrap.dropdownToggle", []).directive("dropdownToggle", [ "$document", "$location", function($document, $location) {
    var openElement = null, closeMenu = angular.noop;
    return {
        restrict: "CA",
        link: function(scope, element, attrs) {
            scope.$watch("$location.path", function() {
                closeMenu();
            }), element.parent().bind("click", function() {
                closeMenu();
            }), element.bind("click", function(event) {
                var elementWasOpen = element === openElement;
                event.preventDefault(), event.stopPropagation(), openElement && closeMenu(), elementWasOpen || element.hasClass("disabled") || element.prop("disabled") || (element.parent().addClass("open"), 
                openElement = element, closeMenu = function(event) {
                    event && (event.preventDefault(), event.stopPropagation()), $document.unbind("click", closeMenu), 
                    element.parent().removeClass("open"), closeMenu = angular.noop, openElement = null;
                }, $document.bind("click", closeMenu));
            });
        }
    };
} ]), angular.module("ui.bootstrap.modal", [ "ui.bootstrap.transition" ]).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key == stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key == stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.splice(stack.length - 1, 1)[0];
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}).directive("modalBackdrop", [ "$timeout", function($timeout) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/modal/backdrop.html",
        link: function(scope) {
            scope.animate = !1, $timeout(function() {
                scope.animate = !0;
            });
        }
    };
} ]).directive("modalWindow", [ "$modalStack", "$timeout", function($modalStack, $timeout) {
    return {
        restrict: "EA",
        scope: {
            index: "@",
            animate: "="
        },
        replace: !0,
        transclude: !0,
        templateUrl: "template/modal/window.html",
        link: function(scope, element, attrs) {
            scope.windowClass = attrs.windowClass || "", $timeout(function() {
                scope.animate = !0, element[0].focus();
            }), scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" != modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            };
        }
    };
} ]).factory("$modalStack", [ "$transition", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
    var backdropDomEl, backdropScope, openedWindows = $$stackedMap.createNew(), $modalStack = {};
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex;
    }
    function removeModalWindow(modalInstance) {
        var body = $document.find("body").eq(0), modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance), removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, checkRemoveBackdrop), 
        body.toggleClass("modal-open", 0 < openedWindows.length());
    }
    function checkRemoveBackdrop() {
        var backdropScopeRef;
        backdropDomEl && -1 == backdropIndex() && (removeAfterAnimate(backdropDomEl, backdropScopeRef = backdropScope, 150, function() {
            backdropScopeRef.$destroy(), backdropScopeRef = null;
        }), backdropScope = backdropDomEl = void 0);
    }
    function removeAfterAnimate(domEl, scope, emulateTime, done) {
        scope.animate = !1;
        var timeout, transitionEndEventName = $transition.transitionEndEventName;
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, domEl.remove(), done && done());
        }
        transitionEndEventName ? (timeout = $timeout(afterAnimating, emulateTime), domEl.bind(transitionEndEventName, function() {
            $timeout.cancel(timeout), afterAnimating(), scope.$apply();
        })) : $timeout(afterAnimating, 0);
    }
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.bind("keydown", function(evt) {
        var modal;
        27 === evt.which && (modal = openedWindows.top()) && modal.value.keyboard && $rootScope.$apply(function() {
            $modalStack.dismiss(modal.key);
        });
    }), $modalStack.open = function(angularDomEl, modalDomEl) {
        openedWindows.add(angularDomEl, {
            deferred: modalDomEl.deferred,
            modalScope: modalDomEl.scope,
            backdrop: modalDomEl.backdrop,
            keyboard: modalDomEl.keyboard
        });
        var body = $document.find("body").eq(0), angularDomEl = backdropIndex();
        0 <= angularDomEl && !backdropDomEl && ((backdropScope = $rootScope.$new(!0)).index = angularDomEl, 
        backdropDomEl = $compile("<div modal-backdrop></div>")(backdropScope), body.append(backdropDomEl));
        angularDomEl = angular.element("<div modal-window></div>");
        angularDomEl.attr("window-class", modalDomEl.windowClass), angularDomEl.attr("index", openedWindows.length() - 1), 
        angularDomEl.attr("animate", "animate"), angularDomEl.html(modalDomEl.content);
        modalDomEl = $compile(angularDomEl)(modalDomEl.scope);
        openedWindows.top().value.modalDomEl = modalDomEl, body.append(modalDomEl), body.addClass("modal-open");
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance).value;
        modalWindow && (modalWindow.deferred.resolve(result), removeModalWindow(modalInstance));
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        modalWindow && (modalWindow.deferred.reject(reason), removeModalWindow(modalInstance));
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal; ) this.dismiss(topModal.key, reason), 
        topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack;
} ]).provider("$modal", function() {
    var $modalProvider = {
        options: {
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
            var $modal = {};
            return $modal.open = function(modalOptions) {
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    close: function(result) {
                        $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if ((modalOptions = angular.extend({}, $modalProvider.options, modalOptions)).resolve = modalOptions.resolve || {}, 
                !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of template or templateUrl options is required.");
                var promisesArr, templateAndResolvePromise, templateAndResolvePromise = $q.all([ (templateAndResolvePromise = modalOptions).template ? $q.when(templateAndResolvePromise.template) : $http.get(templateAndResolvePromise.templateUrl, {
                    cache: $templateCache
                }).then(function(result) {
                    return result.data;
                }) ].concat((templateAndResolvePromise = modalOptions.resolve, promisesArr = [], 
                angular.forEach(templateAndResolvePromise, function(value, key) {
                    (angular.isFunction(value) || angular.isArray(value)) && promisesArr.push($q.when($injector.invoke(value)));
                }), promisesArr)));
                return templateAndResolvePromise.then(function(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss;
                    var ctrlLocals = {}, resolveIter = 1;
                    modalOptions.controller && (ctrlLocals.$scope = modalScope, ctrlLocals.$modalInstance = modalInstance, 
                    angular.forEach(modalOptions.resolve, function(value, key) {
                        ctrlLocals[key] = tplAndVars[resolveIter++];
                    }), $controller(modalOptions.controller, ctrlLocals)), $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        content: tplAndVars[0],
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        windowClass: modalOptions.windowClass
                    });
                }, function(reason) {
                    modalResultDeferred.reject(reason);
                }), templateAndResolvePromise.then(function() {
                    modalOpenedDeferred.resolve(!0);
                }, function() {
                    modalOpenedDeferred.reject(!1);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("ui.bootstrap.pagination", []).controller("PaginationController", [ "$scope", "$attrs", "$parse", "$interpolate", function($scope, $attrs, $parse, $interpolate) {
    var self = this, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(defaultItemsPerPage) {
        $attrs.itemsPerPage ? $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10), $scope.totalPages = self.calculateTotalPages();
        }) : this.itemsPerPage = defaultItemsPerPage;
    }, this.noPrevious = function() {
        return 1 === this.page;
    }, this.noNext = function() {
        return this.page === $scope.totalPages;
    }, this.isActive = function(page) {
        return this.page === page;
    }, this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    }, this.getAttributeValue = function(attribute, defaultValue, interpolate) {
        return angular.isDefined(attribute) ? interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute) : defaultValue;
    }, this.render = function() {
        this.page = parseInt($scope.page, 10) || 1, 0 < this.page && this.page <= $scope.totalPages && ($scope.pages = this.getPages(this.page, $scope.totalPages));
    }, $scope.selectPage = function(page) {
        !self.isActive(page) && 0 < page && page <= $scope.totalPages && ($scope.page = page, 
        $scope.onSelectPage({
            page: page
        }));
    }, $scope.$watch("page", function() {
        self.render();
    }), $scope.$watch("totalItems", function() {
        $scope.totalPages = self.calculateTotalPages();
    }), $scope.$watch("totalPages", function(value) {
        setNumPages($scope.$parent, value), self.page > value ? $scope.selectPage(value) : self.render();
    });
} ]).constant("paginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0
}).directive("pagination", [ "$parse", "paginationConfig", function($parse, config) {
    return {
        restrict: "EA",
        scope: {
            page: "=",
            totalItems: "=",
            onSelectPage: " &"
        },
        controller: "PaginationController",
        templateUrl: "template/pagination/pagination.html",
        replace: !0,
        link: function(scope, element, attrs, paginationCtrl) {
            var maxSize, boundaryLinks = paginationCtrl.getAttributeValue(attrs.boundaryLinks, config.boundaryLinks), directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks), firstText = paginationCtrl.getAttributeValue(attrs.firstText, config.firstText, !0), previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, !0), nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, !0), lastText = paginationCtrl.getAttributeValue(attrs.lastText, config.lastText, !0), rotate = paginationCtrl.getAttributeValue(attrs.rotate, config.rotate);
            function makePage(number, text, isActive, isDisabled) {
                return {
                    number: number,
                    text: text,
                    active: isActive,
                    disabled: isDisabled
                };
            }
            paginationCtrl.init(config.itemsPerPage), attrs.maxSize && scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                maxSize = parseInt(value, 10), paginationCtrl.render();
            }), paginationCtrl.getPages = function(currentPage, lastPage) {
                var pages = [], startPage = 1, endPage = lastPage, isMaxSized = angular.isDefined(maxSize) && maxSize < lastPage;
                isMaxSized && (rotate ? lastPage < (endPage = (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1)) + maxSize - 1) && (startPage = (endPage = lastPage) - maxSize + 1) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
                endPage = Math.min(startPage + maxSize - 1, lastPage)));
                for (var nextPageSet, firstPage, number = startPage; number <= endPage; number++) {
                    var page = makePage(number, number, paginationCtrl.isActive(number), !1);
                    pages.push(page);
                }
                return isMaxSized && !rotate && (1 < startPage && (nextPageSet = makePage(startPage - 1, "...", !1, !1), 
                pages.unshift(nextPageSet)), endPage < lastPage && (nextPageSet = makePage(endPage + 1, "...", !1, !1), 
                pages.push(nextPageSet))), directionLinks && (firstPage = makePage(currentPage - 1, previousText, !1, paginationCtrl.noPrevious()), 
                pages.unshift(firstPage), firstPage = makePage(currentPage + 1, nextText, !1, paginationCtrl.noNext()), 
                pages.push(firstPage)), boundaryLinks && (firstPage = makePage(1, firstText, !1, paginationCtrl.noPrevious()), 
                pages.unshift(firstPage), lastPage = makePage(lastPage, lastText, !1, paginationCtrl.noNext()), 
                pages.push(lastPage)), pages;
            };
        }
    };
} ]).constant("pagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: !0
}).directive("pager", [ "pagerConfig", function(config) {
    return {
        restrict: "EA",
        scope: {
            page: "=",
            totalItems: "=",
            onSelectPage: " &"
        },
        controller: "PaginationController",
        templateUrl: "template/pagination/pager.html",
        replace: !0,
        link: function(scope, element, attrs, paginationCtrl) {
            var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, !0), nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, !0), align = paginationCtrl.getAttributeValue(attrs.align, config.align);
            function makePage(number, text, isDisabled, isPrevious, isNext) {
                return {
                    number: number,
                    text: text,
                    disabled: isDisabled,
                    previous: align && isPrevious,
                    next: align && isNext
                };
            }
            paginationCtrl.init(config.itemsPerPage), paginationCtrl.getPages = function(currentPage) {
                return [ makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), !0, !1), makePage(currentPage + 1, nextText, paginationCtrl.noNext(), !1, !0) ];
            };
        }
    };
} ]), angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).provider("$tooltip", function() {
    var defaultOptions = {
        placement: "top",
        animation: !0,
        popupDelay: 0
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        focus: "blur"
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$parse", "$document", "$position", "$interpolate", function($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
        return function(type, prefix, defaultTriggerShow) {
            var options = angular.extend({}, defaultOptions, globalOptions);
            function getTriggers(show) {
                show = show || options.trigger || defaultTriggerShow;
                return {
                    show: show,
                    hide: triggerMap[show] || show
                };
            }
            var directiveName = type.replace(/[A-Z]/g, function(letter, pos) {
                return (pos ? "-" : "") + letter.toLowerCase();
            }), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup title="' + startSym + "tt_title" + endSym + '" content="' + startSym + "tt_content" + endSym + '" placement="' + startSym + "tt_placement" + endSym + '" animation="tt_animation" is-open="tt_isOpen"></div>';
            return {
                restrict: "EA",
                scope: !0,
                compile: function(tElem, tAttrs) {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs) {
                        var tooltip, transitionTimeout, popupTimeout, appendToBody = !!angular.isDefined(options.appendToBody) && options.appendToBody, triggers = getTriggers(void 0), hasRegisteredTriggers = !1, hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), positionTooltip = function() {
                            var ttPosition, position = appendToBody ? $position.offset(element) : $position.position(element), ttWidth = tooltip.prop("offsetWidth"), ttHeight = tooltip.prop("offsetHeight");
                            switch (scope.tt_placement) {
                              case "right":
                                ttPosition = {
                                    top: position.top + position.height / 2 - ttHeight / 2,
                                    left: position.left + position.width
                                };
                                break;

                              case "bottom":
                                ttPosition = {
                                    top: position.top + position.height,
                                    left: position.left + position.width / 2 - ttWidth / 2
                                };
                                break;

                              case "left":
                                ttPosition = {
                                    top: position.top + position.height / 2 - ttHeight / 2,
                                    left: position.left - ttWidth
                                };
                                break;

                              default:
                                ttPosition = {
                                    top: position.top - ttHeight,
                                    left: position.left + position.width / 2 - ttWidth / 2
                                };
                            }
                            ttPosition.top += "px", ttPosition.left += "px", tooltip.css(ttPosition);
                        };
                        function toggleTooltipBind() {
                            (scope.tt_isOpen ? hideTooltipBind : showTooltipBind)();
                        }
                        function showTooltipBind() {
                            hasEnableExp && !scope.$eval(attrs[prefix + "Enable"]) || (scope.tt_popupDelay ? (popupTimeout = $timeout(show, scope.tt_popupDelay, !1)).then(function(reposition) {
                                reposition();
                            }) : show()());
                        }
                        function hideTooltipBind() {
                            scope.$apply(function() {
                                hide();
                            });
                        }
                        function show() {
                            return scope.tt_content ? (tooltip && removeTooltip(), tooltip = tooltipLinker(scope, function() {}), 
                            scope.$digest(), transitionTimeout && $timeout.cancel(transitionTimeout), tooltip.css({
                                top: 0,
                                left: 0,
                                display: "block"
                            }), appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip), 
                            positionTooltip(), scope.tt_isOpen = !0, scope.$digest(), positionTooltip) : angular.noop;
                        }
                        function hide() {
                            scope.tt_isOpen = !1, $timeout.cancel(popupTimeout), scope.tt_animation ? transitionTimeout = $timeout(removeTooltip, 500) : removeTooltip();
                        }
                        function removeTooltip() {
                            tooltip && (tooltip.remove(), tooltip = null);
                        }
                        scope.tt_isOpen = !1, attrs.$observe(type, function(val) {
                            !(scope.tt_content = val) && scope.tt_isOpen && hide();
                        }), attrs.$observe(prefix + "Title", function(val) {
                            scope.tt_title = val;
                        }), attrs.$observe(prefix + "Placement", function(val) {
                            scope.tt_placement = angular.isDefined(val) ? val : options.placement;
                        }), attrs.$observe(prefix + "PopupDelay", function(delay) {
                            delay = parseInt(delay, 10);
                            scope.tt_popupDelay = isNaN(delay) ? options.popupDelay : delay;
                        });
                        function unregisterTriggers() {
                            hasRegisteredTriggers && (element.unbind(triggers.show, showTooltipBind), element.unbind(triggers.hide, hideTooltipBind));
                        }
                        attrs.$observe(prefix + "Trigger", function(val) {
                            unregisterTriggers(), (triggers = getTriggers(val)).show === triggers.hide ? element.bind(triggers.show, toggleTooltipBind) : (element.bind(triggers.show, showTooltipBind), 
                            element.bind(triggers.hide, hideTooltipBind)), hasRegisteredTriggers = !0;
                        });
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation, 
                        attrs.$observe(prefix + "AppendToBody", function(val) {
                            appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody;
                        }), appendToBody && scope.$on("$locationChangeSuccess", function() {
                            scope.tt_isOpen && hide();
                        }), scope.$on("$destroy", function() {
                            $timeout.cancel(transitionTimeout), $timeout.cancel(popupTimeout), unregisterTriggers(), 
                            removeTooltip();
                        });
                    };
                }
            };
        };
    } ];
}).directive("tooltipPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html"
    };
}).directive("tooltip", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter");
} ]).directive("tooltipHtmlUnsafePopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
    };
}).directive("tooltipHtmlUnsafe", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter");
} ]), angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("popoverPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html"
    };
}).directive("popover", [ "$tooltip", function($tooltip) {
    return $tooltip("popover", "popover", "click");
} ]), angular.module("ui.bootstrap.progressbar", [ "ui.bootstrap.transition" ]).constant("progressConfig", {
    animate: !0,
    max: 100
}).controller("ProgressController", [ "$scope", "$attrs", "progressConfig", "$transition", function($scope, $attrs, progressConfig, $transition) {
    var self = this, bars = [], max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.addBar = function(bar, element) {
        var oldValue = 0, index = bar.$parent.$index;
        angular.isDefined(index) && bars[index] && (oldValue = bars[index].value), bars.push(bar), 
        this.update(element, bar.value, oldValue), bar.$watch("value", function(value, oldValue) {
            value !== oldValue && self.update(element, value, oldValue);
        }), bar.$on("$destroy", function() {
            self.removeBar(bar);
        });
    }, this.update = function(element, percent, oldValue) {
        percent = this.getPercentage(percent);
        animate ? (element.css("width", this.getPercentage(oldValue) + "%"), $transition(element, {
            width: percent + "%"
        })) : element.css({
            transition: "none",
            width: percent + "%"
        });
    }, this.removeBar = function(bar) {
        bars.splice(bars.indexOf(bar), 1);
    }, this.getPercentage = function(value) {
        return Math.round(100 * value / max);
    };
} ]).directive("progress", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        require: "progress",
        scope: {},
        template: '<div class="progress" ng-transclude></div>'
    };
}).directive("bar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        require: "^progress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
}).directive("progressbar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
}), angular.module("ui.bootstrap.rating", []).constant("ratingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null
}).controller("RatingController", [ "$scope", "$attrs", "$parse", "ratingConfig", function($scope, $attrs, $parse, ratingConfig) {
    this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max, 
    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn, 
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff, 
    this.createRateObjects = function(states) {
        for (var defaultOptions = {
            stateOn: this.stateOn,
            stateOff: this.stateOff
        }, i = 0, n = states.length; i < n; i++) states[i] = angular.extend({
            index: i
        }, defaultOptions, states[i]);
        return states;
    }, $scope.range = angular.isDefined($attrs.ratingStates) ? this.createRateObjects(angular.copy($scope.$parent.$eval($attrs.ratingStates))) : this.createRateObjects(new Array(this.maxRange)), 
    $scope.rate = function(value) {
        $scope.value === value || $scope.readonly || ($scope.value = value);
    }, $scope.enter = function(value) {
        $scope.readonly || ($scope.val = value), $scope.onHover({
            value: value
        });
    }, $scope.reset = function() {
        $scope.val = angular.copy($scope.value), $scope.onLeave();
    }, $scope.$watch("value", function(value) {
        $scope.val = value;
    }), $scope.readonly = !1, $attrs.readonly && $scope.$parent.$watch($parse($attrs.readonly), function(value) {
        $scope.readonly = !!value;
    });
} ]).directive("rating", function() {
    return {
        restrict: "EA",
        scope: {
            value: "=",
            onHover: "&",
            onLeave: "&"
        },
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: !0
    };
}), angular.module("ui.bootstrap.tabs", []).controller("TabsetController", [ "$scope", function($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(tab) {
        angular.forEach(tabs, function(tab) {
            tab.active = !1;
        }), tab.active = !0;
    }, ctrl.addTab = function(tab) {
        tabs.push(tab), 1 !== tabs.length && !tab.active || ctrl.select(tab);
    }, ctrl.removeTab = function(newActiveIndex) {
        var index = tabs.indexOf(newActiveIndex);
        newActiveIndex.active && 1 < tabs.length && (newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1, 
        ctrl.select(tabs[newActiveIndex])), tabs.splice(index, 1);
    };
} ]).directive("tabset", function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        scope: {},
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            scope.vertical = !!angular.isDefined(attrs.vertical) && scope.$parent.$eval(attrs.vertical), 
            scope.justified = !!angular.isDefined(attrs.justified) && scope.$parent.$eval(attrs.justified), 
            scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : "tabs";
        }
    };
}).directive("tab", [ "$parse", function($parse) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: !0,
        templateUrl: "template/tabs/tab.html",
        transclude: !0,
        scope: {
            heading: "@",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        compile: function(elm, attrs, transclude) {
            return function(scope, elm, attrs, tabsetCtrl) {
                var getActive, setActive;
                attrs.active ? (getActive = $parse(attrs.active), setActive = getActive.assign, 
                scope.$parent.$watch(getActive, function(value, oldVal) {
                    value !== oldVal && (scope.active = !!value);
                }), scope.active = getActive(scope.$parent)) : setActive = getActive = angular.noop, 
                scope.$watch("active", function(active) {
                    setActive(scope.$parent, active), active ? (tabsetCtrl.select(scope), scope.onSelect()) : scope.onDeselect();
                }), scope.disabled = !1, attrs.disabled && scope.$parent.$watch($parse(attrs.disabled), function(value) {
                    scope.disabled = !!value;
                }), scope.select = function() {
                    scope.disabled || (scope.active = !0);
                }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                    tabsetCtrl.removeTab(scope);
                }), scope.$transcludeFn = transclude;
            };
        }
    };
} ]).directive("tabHeadingTransclude", [ function() {
    return {
        restrict: "A",
        require: "^tab",
        link: function(scope, elm, attrs, tabCtrl) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
} ]).directive("tabContentTransclude", function() {
    return {
        restrict: "A",
        require: "^tabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    !function(node) {
                        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase());
                    }(node) ? elm.append(node) : tab.headingElement = node;
                });
            });
        }
    };
}), angular.module("ui.bootstrap.timepicker", []).constant("timepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: !0,
    meridians: null,
    readonlyInput: !1,
    mousewheel: !0
}).directive("timepicker", [ "$parse", "$log", "timepickerConfig", "$locale", function($parse, $log, timepickerConfig, $locale) {
    return {
        restrict: "EA",
        require: "?^ngModel",
        replace: !0,
        scope: {},
        templateUrl: "template/timepicker/timepicker.html",
        link: function(scope, hoursInputEl, attrs, ngModel) {
            var selected, meridians, hourStep, minuteStep, minutesInputEl, isScrollingUp, invalidate;
            function getHoursFromTemplate() {
                var hours = parseInt(scope.hours, 10);
                if (scope.showMeridian ? 0 < hours && hours < 13 : 0 <= hours && hours < 24) return scope.showMeridian && (12 === hours && (hours = 0), 
                scope.meridian === meridians[1] && (hours += 12)), hours;
            }
            function getMinutesFromTemplate() {
                var minutes = parseInt(scope.minutes, 10);
                return 0 <= minutes && minutes < 60 ? minutes : void 0;
            }
            function pad(value) {
                return angular.isDefined(value) && value.toString().length < 2 ? "0" + value : value;
            }
            function refresh(keyboardChange) {
                makeValid(), ngModel.$setViewValue(new Date(selected)), updateTemplate(keyboardChange);
            }
            function makeValid() {
                ngModel.$setValidity("time", !0), scope.invalidHours = !1, scope.invalidMinutes = !1;
            }
            function updateTemplate(keyboardChange) {
                var hours = selected.getHours(), minutes = selected.getMinutes();
                scope.showMeridian && (hours = 0 === hours || 12 === hours ? 12 : hours % 12), scope.hours = "h" === keyboardChange ? hours : pad(hours), 
                scope.minutes = "m" === keyboardChange ? minutes : pad(minutes), scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
            }
            function addMinutes(dt) {
                dt = new Date(selected.getTime() + 6e4 * dt);
                selected.setHours(dt.getHours(), dt.getMinutes()), refresh();
            }
            ngModel && (selected = new Date(), meridians = angular.isDefined(attrs.meridians) ? scope.$parent.$eval(attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS, 
            hourStep = timepickerConfig.hourStep, attrs.hourStep && scope.$parent.$watch($parse(attrs.hourStep), function(value) {
                hourStep = parseInt(value, 10);
            }), minuteStep = timepickerConfig.minuteStep, attrs.minuteStep && scope.$parent.$watch($parse(attrs.minuteStep), function(value) {
                minuteStep = parseInt(value, 10);
            }), scope.showMeridian = timepickerConfig.showMeridian, attrs.showMeridian && scope.$parent.$watch($parse(attrs.showMeridian), function(minutes) {
                var hours;
                scope.showMeridian = !!minutes, ngModel.$error.time ? (hours = getHoursFromTemplate(), 
                minutes = getMinutesFromTemplate(), angular.isDefined(hours) && angular.isDefined(minutes) && (selected.setHours(hours), 
                refresh())) : updateTemplate();
            }), hoursInputEl = (minutesInputEl = hoursInputEl.find("input")).eq(0), minutesInputEl = minutesInputEl.eq(1), 
            (angular.isDefined(attrs.mousewheel) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel) && (isScrollingUp = function(e) {
                var delta = (e = e.originalEvent ? e.originalEvent : e).wheelDelta || -e.deltaY;
                return e.detail || 0 < delta;
            }, hoursInputEl.bind("mousewheel wheel", function(e) {
                scope.$apply(isScrollingUp(e) ? scope.incrementHours() : scope.decrementHours()), 
                e.preventDefault();
            }), minutesInputEl.bind("mousewheel wheel", function(e) {
                scope.$apply(isScrollingUp(e) ? scope.incrementMinutes() : scope.decrementMinutes()), 
                e.preventDefault();
            })), scope.readonlyInput = angular.isDefined(attrs.readonlyInput) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput, 
            scope.readonlyInput ? (scope.updateHours = angular.noop, scope.updateMinutes = angular.noop) : (invalidate = function(invalidHours, invalidMinutes) {
                ngModel.$setViewValue(null), ngModel.$setValidity("time", !1), angular.isDefined(invalidHours) && (scope.invalidHours = invalidHours), 
                angular.isDefined(invalidMinutes) && (scope.invalidMinutes = invalidMinutes);
            }, scope.updateHours = function() {
                var hours = getHoursFromTemplate();
                angular.isDefined(hours) ? (selected.setHours(hours), refresh("h")) : invalidate(!0);
            }, hoursInputEl.bind("blur", function(e) {
                !scope.validHours && scope.hours < 10 && scope.$apply(function() {
                    scope.hours = pad(scope.hours);
                });
            }), scope.updateMinutes = function() {
                var minutes = getMinutesFromTemplate();
                angular.isDefined(minutes) ? (selected.setMinutes(minutes), refresh("m")) : invalidate(void 0, !0);
            }, minutesInputEl.bind("blur", function(e) {
                !scope.invalidMinutes && scope.minutes < 10 && scope.$apply(function() {
                    scope.minutes = pad(scope.minutes);
                });
            })), ngModel.$render = function() {
                var date = ngModel.$modelValue ? new Date(ngModel.$modelValue) : null;
                isNaN(date) ? (ngModel.$setValidity("time", !1), $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (date && (selected = date), 
                makeValid(), updateTemplate());
            }, scope.incrementHours = function() {
                addMinutes(60 * hourStep);
            }, scope.decrementHours = function() {
                addMinutes(60 * -hourStep);
            }, scope.incrementMinutes = function() {
                addMinutes(minuteStep);
            }, scope.decrementMinutes = function() {
                addMinutes(-minuteStep);
            }, scope.toggleMeridian = function() {
                addMinutes(720 * (selected.getHours() < 12 ? 1 : -1));
            });
        }
    };
} ]), angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).factory("typeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error("Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_' but got '" + input + "'.");
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).directive("typeahead", [ "$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [ 9, 13, 27, 38, 40 ];
    return {
        require: "ngModel",
        link: function(originalScope, element, attrs, modelCtrl) {
            var hasFocus, minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1, waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = !1 !== originalScope.$eval(attrs.typeaheadEditable), isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, onSelectCallback = $parse(attrs.typeaheadOnSelect), inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = !!attrs.typeaheadAppendToBody && $parse(attrs.typeaheadAppendToBody), $setModelValue = $parse(attrs.ngModel).assign, parserResult = typeaheadParser.parse(attrs.typeahead), $popup = angular.element("<div typeahead-popup></div>");
            $popup.attr({
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                query: "query",
                position: "position"
            }), angular.isDefined(attrs.typeaheadTemplateUrl) && $popup.attr("template-url", attrs.typeaheadTemplateUrl);
            var scope = originalScope.$new();
            originalScope.$on("$destroy", function() {
                scope.$destroy();
            });
            function resetMatches() {
                scope.matches = [], scope.activeIdx = -1;
            }
            function getMatchesAsync(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, !0), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    if (inputValue === modelCtrl.$viewValue && hasFocus) {
                        if (0 < matches.length) {
                            scope.activeIdx = 0;
                            for (var i = scope.matches.length = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                            scope.matches.push({
                                label: parserResult.viewMapper(scope, locals),
                                model: matches[i]
                            });
                            scope.query = inputValue, scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
                            scope.position.top = scope.position.top + element.prop("offsetHeight");
                        } else resetMatches();
                        isLoadingSetter(originalScope, !1);
                    }
                }, function() {
                    resetMatches(), isLoadingSetter(originalScope, !1);
                });
            }
            var timeoutPromise;
            resetMatches(), scope.query = void 0, modelCtrl.$parsers.unshift(function(inputValue) {
                return hasFocus = !0, inputValue && inputValue.length >= minSearch ? 0 < waitTime ? (timeoutPromise && $timeout.cancel(timeoutPromise), 
                timeoutPromise = $timeout(function() {
                    getMatchesAsync(inputValue);
                }, waitTime)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
                resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
                inputValue);
            }), modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, locals = {};
                return inputFormatter ? (locals.$model = modelValue, inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
                candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
                candidateViewValue !== parserResult.viewMapper(originalScope, locals) ? candidateViewValue : modelValue);
            }), scope.select = function(model) {
                var item, locals = {};
                locals[parserResult.itemName] = item = scope.matches[model].model, model = parserResult.modelMapper(originalScope, locals), 
                $setModelValue(originalScope, model), modelCtrl.$setValidity("editable", !0), onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                }), resetMatches(), element[0].focus();
            }, element.bind("keydown", function(evt) {
                0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which) && (evt.preventDefault(), 
                40 === evt.which ? (scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, 
                scope.$digest()) : 38 === evt.which ? (scope.activeIdx = (scope.activeIdx || scope.matches.length) - 1, 
                scope.$digest()) : 13 === evt.which || 9 === evt.which ? scope.$apply(function() {
                    scope.select(scope.activeIdx);
                }) : 27 === evt.which && (evt.stopPropagation(), resetMatches(), scope.$digest()));
            }), element.bind("blur", function(evt) {
                hasFocus = !1;
            });
            function dismissClickHandler(evt) {
                element[0] !== evt.target && (resetMatches(), scope.$digest());
            }
            $document.bind("click", dismissClickHandler), originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler);
            });
            $popup = $compile($popup)(scope);
            appendToBody ? $document.find("body").append($popup) : element.after($popup);
        }
    };
} ]).directive("typeaheadPopup", function() {
    return {
        restrict: "EA",
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "=",
            select: "&"
        },
        replace: !0,
        templateUrl: "template/typeahead/typeahead-popup.html",
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                return 0 < scope.matches.length;
            }, scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
        }
    };
}).directive("typeaheadMatch", [ "$http", "$templateCache", "$compile", "$parse", function($http, $templateCache, $compile, $parse) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, tplUrl) {
            tplUrl = $parse(tplUrl.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $http.get(tplUrl, {
                cache: $templateCache
            }).success(function(tplContent) {
                element.replaceWith($compile(tplContent.trim())(scope));
            });
        }
    };
} ]).filter("typeaheadHighlight", function() {
    return function(matchItem, query) {
        return query ? matchItem.replace(new RegExp(query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"), "gi"), "<strong>$&</strong>") : matchItem;
    };
}), angular.module("template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html", '<div class="panel panel-default">\n  <div class="panel-heading">\n    <h4 class="panel-title">\n      <a class="accordion-toggle" ng-click="isOpen = !isOpen" accordion-transclude="heading">{{heading}}</a>\n    </h4>\n  </div>\n  <div class="panel-collapse" collapse="!isOpen">\n\t  <div class="panel-body" ng-transclude></div>\n  </div>\n</div>');
} ]), angular.module("template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion.html", '<div class="panel-group" ng-transclude></div>');
} ]), angular.module("template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/alert/alert.html", "<div class='alert' ng-class='\"alert-\" + (type || \"warning\")'>\n    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\n    <div ng-transclude></div>\n</div>\n");
} ]), angular.module("template/carousel/carousel.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel">\n    <ol class="carousel-indicators" ng-show="slides().length > 1">\n        <li ng-repeat="slide in slides()" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n    </ol>\n    <div class="carousel-inner" ng-transclude></div>\n    <a class="left carousel-control" ng-click="prev()" ng-show="slides().length > 1"><span class="icon-prev"></span></a>\n    <a class="right carousel-control" ng-click="next()" ng-show="slides().length > 1"><span class="icon-next"></span></a>\n</div>\n');
} ]), angular.module("template/carousel/slide.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/slide.html", "<div ng-class=\"{\n    'active': leaving || (active && !entering),\n    'prev': (next || active) && direction=='prev',\n    'next': (next || active) && direction=='next',\n    'right': direction=='prev',\n    'left': direction=='next'\n  }\" class=\"item text-center\" ng-transclude></div>\n");
} ]), angular.module("template/datepicker/datepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html", '<table>\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{rows[0].length - 2 + showWeekNumbers}}"><button type="button" class="btn btn-default btn-sm btn-block" ng-click="toggleMode()"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr ng-show="labels.length > 0" class="h6">\n      <th ng-show="showWeekNumbers" class="text-center">#</th>\n      <th ng-repeat="label in labels" class="text-center">{{label}}</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows">\n      <td ng-show="showWeekNumbers" class="text-center"><em>{{ getWeekNumber(row) }}</em></td>\n      <td ng-repeat="dt in row" class="text-center">\n        <button type="button" style="width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected}" ng-click="select(dt.date)" ng-disabled="dt.disabled"><span ng-class="{\'text-muted\': dt.secondary}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("template/datepicker/popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/popup.html", "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\">\n\t<li ng-transclude></li>\n" + '\t<li ng-show="showButtonBar" style="padding:10px 9px 2px">\n\t\t<span class="btn-group">\n\t\t\t<button type="button" class="btn btn-sm btn-info" ng-click="today()">{{currentText}}</button>\n\t\t\t<button type="button" class="btn btn-sm btn-default" ng-click="showWeeks = ! showWeeks" ng-class="{active: showWeeks}">{{toggleWeeksText}}</button>\n\t\t\t<button type="button" class="btn btn-sm btn-danger" ng-click="clear()">{{clearText}}</button>\n\t\t</span>\n\t\t<button type="button" class="btn btn-sm btn-success pull-right" ng-click="isOpen = false">{{closeText}}</button>\n\t</li>\n</ul>\n');
} ]), angular.module("template/modal/backdrop.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/backdrop.html", '<div class="modal-backdrop fade" ng-class="{in: animate}" ng-style="{\'z-index\': 1040 + index*10}"></div>');
} ]), angular.module("template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/window.html", '<div tabindex="-1" class="modal fade {{ windowClass }}" ng-class="{in: animate}" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)">\n    <div class="modal-dialog"><div class="modal-content" ng-transclude></div></div>\n</div>');
} ]), angular.module("template/pagination/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pager.html", '<ul class="pager">\n  <li ng-repeat="page in pages" ng-class="{disabled: page.disabled, previous: page.previous, next: page.next}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n</ul>');
} ]), angular.module("template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pagination.html", '<ul class="pagination">\n  <li ng-repeat="page in pages" ng-class="{active: page.active, disabled: page.disabled}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n</ul>');
} ]), angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n</div>\n');
} ]), angular.module("template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind="content"></div>\n</div>\n');
} ]), angular.module("template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover.html", '<div class="popover {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n      <div class="popover-content" ng-bind="content"></div>\n  </div>\n</div>\n');
} ]), angular.module("template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" ng-transclude></div>');
} ]), angular.module("template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progress.html", '<div class="progress" ng-transclude></div>');
} ]), angular.module("template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progressbar.html", '<div class="progress"><div class="progress-bar" ng-class="type && \'progress-bar-\' + type" ng-transclude></div></div>');
} ]), angular.module("template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/rating/rating.html", '<span ng-mouseleave="reset()">\n    <i ng-repeat="r in range" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < val && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')"></i>\n</span>');
} ]), angular.module("template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}">\n  <a ng-click="select()" tab-heading-transclude>{{heading}}</a>\n</li>\n');
} ]), angular.module("template/tabs/tabset-titles.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset-titles.html", "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n</ul>\n");
} ]), angular.module("template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset.html", '\n<div class="tabbable">\n  <ul class="nav {{type && \'nav-\' + type}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane" \n         ng-repeat="tab in tabs" \n         ng-class="{active: tab.active}"\n         tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n');
} ]), angular.module("template/timepicker/timepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html", '<table>\n\t<tbody>\n\t\t<tr class="text-center">\n\t\t\t<td><a ng-click="incrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td><a ng-click="incrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n\t\t\t<td ng-show="showMeridian"></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidHours}">\n\t\t\t\t<input type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-mousewheel="incrementHours()" ng-readonly="readonlyInput" maxlength="2">\n\t\t\t</td>\n\t\t\t<td>:</td>\n\t\t\t<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n\t\t\t\t<input type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n\t\t\t</td>\n\t\t\t<td ng-show="showMeridian"><button type="button" class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n\t\t</tr>\n\t\t<tr class="text-center">\n\t\t\t<td><a ng-click="decrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td><a ng-click="decrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n\t\t\t<td ng-show="showMeridian"></td>\n\t\t</tr>\n\t</tbody>\n</table>\n');
} ]), angular.module("template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html", '<a tabindex="-1" bind-html-unsafe="match.label | typeaheadHighlight:query"></a>');
} ]), angular.module("template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" + '    <li ng-repeat="match in matches" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)">\n        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>');
} ]), angular.module("ui.alias", []).config([ "$compileProvider", "uiAliasConfig", function($compileProvider, uiAliasConfig) {
    "use strict";
    uiAliasConfig = uiAliasConfig || {}, angular.forEach(uiAliasConfig, function(config, alias) {
        angular.isString(config) && (config = {
            replace: !0,
            template: config
        }), $compileProvider.directive(alias, function() {
            return config;
        });
    });
} ]), angular.module("ui.event", []).directive("uiEvent", [ "$parse", function($parse) {
    "use strict";
    return function($scope, elm, events) {
        events = $scope.$eval(events.uiEvent);
        angular.forEach(events, function(uiEvent, eventName) {
            var fn = $parse(uiEvent);
            elm.bind(eventName, function(evt) {
                var params = (params = Array.prototype.slice.call(arguments)).splice(1);
                fn($scope, {
                    $event: evt,
                    $params: params
                }), $scope.$$phase || $scope.$apply();
            });
        });
    };
} ]), angular.module("ui.format", []).filter("format", function() {
    "use strict";
    return function(value, replace) {
        var rlen, target = value;
        return angular.isString(target) && void 0 !== replace && (angular.isArray(replace) || angular.isObject(replace) || (replace = [ replace ]), 
        angular.isArray(replace) ? (rlen = replace.length, target = target.replace(/\$([0-9]+)/g, function(str, i) {
            return 0 <= (i = parseInt(i, 10)) && i < rlen ? replace[i] : str;
        })) : angular.forEach(replace, function(value, key) {
            target = target.split(":" + key).join(value);
        })), target;
    };
}), angular.module("ui.highlight", []).filter("highlight", function() {
    "use strict";
    return function(text, search, caseSensitive) {
        return text && (search || angular.isNumber(search)) ? (text = text.toString(), search = search.toString(), 
        caseSensitive ? text.split(search).join('<span class="ui-match">' + search + "</span>") : text.replace(new RegExp(search, "gi"), '<span class="ui-match">$&</span>')) : text;
    };
}), angular.module("ui.include", []).directive("uiInclude", [ "$http", "$templateCache", "$anchorScroll", "$compile", function($http, $templateCache, $anchorScroll, $compile) {
    "use strict";
    return {
        restrict: "ECA",
        terminal: !0,
        compile: function(element, attr) {
            var srcExp = attr.uiInclude || attr.src, fragExp = attr.fragment || "", onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
            return function(scope, element) {
                function clearContent() {
                    childScope && (childScope.$destroy(), childScope = null), element.html("");
                }
                var childScope, changeCounter = 0;
                function ngIncludeWatchAction() {
                    var thisChangeId = ++changeCounter, src = scope.$eval(srcExp), fragment = scope.$eval(fragExp);
                    src ? $http.get(src, {
                        cache: $templateCache
                    }).success(function(contents) {
                        thisChangeId === changeCounter && (childScope && childScope.$destroy(), childScope = scope.$new(), 
                        contents = fragment ? angular.element("<div/>").html(contents).find(fragment) : angular.element("<div/>").html(contents).contents(), 
                        element.html(contents), $compile(contents)(childScope), !angular.isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll(), 
                        childScope.$emit("$includeContentLoaded"), scope.$eval(onloadExp));
                    }).error(function() {
                        thisChangeId === changeCounter && clearContent();
                    }) : clearContent();
                }
                scope.$watch(fragExp, ngIncludeWatchAction), scope.$watch(srcExp, ngIncludeWatchAction);
            };
        }
    };
} ]), angular.module("ui.indeterminate", []).directive("uiIndeterminate", [ function() {
    "use strict";
    return {
        compile: function(tElm, tAttrs) {
            return tAttrs.type && "checkbox" === tAttrs.type.toLowerCase() ? function($scope, elm, attrs) {
                $scope.$watch(attrs.uiIndeterminate, function(newVal) {
                    elm[0].indeterminate = !!newVal;
                });
            } : angular.noop;
        }
    };
} ]), angular.module("ui.inflector", []).filter("inflector", function() {
    "use strict";
    function tokenize(text) {
        return (text = text.replace(/([A-Z])|([\-|\_])/g, function(_, $1) {
            return " " + ($1 || "");
        })).replace(/\s\s+/g, " ").trim().toLowerCase().split(" ");
    }
    function capitalizeTokens(tokens) {
        var result = [];
        return angular.forEach(tokens, function(token) {
            result.push(token.charAt(0).toUpperCase() + token.substr(1));
        }), result;
    }
    var inflectors = {
        humanize: function(value) {
            return capitalizeTokens(tokenize(value)).join(" ");
        },
        underscore: function(value) {
            return tokenize(value).join("_");
        },
        variable: function(value) {
            return value = (value = tokenize(value))[0] + capitalizeTokens(value.slice(1)).join("");
        }
    };
    return function(text, inflector) {
        return !1 !== inflector && angular.isString(text) ? inflectors[inflector = inflector || "humanize"](text) : text;
    };
}), angular.module("ui.jq", []).value("uiJqConfig", {}).directive("uiJq", [ "uiJqConfig", "$timeout", function(uiJqConfig, $timeout) {
    "use strict";
    return {
        restrict: "A",
        compile: function(tElm, tAttrs) {
            if (!angular.isFunction(tElm[tAttrs.uiJq])) throw new Error('ui-jq: The "' + tAttrs.uiJq + '" function does not exist');
            var options = uiJqConfig && uiJqConfig[tAttrs.uiJq];
            return function(scope, elm, attrs) {
                function callPlugin() {
                    $timeout(function() {
                        var linkOptions;
                        elm[attrs.uiJq].apply(elm, (linkOptions = [], attrs.uiOptions ? (linkOptions = scope.$eval("[" + attrs.uiOptions + "]"), 
                        angular.isObject(options) && angular.isObject(linkOptions[0]) && (linkOptions[0] = angular.extend({}, options, linkOptions[0]))) : options && (linkOptions = [ options ]), 
                        linkOptions));
                    }, 0, !1);
                }
                attrs.ngModel && elm.is("select,input,textarea") && elm.bind("change", function() {
                    elm.trigger("input");
                }), attrs.uiRefresh && scope.$watch(attrs.uiRefresh, function() {
                    callPlugin();
                }), callPlugin();
            };
        }
    };
} ]), angular.module("ui.keypress", []).factory("keypressHelper", [ "$parse", function($parse) {
    "use strict";
    var keysByCode = {
        8: "backspace",
        9: "tab",
        13: "enter",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "delete"
    };
    return function(mode, scope, elm, params) {
        var combinations = [], params = scope.$eval(params["ui" + ((params = mode).charAt(0).toUpperCase() + params.slice(1))]);
        angular.forEach(params, function(v, k) {
            var combination, expression = $parse(v);
            angular.forEach(k.split(" "), function(variation) {
                combination = {
                    expression: expression,
                    keys: {}
                }, angular.forEach(variation.split("-"), function(value) {
                    combination.keys[value] = !0;
                }), combinations.push(combination);
            });
        }), elm.bind(mode, function(event) {
            var metaPressed = !(!event.metaKey || event.ctrlKey), altPressed = !!event.altKey, ctrlPressed = !!event.ctrlKey, shiftPressed = !!event.shiftKey, keyCode = event.keyCode;
            "keypress" === mode && !shiftPressed && 97 <= keyCode && keyCode <= 122 && (keyCode -= 32), 
            angular.forEach(combinations, function(combination) {
                var mainKeyPressed = combination.keys[keysByCode[keyCode]] || combination.keys[keyCode.toString()], metaRequired = !!combination.keys.meta, altRequired = !!combination.keys.alt, ctrlRequired = !!combination.keys.ctrl, shiftRequired = !!combination.keys.shift;
                mainKeyPressed && metaRequired == metaPressed && altRequired == altPressed && ctrlRequired == ctrlPressed && shiftRequired == shiftPressed && scope.$apply(function() {
                    combination.expression(scope, {
                        $event: event
                    });
                });
            });
        });
    };
} ]), angular.module("ui.keypress").directive("uiKeydown", [ "keypressHelper", function(keypressHelper) {
    "use strict";
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keydown", scope, elm, attrs);
        }
    };
} ]), angular.module("ui.keypress").directive("uiKeypress", [ "keypressHelper", function(keypressHelper) {
    "use strict";
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keypress", scope, elm, attrs);
        }
    };
} ]), angular.module("ui.keypress").directive("uiKeyup", [ "keypressHelper", function(keypressHelper) {
    "use strict";
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keyup", scope, elm, attrs);
        }
    };
} ]), angular.module("ui.mask", []).value("uiMaskConfig", {
    maskDefinitions: {
        9: /\d/,
        A: /[a-zA-Z]/,
        "*": /[a-zA-Z0-9]/
    },
    clearOnBlur: !0
}).directive("uiMask", [ "uiMaskConfig", "$parse", function(maskConfig, $parse) {
    "use strict";
    return {
        priority: 100,
        require: "ngModel",
        restrict: "A",
        compile: function() {
            var options = maskConfig;
            return function(scope, iElement, iAttrs, controller) {
                var maskCaretMap, maskPatterns, maskPlaceholder, maskComponents, minRequiredLength, value, valueMasked, isValid, oldValue, oldValueUnmasked, oldCaretPosition, oldSelectionLength, maskProcessed = !1, eventsBound = !1, originalPlaceholder = iAttrs.placeholder, originalMaxlength = iAttrs.maxlength;
                var linkOptions = {};
                iAttrs.uiOptions ? (linkOptions = scope.$eval("[" + iAttrs.uiOptions + "]"), angular.isObject(linkOptions[0]) && (linkOptions = function(original, current) {
                    for (var i in original) Object.prototype.hasOwnProperty.call(original, i) && (void 0 === current[i] ? current[i] = angular.copy(original[i]) : angular.extend(current[i], original[i]));
                    return current;
                }(options, linkOptions[0]))) : linkOptions = options, iAttrs.$observe("uiMask", function(splitMask) {
                    return angular.isDefined(splitMask) ? (characterCount = 0, maskCaretMap = [], maskPatterns = [], 
                    maskPlaceholder = "", "string" == typeof (splitMask = splitMask) && (minRequiredLength = 0, 
                    isOptional = !1, splitMask = splitMask.split(""), angular.forEach(splitMask, function(chr, i) {
                        linkOptions.maskDefinitions[chr] ? (maskCaretMap.push(characterCount), maskPlaceholder += function(i) {
                            var placeholder = iAttrs.placeholder;
                            return void 0 !== placeholder && placeholder[i] ? placeholder[i] : "_";
                        }(i), maskPatterns.push(linkOptions.maskDefinitions[chr]), characterCount++, isOptional || minRequiredLength++) : "?" === chr ? isOptional = !0 : (maskPlaceholder += chr, 
                        characterCount++);
                    })), maskCaretMap.push(maskCaretMap.slice().pop() + 1), maskComponents = maskPlaceholder.replace(/[_]+/g, "_").replace(/([^_]+)([a-zA-Z0-9])([^_])/g, "$1$2_$3").split("_"), 
                    (maskProcessed = 1 < maskCaretMap.length) ? (function() {
                        value = oldValueUnmasked = unmaskValue(controller.$viewValue || ""), valueMasked = oldValue = maskValue(value);
                        var viewValue = (isValid = validateValue(value)) && value.length ? valueMasked : "";
                        iAttrs.maxlength && iElement.attr("maxlength", 2 * maskCaretMap[maskCaretMap.length - 1]), 
                        iElement.attr("placeholder", maskPlaceholder), iElement.val(viewValue), controller.$viewValue = viewValue;
                    }(), eventsBound || (iElement.bind("blur", blurHandler), iElement.bind("mousedown mouseup", mouseDownUpHandler), 
                    iElement.bind("input keyup click focus", eventHandler), eventsBound = !0), !0) : uninitialize()) : uninitialize();
                    var isOptional, characterCount;
                }), iAttrs.$observe("placeholder", function(placeholderAttr) {
                    angular.isDefined(placeholderAttr) && (maskPlaceholder = placeholderAttr, maskProcessed && eventHandler());
                });
                var modelViewValue = !1;
                function uninitialize() {
                    return maskProcessed = !1, eventsBound && (iElement.unbind("blur", blurHandler), 
                    iElement.unbind("mousedown", mouseDownUpHandler), iElement.unbind("mouseup", mouseDownUpHandler), 
                    iElement.unbind("input", eventHandler), iElement.unbind("keyup", eventHandler), 
                    iElement.unbind("click", eventHandler), iElement.unbind("focus", eventHandler), 
                    eventsBound = !1), angular.isDefined(originalPlaceholder) ? iElement.attr("placeholder", originalPlaceholder) : iElement.removeAttr("placeholder"), 
                    angular.isDefined(originalMaxlength) ? iElement.attr("maxlength", originalMaxlength) : iElement.removeAttr("maxlength"), 
                    iElement.val(controller.$modelValue), controller.$viewValue = controller.$modelValue, 
                    !1;
                }
                function validateValue(value) {
                    return !value.length || value.length >= minRequiredLength;
                }
                function unmaskValue(value) {
                    var valueUnmasked = "", maskPatternsCopy = maskPatterns.slice();
                    return value = value.toString(), angular.forEach(maskComponents, function(component) {
                        value = value.replace(component, "");
                    }), angular.forEach(value.split(""), function(chr) {
                        maskPatternsCopy.length && maskPatternsCopy[0].test(chr) && (valueUnmasked += chr, 
                        maskPatternsCopy.shift());
                    }), valueUnmasked;
                }
                function maskValue(unmaskedValue) {
                    var valueMasked = "", maskCaretMapCopy = maskCaretMap.slice();
                    return angular.forEach(maskPlaceholder.split(""), function(chr, i) {
                        unmaskedValue.length && i === maskCaretMapCopy[0] ? (valueMasked += unmaskedValue.charAt(0) || "_", 
                        unmaskedValue = unmaskedValue.substr(1), maskCaretMapCopy.shift()) : valueMasked += chr;
                    }), valueMasked;
                }
                function blurHandler() {
                    linkOptions.clearOnBlur && (oldSelectionLength = oldCaretPosition = 0, isValid && 0 !== value.length || (valueMasked = "", 
                    iElement.val(""), scope.$apply(function() {
                        controller.$setViewValue("");
                    })));
                }
                function mouseDownUpHandler(e) {
                    "mousedown" === e.type ? iElement.bind("mouseout", mouseoutHandler) : iElement.unbind("mouseout", mouseoutHandler);
                }
                function mouseoutHandler() {
                    oldSelectionLength = getSelectionLength(this), iElement.unbind("mouseout", mouseoutHandler);
                }
                function eventHandler(isSelection) {
                    var eventWhich = (isSelection = isSelection || {}).which, eventType = isSelection.type;
                    if (16 !== eventWhich && 91 !== eventWhich) {
                        var val = iElement.val(), valOld = oldValue, valUnmasked = unmaskValue(val), valUnmaskedOld = oldValueUnmasked, valAltered = !1, caretPos = function(input) {
                            if (!input) return 0;
                            {
                                if (void 0 !== input.selectionStart) return input.selectionStart;
                                if (document.selection) {
                                    input.focus();
                                    var selection = document.selection.createRange();
                                    return selection.moveStart("character", input.value ? -input.value.length : 0), 
                                    selection.text.length;
                                }
                            }
                            return 0;
                        }(this) || 0, range = oldCaretPosition || 0, caretPosDelta = caretPos - range, caretPosMin = maskCaretMap[0], caretPosMax = maskCaretMap[valUnmasked.length] || maskCaretMap.slice().shift(), isDeletion = oldSelectionLength || 0, isSelected = 0 < getSelectionLength(this), wasSelected = 0 < isDeletion, pos = val.length > valOld.length || isDeletion && val.length > valOld.length - isDeletion, isDeletion = val.length < valOld.length || isDeletion && val.length === valOld.length - isDeletion, isSelection = 37 <= eventWhich && eventWhich <= 40 && isSelection.shiftKey, isKeyBackspace = 8 === eventWhich || "keyup" !== eventType && isDeletion && -1 == caretPosDelta, isKeyDelete = 46 === eventWhich || "keyup" !== eventType && isDeletion && 0 == caretPosDelta && !wasSelected, caretBumpBack = (37 === eventWhich || isKeyBackspace || "click" === eventType) && caretPosMin < caretPos;
                        if (oldSelectionLength = getSelectionLength(this), !isSelection && (!isSelected || "click" !== eventType && "keyup" !== eventType)) {
                            if ("input" === eventType && isDeletion && !wasSelected && valUnmasked === valUnmaskedOld) {
                                for (;isKeyBackspace && caretPosMin < caretPos && !isValidCaretPosition(caretPos); ) caretPos--;
                                for (;isKeyDelete && caretPos < caretPosMax && -1 === maskCaretMap.indexOf(caretPos); ) caretPos++;
                                var valMasked = maskCaretMap.indexOf(caretPos), valUnmasked = valUnmasked.substring(0, valMasked) + valUnmasked.substring(valMasked + 1), valAltered = !0;
                            }
                            for (valMasked = maskValue(valUnmasked), oldValue = valMasked, oldValueUnmasked = valUnmasked, 
                            iElement.val(valMasked), valAltered && scope.$apply(function() {
                                controller.$setViewValue(valUnmasked);
                            }), pos && caretPos <= caretPosMin && (caretPos = caretPosMin + 1), caretBumpBack && caretPos--, 
                            caretPos = caretPosMax < caretPos ? caretPosMax : caretPos < caretPosMin ? caretPosMin : caretPos; !isValidCaretPosition(caretPos) && caretPosMin < caretPos && caretPos < caretPosMax; ) caretPos += caretBumpBack ? -1 : 1;
                            (caretBumpBack && caretPos < caretPosMax || pos && !isValidCaretPosition(range)) && caretPos++, 
                            pos = oldCaretPosition = caretPos, (range = this) && 0 !== range.offsetWidth && 0 !== range.offsetHeight && (range.setSelectionRange ? (range.focus(), 
                            range.setSelectionRange(pos, pos)) : range.createTextRange && ((range = range.createTextRange()).collapse(!0), 
                            range.moveEnd("character", pos), range.moveStart("character", pos), range.select()));
                        }
                    }
                }
                function isValidCaretPosition(pos) {
                    return -1 < maskCaretMap.indexOf(pos);
                }
                function getSelectionLength(input) {
                    return input ? void 0 !== input.selectionStart ? input.selectionEnd - input.selectionStart : document.selection ? document.selection.createRange().text.length : 0 : 0;
                }
                iAttrs.$observe("modelViewValue", function(val) {
                    "true" === val && (modelViewValue = !0);
                }), scope.$watch(iAttrs.ngModel, function(val) {
                    modelViewValue && val && $parse(iAttrs.ngModel).assign(scope, controller.$viewValue);
                }), controller.$formatters.push(function(fromModelValue) {
                    return maskProcessed ? (value = unmaskValue(fromModelValue || ""), isValid = validateValue(value), 
                    controller.$setValidity("mask", isValid), isValid && value.length ? maskValue(value) : void 0) : fromModelValue;
                }), controller.$parsers.push(function(fromViewValue) {
                    return maskProcessed ? (value = unmaskValue(fromViewValue || ""), isValid = validateValue(value), 
                    controller.$viewValue = value.length ? maskValue(value) : "", controller.$setValidity("mask", isValid), 
                    "" === value && iAttrs.required && controller.$setValidity("required", !controller.$error.required), 
                    isValid ? value : void 0) : fromViewValue;
                }), iElement.bind("mousedown mouseup", mouseDownUpHandler), Array.prototype.indexOf || (Array.prototype.indexOf = function(searchElement) {
                    if (null === this) throw new TypeError();
                    var t = Object(this), len = t.length >>> 0;
                    if (0 == len) return -1;
                    var n = 0;
                    if (1 < arguments.length && ((n = Number(arguments[1])) != n ? n = 0 : 0 !== n && n !== 1 / 0 && n !== -1 / 0 && (n = (0 < n || -1) * Math.floor(Math.abs(n)))), 
                    len <= n) return -1;
                    for (var k = 0 <= n ? n : Math.max(len - Math.abs(n), 0); k < len; k++) if (k in t && t[k] === searchElement) return k;
                    return -1;
                });
            };
        }
    };
} ]), angular.module("ui.reset", []).value("uiResetConfig", null).directive("uiReset", [ "uiResetConfig", function(uiResetConfig) {
    "use strict";
    var resetValue = void 0 !== uiResetConfig ? uiResetConfig : null;
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            var aElement = angular.element('<a class="ui-reset" />');
            elm.wrap('<span class="ui-resetwrap" />').after(aElement), aElement.bind("click", function(e) {
                e.preventDefault(), scope.$apply(function() {
                    attrs.uiReset ? ctrl.$setViewValue(scope.$eval(attrs.uiReset)) : ctrl.$setViewValue(resetValue), 
                    ctrl.$render();
                });
            });
        }
    };
} ]), angular.module("ui.route", []).directive("uiRoute", [ "$location", "$parse", function($location, $parse) {
    "use strict";
    return {
        restrict: "AC",
        scope: !0,
        compile: function(tElement, tAttrs) {
            var useProperty;
            if (tAttrs.uiRoute) useProperty = "uiRoute"; else if (tAttrs.ngHref) useProperty = "ngHref"; else {
                if (!tAttrs.href) throw new Error("uiRoute missing a route or href property on " + tElement[0]);
                useProperty = "href";
            }
            return function($scope, elm, attrs) {
                var modelSetter = $parse(attrs.ngModel || attrs.routeModel || "$uiRoute").assign, watcher = angular.noop;
                function staticWatcher(newVal) {
                    var hash = newVal.indexOf("#");
                    -1 < hash && (newVal = newVal.substr(hash + 1)), (watcher = function() {
                        modelSetter($scope, -1 < $location.path().indexOf(newVal));
                    })();
                }
                function regexWatcher(newVal) {
                    var hash = newVal.indexOf("#");
                    -1 < hash && (newVal = newVal.substr(hash + 1)), (watcher = function() {
                        var regexp = new RegExp("^" + newVal + "$", [ "i" ]);
                        modelSetter($scope, regexp.test($location.path()));
                    })();
                }
                switch (useProperty) {
                  case "uiRoute":
                    attrs.uiRoute ? regexWatcher(attrs.uiRoute) : attrs.$observe("uiRoute", regexWatcher);
                    break;

                  case "ngHref":
                    attrs.ngHref ? staticWatcher(attrs.ngHref) : attrs.$observe("ngHref", staticWatcher);
                    break;

                  case "href":
                    staticWatcher(attrs.href);
                }
                $scope.$on("$routeChangeSuccess", function() {
                    watcher();
                }), $scope.$on("$stateChangeSuccess", function() {
                    watcher();
                });
            };
        }
    };
} ]), angular.module("ui.scroll.jqlite", [ "ui.scroll" ]).service("jqLiteExtras", [ "$log", "$window", function(console, window) {
    "use strict";
    return {
        registerFor: function(element) {
            var convertToPx, getMeasurements, getStyle, getWidthHeight, isWindow, scrollTo, css = angular.element.prototype.css;
            return element.prototype.css = function(name, value) {
                var elem = this[0];
                if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) return css.call(this, name, value);
            }, isWindow = function(obj) {
                return obj && obj.document && obj.location && obj.alert && obj.setInterval;
            }, scrollTo = function(self, prop, value) {
                var elem = self[0], preserve = {
                    top: [ "scrollTop", "pageYOffset", "scrollLeft" ],
                    left: [ "scrollLeft", "pageXOffset", "scrollTop" ]
                }[prop], method = preserve[0], prop = preserve[1], preserve = preserve[2];
                return isWindow(elem) ? angular.isDefined(value) ? elem.scrollTo(self[preserve].call(self), value) : prop in elem ? elem[prop] : elem.document.documentElement[method] : angular.isDefined(value) ? elem[method] = value : elem[method];
            }, convertToPx = window.getComputedStyle ? (getStyle = function(elem) {
                return window.getComputedStyle(elem, null);
            }, function(elem, value) {
                return parseFloat(value);
            }) : (getStyle = function(elem) {
                return elem.currentStyle;
            }, function(result, value) {
                var left, rs, rsLeft, style;
                return new RegExp("^(" + /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source + ")(?!px)[a-z%]+$", "i").test(value) ? (left = (style = result.style).left, 
                rsLeft = (rs = result.runtimeStyle) && rs.left, rs && (rs.left = style.left), style.left = value, 
                result = style.pixelLeft, style.left = left, rsLeft && (rs.left = rsLeft), result) : parseFloat(value);
            }), getMeasurements = function(elem, borderA) {
                var base, computedStyle, computedMarginA, computedMarginB, paddingA, paddingB, borderB;
                return isWindow(elem) ? {
                    base: base = document.documentElement[{
                        height: "clientHeight",
                        width: "clientWidth"
                    }[borderA]],
                    padding: 0,
                    border: 0,
                    margin: 0
                } : (base = (borderB = {
                    width: [ elem.offsetWidth, "Left", "Right" ],
                    height: [ elem.offsetHeight, "Top", "Bottom" ]
                }[borderA])[0], computedMarginA = borderB[1], computedMarginB = borderB[2], computedStyle = getStyle(elem), 
                paddingA = convertToPx(elem, computedStyle["padding" + computedMarginA]) || 0, paddingB = convertToPx(elem, computedStyle["padding" + computedMarginB]) || 0, 
                borderA = convertToPx(elem, computedStyle["border" + computedMarginA + "Width"]) || 0, 
                borderB = convertToPx(elem, computedStyle["border" + computedMarginB + "Width"]) || 0, 
                computedMarginA = computedStyle["margin" + computedMarginA], computedMarginB = computedStyle["margin" + computedMarginB], 
                {
                    base: base,
                    padding: paddingA + paddingB,
                    border: borderA + borderB,
                    margin: (convertToPx(elem, computedMarginA) || 0) + (convertToPx(elem, computedMarginB) || 0)
                });
            }, getWidthHeight = function(elem, direction, measure) {
                var result, measurements = getMeasurements(elem, direction);
                return 0 < measurements.base ? {
                    base: measurements.base - measurements.padding - measurements.border,
                    outer: measurements.base,
                    outerfull: measurements.base + measurements.margin
                }[measure] : (((result = getStyle(elem)[direction]) < 0 || null === result) && (result = elem.style[direction] || 0), 
                {
                    base: (result = parseFloat(result) || 0) - measurements.padding - measurements.border,
                    outer: result,
                    outerfull: result + measurements.padding + measurements.border + measurements.margin
                }[measure]);
            }, angular.forEach({
                before: function(newElem) {
                    var i, _i, _ref, elem = this[0], parent = this.parent(), children = parent.contents();
                    if (children[0] === elem) return parent.prepend(newElem);
                    for (i = _i = 1, _ref = children.length - 1; 1 <= _ref ? _i <= _ref : _ref <= _i; i = 1 <= _ref ? ++_i : --_i) if (children[i] === elem) return void angular.element(children[i - 1]).after(newElem);
                    throw new Error("invalid DOM structure " + elem.outerHTML);
                },
                height: function(value) {
                    return angular.isDefined(value) ? (angular.isNumber(value) && (value += "px"), css.call(this, "height", value)) : getWidthHeight(this[0], "height", "base");
                },
                outerHeight: function(option) {
                    return getWidthHeight(this[0], "height", option ? "outerfull" : "outer");
                },
                offset: function(docElem) {
                    var box, elem, win;
                    if (arguments.length) {
                        if (void 0 === docElem) return this;
                        throw new Error("offset setter method is not implemented");
                    }
                    if (box = {
                        top: 0,
                        left: 0
                    }, win = (elem = this[0]) && elem.ownerDocument) return docElem = win.documentElement, 
                    null != elem.getBoundingClientRect && (box = elem.getBoundingClientRect()), win = win.defaultView || win.parentWindow, 
                    {
                        top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
                    };
                },
                scrollTop: function(value) {
                    return scrollTo(this, "top", value);
                },
                scrollLeft: function(value) {
                    return scrollTo(this, "left", value);
                }
            }, function(value, key) {
                if (!element.prototype[key]) return element.prototype[key] = value;
            });
        }
    };
} ]).run([ "$log", "$window", "jqLiteExtras", function(console, window, jqLiteExtras) {
    "use strict";
    if (!window.jQuery) return jqLiteExtras.registerFor(angular.element);
} ]), angular.module("ui.scroll", []).directive("uiScrollViewport", [ "$log", function() {
    "use strict";
    return {
        controller: [ "$scope", "$element", function(scope, element) {
            return this.viewport = element, this;
        } ]
    };
} ]).directive("uiScroll", [ "$log", "$injector", "$rootScope", "$timeout", function(console, $injector, $rootScope, $timeout) {
    "use strict";
    return {
        require: [ "?^uiScrollViewport" ],
        transclude: "element",
        priority: 1e3,
        terminal: !0,
        compile: function(elementTemplate, attr, linker) {
            return function($scope, element, $attr, controllers) {
                var adapter, adjustBuffer, adjustRowHeight, bof, bottomVisiblePos, buffer, bufferPadding, bufferSize, clipBottom, clipTop, datasource, doAdjustment, enqueueFetch, eof, eventListener, fetch, finalize, first, getValueChain, hideElementBeforeAppend, insert, isLoading, itemName, loading, next, pending, reload, removeFromBuffer, resizeHandler, ridActual, scrollHandler, scrollHeight, shouldLoadBottom, shouldLoadTop, showElementAfterRender, tempScope, topVisible, topVisibleElement, topVisibleItem, topVisiblePos, topVisibleScope, viewport, viewportScope, wheelHandler, log = console.debug || console.log, isDatasource = $attr.uiScroll.match(/^\s*(\w+)\s+in\s+([\w\.]+)\s*$/);
                if (!isDatasource) throw new Error("Expected uiScroll in form of '_item_ in _datasource_' but got '" + $attr.uiScroll + "'");
                if (itemName = isDatasource[1], reload = isDatasource[2], isDatasource = function(datasource) {
                    return angular.isObject(datasource) && datasource.get && angular.isFunction(datasource.get);
                }, getValueChain = function(targetScope, target) {
                    var chain;
                    return targetScope ? (chain = target.match(/^([\w]+)\.(.+)$/)) && 3 === chain.length ? getValueChain(targetScope[chain[1]], chain[2]) : targetScope[target] : null;
                }, datasource = getValueChain($scope, reload), !isDatasource(datasource) && !isDatasource(datasource = $injector.get(reload))) throw new Error(reload + " is not a valid datasource");
                return bufferSize = Math.max(3, +$attr.bufferSize || 10), bufferPadding = function() {
                    return viewport.outerHeight() * Math.max(.1, +$attr.padding || .1);
                }, scrollHeight = function(elem) {
                    var _ref;
                    return null != (_ref = elem[0].scrollHeight) ? _ref : elem[0].document.documentElement.scrollHeight;
                }, adapter = null, linker(tempScope = $scope.$new(), function(padding) {
                    var bottomPadding, createPadding, topPadding, viewport, repeaterType = padding[0].localName;
                    if ("dl" === repeaterType) throw new Error("ui-scroll directive does not support <" + padding[0].localName + "> as a repeating tag: " + padding[0].outerHTML);
                    return "li" !== repeaterType && "tr" !== repeaterType && (repeaterType = "div"), 
                    (viewport = controllers[0] && controllers[0].viewport ? controllers[0].viewport : angular.element(window)).css({
                        "overflow-y": "auto",
                        display: "block"
                    }), topPadding = (createPadding = function(padding, element, direction) {
                        return element[{
                            top: "before",
                            bottom: "after"
                        }[direction]](padding), {
                            paddingHeight: function() {
                                return padding.paddingHeight.apply(padding, arguments);
                            },
                            insert: function(element) {
                                return padding[{
                                    top: "after",
                                    bottom: "before"
                                }[direction]](element);
                            }
                        };
                    })((padding = function(table) {
                        var div, result;
                        return "tr" !== table ? (result = angular.element("<" + table + "></" + table + ">")).paddingHeight = result.height : (table = angular.element("<table><tr><td><div></div></td></tr></table>"), 
                        div = table.find("div"), (result = table.find("tr")).paddingHeight = function() {
                            return div.height.apply(div, arguments);
                        }), result;
                    })(repeaterType), element, "top"), bottomPadding = createPadding(padding(repeaterType), element, "bottom"), 
                    tempScope.$destroy(), adapter = {
                        viewport: viewport,
                        topPadding: topPadding.paddingHeight,
                        bottomPadding: bottomPadding.paddingHeight,
                        append: bottomPadding.insert,
                        prepend: topPadding.insert,
                        bottomDataPos: function() {
                            return scrollHeight(viewport) - bottomPadding.paddingHeight();
                        },
                        topDataPos: function() {
                            return topPadding.paddingHeight();
                        }
                    };
                }), viewport = adapter.viewport, viewportScope = viewport.scope() || $rootScope, 
                angular.isDefined($attr.topVisible) && (topVisibleItem = function(item) {
                    return viewportScope[$attr.topVisible] = item;
                }), angular.isDefined($attr.topVisibleElement) && (topVisibleElement = function(element) {
                    return viewportScope[$attr.topVisibleElement] = element;
                }), angular.isDefined($attr.topVisibleScope) && (topVisibleScope = function(scope) {
                    return viewportScope[$attr.topVisibleScope] = scope;
                }), topVisible = function(item) {
                    if (topVisibleItem && topVisibleItem(item.scope[itemName]), topVisibleElement && topVisibleElement(item.element), 
                    topVisibleScope && topVisibleScope(item.scope), datasource.topVisible) return datasource.topVisible(item);
                }, loading = angular.isDefined($attr.isLoading) ? function(value) {
                    if (viewportScope[$attr.isLoading] = value, datasource.loading) return datasource.loading(value);
                } : function(value) {
                    if (datasource.loading) return datasource.loading(value);
                }, ridActual = 0, next = first = 1, buffer = [], isLoading = bof = eof = !(pending = []), 
                removeFromBuffer = function(start, stop) {
                    for (var _i, i = _i = start; start <= stop ? _i < stop : stop < _i; i = start <= stop ? ++_i : --_i) buffer[i].scope.$destroy(), 
                    buffer[i].element.remove();
                    return buffer.splice(start, stop - start);
                }, reload = function() {
                    return ridActual++, next = first = 1, removeFromBuffer(0, buffer.length), adapter.topPadding(0), 
                    adapter.bottomPadding(0), adjustBuffer(ridActual, bof = eof = !(pending = []));
                }, bottomVisiblePos = function() {
                    return viewport.scrollTop() + viewport.outerHeight();
                }, topVisiblePos = function() {
                    return viewport.scrollTop();
                }, shouldLoadBottom = function() {
                    return !eof && adapter.bottomDataPos() < bottomVisiblePos() + bufferPadding();
                }, clipBottom = function() {
                    for (var item, itemHeight, itemTop, newRow, rowTop, _i, _ref, bottomHeight = 0, overage = 0, i = _i = _ref = buffer.length - 1; _ref <= 0 ? _i <= 0 : 0 <= _i; i = _ref <= 0 ? ++_i : --_i) if (newRow = rowTop !== (itemTop = (item = buffer[i]).element.offset().top), 
                    rowTop = itemTop, newRow && (itemHeight = item.element.outerHeight(!0)), adapter.bottomDataPos() - bottomHeight - itemHeight > bottomVisiblePos() + bufferPadding()) newRow && (bottomHeight += itemHeight), 
                    overage++, eof = !1; else {
                        if (newRow) break;
                        overage++;
                    }
                    if (0 < overage) return adapter.bottomPadding(adapter.bottomPadding() + bottomHeight), 
                    removeFromBuffer(buffer.length - overage, buffer.length), next -= overage, log("clipped off bottom " + overage + " bottom padding " + adapter.bottomPadding());
                }, shouldLoadTop = function() {
                    return !bof && adapter.topDataPos() > topVisiblePos() - bufferPadding();
                }, clipTop = function() {
                    for (var item, itemHeight, itemTop, newRow, rowTop, topHeight = 0, overage = 0, _i = 0, _len = buffer.length; _i < _len; _i++) if (newRow = rowTop !== (itemTop = (item = buffer[_i]).element.offset().top), 
                    rowTop = itemTop, newRow && (itemHeight = item.element.outerHeight(!0)), adapter.topDataPos() + topHeight + itemHeight < topVisiblePos() - bufferPadding()) newRow && (topHeight += itemHeight), 
                    overage++, bof = !1; else {
                        if (newRow) break;
                        overage++;
                    }
                    if (0 < overage) return adapter.topPadding(adapter.topPadding() + topHeight), removeFromBuffer(0, overage), 
                    first += overage, log("clipped off top " + overage + " top padding " + adapter.topPadding());
                }, enqueueFetch = function(rid, direction, scrolling) {
                    if (isLoading || loading(isLoading = !0), 1 === pending.push(direction)) return fetch(rid, scrolling);
                }, hideElementBeforeAppend = function(element) {
                    return element.displayTemp = element.css("display"), element.css("display", "none");
                }, showElementAfterRender = function(element) {
                    if (element.hasOwnProperty("displayTemp")) return element.css("display", element.displayTemp);
                }, insert = function(index, item) {
                    var toBeAppended, wrapper, itemScope = $scope.$new();
                    return itemScope[itemName] = item, toBeAppended = first < index, itemScope.$index = index, 
                    toBeAppended && itemScope.$index--, wrapper = {
                        scope: itemScope
                    }, linker(itemScope, function(clone) {
                        return wrapper.element = clone, toBeAppended ? index === next ? (hideElementBeforeAppend(clone), 
                        adapter.append(clone), buffer.push(wrapper)) : (buffer[index - first].element.after(clone), 
                        buffer.splice(index - first + 1, 0, wrapper)) : (hideElementBeforeAppend(clone), 
                        adapter.prepend(clone), buffer.unshift(wrapper));
                    }), {
                        appended: toBeAppended,
                        wrapper: wrapper
                    };
                }, adjustRowHeight = function(newHeight, wrapper) {
                    return newHeight ? adapter.bottomPadding(Math.max(0, adapter.bottomPadding() - wrapper.element.outerHeight(!0))) : 0 <= (newHeight = adapter.topPadding() - wrapper.element.outerHeight(!0)) ? adapter.topPadding(newHeight) : viewport.scrollTop(viewport.scrollTop() + wrapper.element.outerHeight(!0));
                }, doAdjustment = function(rid, scrolling, finalize) {
                    var item, itemHeight, itemTop, newRow, rowTop, topHeight, _i, _len, _results;
                    if (log("top {actual=" + adapter.topDataPos() + " visible from=" + topVisiblePos() + " bottom {visible through=" + bottomVisiblePos() + " actual=" + adapter.bottomDataPos() + "}"), 
                    shouldLoadBottom() ? enqueueFetch(rid, !0, scrolling) : shouldLoadTop() && enqueueFetch(rid, !1, scrolling), 
                    finalize && finalize(rid), 0 === pending.length) {
                        for (_results = [], _i = topHeight = 0, _len = buffer.length; _i < _len; _i++) {
                            if (newRow = rowTop !== (itemTop = (item = buffer[_i]).element.offset().top), rowTop = itemTop, 
                            newRow && (itemHeight = item.element.outerHeight(!0)), !(newRow && adapter.topDataPos() + topHeight + itemHeight < topVisiblePos())) {
                                newRow && topVisible(item);
                                break;
                            }
                            _results.push(topHeight += itemHeight);
                        }
                        return _results;
                    }
                }, adjustBuffer = function(rid, scrolling, newItems, finalize) {
                    return newItems && newItems.length ? $timeout(function() {
                        for (var itemTop, row, rowTop, _j, _len1, rows = [], _i = 0, _len = newItems.length; _i < _len; _i++) row = newItems[_i], 
                        element = row.wrapper.element, showElementAfterRender(element), rowTop !== (itemTop = element.offset().top) && (rows.push(row), 
                        rowTop = itemTop);
                        for (_j = 0, _len1 = rows.length; _j < _len1; _j++) row = rows[_j], adjustRowHeight(row.appended, row.wrapper);
                        return doAdjustment(rid, scrolling, finalize);
                    }) : doAdjustment(rid, scrolling, finalize);
                }, finalize = function(rid, scrolling, newItems) {
                    return adjustBuffer(rid, scrolling, newItems, function() {
                        return pending.shift(), 0 === pending.length ? loading(isLoading = !1) : fetch(rid, scrolling);
                    });
                }, fetch = function(rid, scrolling) {
                    return pending[0] ? buffer.length && !shouldLoadBottom() ? finalize(rid, scrolling) : datasource.get(next, bufferSize, function(result) {
                        var item, newItems, _i, _len;
                        if (!rid || rid === ridActual) {
                            if (newItems = [], result.length < bufferSize && (eof = !0, adapter.bottomPadding(0)), 
                            0 < result.length) for (clipTop(), _i = 0, _len = result.length; _i < _len; _i++) item = result[_i], 
                            newItems.push(insert(++next, item));
                            return finalize(rid, scrolling, newItems);
                        }
                    }) : buffer.length && !shouldLoadTop() ? finalize(rid, scrolling) : datasource.get(first - bufferSize, bufferSize, function(result) {
                        var i, newItems, _i, _ref;
                        if (!rid || rid === ridActual) {
                            if (newItems = [], result.length < bufferSize && (bof = !0, adapter.topPadding(0)), 
                            0 < result.length) for (buffer.length && clipBottom(), i = _i = _ref = result.length - 1; _ref <= 0 ? _i <= 0 : 0 <= _i; i = _ref <= 0 ? ++_i : --_i) newItems.unshift(insert(--first, result[i]));
                            return finalize(rid, scrolling, newItems);
                        }
                    });
                }, resizeHandler = function() {
                    if (!$rootScope.$$phase && !isLoading) return adjustBuffer(null, !1), $scope.$apply();
                }, viewport.bind("resize", resizeHandler), scrollHandler = function() {
                    if (!$rootScope.$$phase && !isLoading) return adjustBuffer(null, !0), $scope.$apply();
                }, viewport.bind("scroll", scrollHandler), wheelHandler = function(event) {
                    var scrollTop = viewport[0].scrollTop, yMax = viewport[0].scrollHeight - viewport[0].clientHeight;
                    if (0 === scrollTop && !bof || scrollTop === yMax && !eof) return event.preventDefault();
                }, viewport.bind("mousewheel", wheelHandler), $scope.$watch(datasource.revision, reload), 
                eventListener = (datasource.scope || $scope).$new(), $scope.$on("$destroy", function() {
                    return eventListener.$destroy(), viewport.unbind("resize", resizeHandler), viewport.unbind("scroll", scrollHandler), 
                    viewport.unbind("mousewheel", wheelHandler);
                }), eventListener.$on("update.items", function(event, locator, newItem) {
                    var _fn, _i, _len, _ref;
                    if (angular.isFunction(locator)) for (_fn = function(wrapper) {
                        return locator(wrapper.scope);
                    }, _i = 0, _len = buffer.length; _i < _len; _i++) _fn(buffer[_i]); else 0 <= (_ref = locator - first - 1) && _ref < buffer.length && (buffer[locator - first - 1].scope[itemName] = newItem);
                    return null;
                }), eventListener.$on("delete.items", function(event, locator) {
                    var i, item, temp, _fn, _i, _j, _k, _len, _len1, _len2, _ref;
                    if (angular.isFunction(locator)) {
                        for (temp = [], _i = 0, _len = buffer.length; _i < _len; _i++) item = buffer[_i], 
                        temp.unshift(item);
                        for (_fn = function(wrapper) {
                            if (locator(wrapper.scope)) return removeFromBuffer(temp.length - 1 - i, temp.length - i), 
                            next--;
                        }, i = _j = 0, _len1 = temp.length; _j < _len1; i = ++_j) _fn(temp[i]);
                    } else 0 <= (_ref = locator - first - 1) && _ref < buffer.length && (removeFromBuffer(locator - first - 1, locator - first), 
                    next--);
                    for (i = _k = 0, _len2 = buffer.length; _k < _len2; i = ++_k) (item = buffer[i]).scope.$index = first + i;
                    return adjustBuffer(null, !1);
                }), eventListener.$on("insert.item", function(event, locator, item) {
                    var i, _i, _len, _ref, inserted = [];
                    if (angular.isFunction(locator)) throw new Error("not implemented - Insert with locator function");
                    for (0 <= (_ref = locator - first - 1) && _ref < buffer.length && (inserted.push(insert(locator, item)), 
                    next++), i = _i = 0, _len = buffer.length; _i < _len; i = ++_i) (item = buffer[i]).scope.$index = first + i;
                    return adjustBuffer(null, !1, inserted);
                });
            };
        }
    };
} ]), angular.module("ui.scrollfix", []).directive("uiScrollfix", [ "$window", function($window) {
    "use strict";
    return {
        require: "^?uiScrollfixTarget",
        link: function(scope, elm, attrs, uiScrollfixTarget) {
            var fixLimit, absolute = !0, shift = 0, $target = uiScrollfixTarget && uiScrollfixTarget.$element || angular.element($window);
            function onScroll() {
                var limit = absolute ? attrs.uiScrollfix : elm[0].offsetTop + shift, offset = uiScrollfixTarget ? $target[0].scrollTop : angular.isDefined($window.pageYOffset) ? $window.pageYOffset : (document.compatMode && "BackCompat" !== document.compatMode ? document.documentElement : document.body).scrollTop;
                !elm.hasClass("ui-scrollfix") && limit < offset ? (elm.addClass("ui-scrollfix"), 
                fixLimit = limit) : elm.hasClass("ui-scrollfix") && offset < fixLimit && elm.removeClass("ui-scrollfix");
            }
            attrs.uiScrollfix ? "string" == typeof attrs.uiScrollfix && ("-" === attrs.uiScrollfix.charAt(0) ? (absolute = !1, 
            shift = -parseFloat(attrs.uiScrollfix.substr(1))) : "+" === attrs.uiScrollfix.charAt(0) && (absolute = !1, 
            shift = parseFloat(attrs.uiScrollfix.substr(1)))) : absolute = !1, fixLimit = absolute ? attrs.uiScrollfix : elm[0].offsetTop + shift, 
            $target.on("scroll", onScroll), scope.$on("$destroy", function() {
                $target.off("scroll", onScroll);
            });
        }
    };
} ]).directive("uiScrollfixTarget", [ function() {
    "use strict";
    return {
        controller: [ "$element", function($element) {
            this.$element = $element;
        } ]
    };
} ]), angular.module("ui.showhide", []).directive("uiShow", [ function() {
    "use strict";
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiShow, function(newVal) {
            newVal ? elm.addClass("ui-show") : elm.removeClass("ui-show");
        });
    };
} ]).directive("uiHide", [ function() {
    "use strict";
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiHide, function(newVal) {
            newVal ? elm.addClass("ui-hide") : elm.removeClass("ui-hide");
        });
    };
} ]).directive("uiToggle", [ function() {
    "use strict";
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiToggle, function(newVal) {
            newVal ? elm.removeClass("ui-hide").addClass("ui-show") : elm.removeClass("ui-show").addClass("ui-hide");
        });
    };
} ]), angular.module("ui.unique", []).filter("unique", [ "$parse", function($parse) {
    "use strict";
    return function(items, filterOn) {
        return !1 === filterOn || (filterOn || angular.isUndefined(filterOn)) && angular.isArray(items) && (newItems = [], 
        get = angular.isString(filterOn) ? $parse(filterOn) : function(item) {
            return item;
        }, extractValueToCompare = function(item) {
            return angular.isObject(item) ? get(item) : item;
        }, angular.forEach(items, function(item) {
            for (var isDuplicate = !1, i = 0; i < newItems.length; i++) if (angular.equals(extractValueToCompare(newItems[i]), extractValueToCompare(item))) {
                isDuplicate = !0;
                break;
            }
            isDuplicate || newItems.push(item);
        }), items = newItems), items;
        var newItems, get, extractValueToCompare;
    };
} ]), angular.module("ui.uploader", []).service("uiUploader", uiUploader), uiUploader.$inject = [ "$log" ], 
angular.module("ui.validate", []).directive("uiValidate", function() {
    "use strict";
    return {
        restrict: "A",
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            var validateFn, watch, validators = {}, validateExpr = scope.$eval(attrs.uiValidate);
            validateExpr && (angular.isString(validateExpr) && (validateExpr = {
                validator: validateExpr
            }), angular.forEach(validateExpr, function(exprssn, key) {
                validateFn = function(valueToValidate) {
                    var expression = scope.$eval(exprssn, {
                        $value: valueToValidate
                    });
                    return angular.isObject(expression) && angular.isFunction(expression.then) ? expression.then(function() {
                        ctrl.$setValidity(key, !0);
                    }, function() {
                        ctrl.$setValidity(key, !1);
                    }) : expression ? ctrl.$setValidity(key, !0) : ctrl.$setValidity(key, !1), valueToValidate;
                }, validators[key] = validateFn, ctrl.$formatters.push(validateFn), ctrl.$parsers.push(validateFn);
            }), attrs.uiValidateWatch && (watch = scope.$eval(attrs.uiValidateWatch), angular.isString(watch) ? scope.$watch(watch, function() {
                angular.forEach(validators, function(validatorFn) {
                    validatorFn(ctrl.$modelValue);
                });
            }) : angular.isArray(watch) ? angular.forEach(watch, function(expression) {
                scope.$watch(expression, function() {
                    angular.forEach(validators, function(validatorFn) {
                        validatorFn(ctrl.$modelValue);
                    });
                });
            }) : angular.isObject(watch) && angular.forEach(watch, function(expression, validatorKey) {
                angular.isString(expression) && scope.$watch(expression, function() {
                    validators[validatorKey](ctrl.$modelValue);
                }), angular.isArray(expression) && angular.forEach(expression, function(intExpression) {
                    scope.$watch(intExpression, function() {
                        validators[validatorKey](ctrl.$modelValue);
                    });
                });
            })));
        }
    };
}), angular.module("ui.utils", [ "ui.event", "ui.format", "ui.highlight", "ui.include", "ui.indeterminate", "ui.inflector", "ui.jq", "ui.keypress", "ui.mask", "ui.reset", "ui.route", "ui.scrollfix", "ui.scroll", "ui.scroll.jqlite", "ui.showhide", "ui.unique", "ui.validate" ]), 
function(angular) {
    "use strict";
    angular.module("ng-autofocus", []).directive("autofocus", function() {
        return {
            restrict: "A",
            link: function($scope, element) {
                element[0].focus();
            }
        };
    });
}(angular), function(angular) {
    "use strict";
    function $$CookieWriter($document, $log, $browser) {
        var cookiePath = $browser.baseHref(), rawDocument = $document[0];
        return function(name, value, options) {
            rawDocument.cookie = function(name, str, cookieLength) {
                var expires = (cookieLength = cookieLength || {}).expires, path = angular.isDefined(cookieLength.path) ? cookieLength.path : cookiePath;
                return angular.isUndefined(str) && (expires = "Thu, 01 Jan 1970 00:00:00 GMT", str = ""), 
                angular.isString(expires) && (expires = new Date(expires)), str = encodeURIComponent(name) + "=" + encodeURIComponent(str), 
                str += path ? ";path=" + path : "", str += cookieLength.domain ? ";domain=" + cookieLength.domain : "", 
                str += expires ? ";expires=" + expires.toUTCString() : "", str += cookieLength.secure ? ";secure" : "", 
                4096 < (cookieLength = (str += cookieLength.samesite ? ";samesite=" + cookieLength.samesite : "").length + 1) && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"), 
                str;
            }(name, value, options);
        };
    }
    angular.module("ngCookies", [ "ng" ]).info({
        angularVersion: "1.8.2"
    }).provider("$cookies", [ function() {
        var defaults = this.defaults = {};
        function calcOptions(options) {
            return options ? angular.extend({}, defaults, options) : defaults;
        }
        this.$get = [ "$$cookieReader", "$$cookieWriter", function($$cookieReader, $$cookieWriter) {
            return {
                get: function(key) {
                    return $$cookieReader()[key];
                },
                getObject: function(value) {
                    value = this.get(value);
                    return value && angular.fromJson(value);
                },
                getAll: function() {
                    return $$cookieReader();
                },
                put: function(key, value, options) {
                    $$cookieWriter(key, value, calcOptions(options));
                },
                putObject: function(key, value, options) {
                    this.put(key, angular.toJson(value), options);
                },
                remove: function(key, options) {
                    $$cookieWriter(key, void 0, calcOptions(options));
                }
            };
        } ];
    } ]), $$CookieWriter.$inject = [ "$document", "$log", "$browser" ], angular.module("ngCookies").provider("$$cookieWriter", function() {
        this.$get = $$CookieWriter;
    });
}((window, window.angular)), angular.module("ivpusic.cookie", [ "ipCookie" ]), angular.module("ipCookie", [ "ng" ]).factory("ipCookie", [ "$document", function($document) {
    "use strict";
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    return cookieFun.remove = function(key, options) {
        var hasCookie = void 0 !== cookieFun(key);
        return hasCookie && ((options = options || {}).expires = -1, cookieFun(key, "", options)), 
        hasCookie;
    }, cookieFun;
    function cookieFun(key, value, all) {
        var cookies, list, i, cookie, pos, name, hasCookies, expiresFor, dec = (all = all || {}).decode || tryDecodeURIComponent, enc = all.encode || encodeURIComponent;
        if (void 0 !== value) return value = "object" == typeof value ? JSON.stringify(value) : String(value), 
        "number" == typeof all.expires && (expiresFor = all.expires, all.expires = new Date(), 
        -1 === expiresFor ? all.expires = new Date("Thu, 01 Jan 1970 00:00:00 GMT") : void 0 !== all.expirationUnit ? "hours" === all.expirationUnit ? all.expires.setHours(all.expires.getHours() + expiresFor) : "minutes" === all.expirationUnit ? all.expires.setMinutes(all.expires.getMinutes() + expiresFor) : "seconds" === all.expirationUnit ? all.expires.setSeconds(all.expires.getSeconds() + expiresFor) : "milliseconds" === all.expirationUnit ? all.expires.setMilliseconds(all.expires.getMilliseconds() + expiresFor) : all.expires.setDate(all.expires.getDate() + expiresFor) : all.expires.setDate(all.expires.getDate() + expiresFor)), 
        $document[0].cookie = [ enc(key), "=", enc(value), all.expires ? "; expires=" + all.expires.toUTCString() : "", all.path ? "; path=" + all.path : "", all.domain ? "; domain=" + all.domain : "", all.secure ? "; secure" : "" ].join("");
        for (list = [], (all = $document[0].cookie) && (list = all.split("; ")), hasCookies = !(cookies = {}), 
        i = 0; i < list.length; ++i) if (list[i] && (cookie = list[i], pos = cookie.indexOf("="), 
        name = cookie.substring(0, pos), value = dec(cookie.substring(pos + 1)), !angular.isUndefined(value) && (void 0 === key || key === name))) {
            try {
                cookies[name] = JSON.parse(value);
            } catch (e) {
                cookies[name] = value;
            }
            if (key === name) return cookies[name];
            hasCookies = !0;
        }
        return hasCookies && void 0 === key ? cookies : void 0;
    }
} ]), function() {
    "use strict";
    angular.module("angularLoad", []).service("angularLoad", [ "$document", "$q", "$timeout", function($document, $q, $timeout) {
        this.loadScript = function(src) {
            var deferred = $q.defer(), script = $document[0].createElement("script");
            return script.onload = script.onreadystatechange = function(e) {
                $timeout(function() {
                    deferred.resolve(e);
                });
            }, script.onerror = function(e) {
                $timeout(function() {
                    deferred.reject(e);
                });
            }, script.src = src, $document[0].body.appendChild(script), deferred.promise;
        }, this.loadCSS = function(href) {
            var deferred = $q.defer(), style = $document[0].createElement("link");
            return style.rel = "stylesheet", style.type = "text/css", style.href = href, style.onload = style.onreadystatechange = function(e) {
                $timeout(function() {
                    deferred.resolve(e);
                });
            }, style.onerror = function(e) {
                $timeout(function() {
                    deferred.reject(e);
                });
            }, $document[0].head.appendChild(style), deferred.promise;
        };
    } ]);
}(), function(addPostProcessor) {
    Array.prototype.indexOf || (Array.prototype.indexOf = function(searchElement) {
        "use strict";
        if (null == this) throw new TypeError();
        var t = Object(this), len = t.length >>> 0;
        if (0 == len) return -1;
        var n = 0;
        if (0 < arguments.length && ((n = Number(arguments[1])) != n ? n = 0 : 0 != n && n != 1 / 0 && n != -1 / 0 && (n = (0 < n || -1) * Math.floor(Math.abs(n)))), 
        len <= n) return -1;
        for (var k = 0 <= n ? n : Math.max(len - Math.abs(n), 0); k < len; k++) if (k in t && t[k] === searchElement) return k;
        return -1;
    }), Array.prototype.lastIndexOf || (Array.prototype.lastIndexOf = function(searchElement) {
        "use strict";
        if (null == this) throw new TypeError();
        var t = Object(this), len = t.length >>> 0;
        if (0 == len) return -1;
        var n = len;
        1 < arguments.length && ((n = Number(arguments[1])) != n ? n = 0 : 0 != n && n != 1 / 0 && n != -1 / 0 && (n = (0 < n || -1) * Math.floor(Math.abs(n))));
        for (var k = 0 <= n ? Math.min(n, len - 1) : len - Math.abs(n); 0 <= k; k--) if (k in t && t[k] === searchElement) return k;
        return -1;
    }), "function" != typeof String.prototype.trim && (String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g, "");
    });
    var currentLng, $ = addPostProcessor.jQuery || addPostProcessor.Zepto, i18n = {}, resStore = {}, replacementCounter = 0, languages = [], initialized = !1, sync = {}, conflictReference = null;
    "undefined" != typeof module && module.exports ? module.exports = i18n : ($ && ($.i18n = $.i18n || i18n), 
    addPostProcessor.i18n && (conflictReference = addPostProcessor.i18n), addPostProcessor.i18n = i18n);
    var o = {
        lng: void 0,
        load: "all",
        preload: [],
        lowerCaseLng: !(sync = {
            load: function(lngs, options, cb) {
                options.useLocalStorage ? sync._loadLocal(lngs, options, function(err, store) {
                    for (var missingLngs = [], i = 0, len = lngs.length; i < len; i++) store[lngs[i]] || missingLngs.push(lngs[i]);
                    0 < missingLngs.length ? sync._fetch(missingLngs, options, function(err, fetched) {
                        f.extend(store, fetched), sync._storeLocal(fetched), cb(null, store);
                    }) : cb(null, store);
                }) : sync._fetch(lngs, options, function(err, store) {
                    cb(null, store);
                });
            },
            _loadLocal: function(lngs, options, cb) {
                var todo, store = {}, nowMS = new Date().getTime();
                window.localStorage && (todo = lngs.length, f.each(lngs, function(key, lng) {
                    var local = f.localStorage.getItem("res_" + lng);
                    local && (local = JSON.parse(local)).i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS && (store[lng] = local), 
                    0 === --todo && cb(null, store);
                }));
            },
            _storeLocal: function(store) {
                if (window.localStorage) for (var m in store) store[m].i18nStamp = new Date().getTime(), 
                f.localStorage.setItem("res_" + m, JSON.stringify(store[m]));
            },
            _fetch: function(lngs, options, cb) {
                var loadComplete, url, todo, errors, ns = options.ns, store = {};
                options.dynamicLoad ? (loadComplete = function(err, data) {
                    cb(null, data);
                }, "function" == typeof options.customLoad ? options.customLoad(lngs, ns.namespaces, options, loadComplete) : (url = applyReplacement(options.resGetPath, {
                    lng: lngs.join("+"),
                    ns: ns.namespaces.join("+")
                }), f.ajax({
                    url: url,
                    cache: options.cache,
                    success: function(data, status, xhr) {
                        f.log("loaded: " + url), loadComplete(0, data);
                    },
                    error: function(xhr, status, error) {
                        f.log("failed loading: " + url), loadComplete();
                    },
                    dataType: "json",
                    async: options.getAsync,
                    timeout: options.ajaxTimeout
                }))) : (todo = ns.namespaces.length * lngs.length, f.each(ns.namespaces, function(nsIndex, nsValue) {
                    f.each(lngs, function(lngIndex, lngValue) {
                        function loadComplete(err, data) {
                            err && (errors = errors || []).push(err), store[lngValue] = store[lngValue] || {}, 
                            store[lngValue][nsValue] = data, 0 === --todo && cb(errors, store);
                        }
                        "function" == typeof options.customLoad ? options.customLoad(lngValue, nsValue, options, loadComplete) : sync._fetchOne(lngValue, nsValue, options, loadComplete);
                    });
                }));
            },
            _fetchOne: function(lng, ns, options, done) {
                var url = applyReplacement(options.resGetPath, {
                    lng: lng,
                    ns: ns
                });
                f.ajax({
                    url: url,
                    cache: options.cache,
                    success: function(data, status, xhr) {
                        f.log("loaded: " + url), done(null, data);
                    },
                    error: function(theStatus, status, error) {
                        status && 200 == status || theStatus && theStatus.status && 200 == theStatus.status ? f.error("There is a typo in: " + url) : status && 404 == status || theStatus && theStatus.status && 404 == theStatus.status ? f.log("Does not exist: " + url) : (theStatus = status || (theStatus && theStatus.status ? theStatus.status : null), 
                        f.log(theStatus + " when loading " + url)), done(error, {});
                    },
                    dataType: "json",
                    async: options.getAsync,
                    timeout: options.ajaxTimeout
                });
            },
            postMissing: function(lng, ns, key, defaultValue, lngs) {
                var payload = {};
                payload[key] = defaultValue;
                var urls = [];
                if ("fallback" === o.sendMissingTo && !1 !== o.fallbackLng[0]) for (var i = 0; i < o.fallbackLng.length; i++) urls.push({
                    lng: o.fallbackLng[i],
                    url: applyReplacement(o.resPostPath, {
                        lng: o.fallbackLng[i],
                        ns: ns
                    })
                }); else if ("current" === o.sendMissingTo || "fallback" === o.sendMissingTo && !1 === o.fallbackLng[0]) urls.push({
                    lng: lng,
                    url: applyReplacement(o.resPostPath, {
                        lng: lng,
                        ns: ns
                    })
                }); else if ("all" === o.sendMissingTo) for (var i = 0, l = lngs.length; i < l; i++) urls.push({
                    lng: lngs[i],
                    url: applyReplacement(o.resPostPath, {
                        lng: lngs[i],
                        ns: ns
                    })
                });
                for (var y = 0, len = urls.length; y < len; y++) {
                    var item = urls[y];
                    f.ajax({
                        url: item.url,
                        type: o.sendType,
                        data: payload,
                        success: function(data, status, xhr) {
                            f.log("posted missing key '" + key + "' to: " + item.url);
                            for (var keys = key.split("."), x = 0, value = resStore[item.lng][ns]; keys[x]; ) value = x === keys.length - 1 ? value[keys[x]] = defaultValue : value[keys[x]] = value[keys[x]] || {}, 
                            x++;
                        },
                        error: function(xhr, status, error) {
                            f.log("failed posting missing key '" + key + "' to: " + item.url);
                        },
                        dataType: "json",
                        async: o.postAsync,
                        timeout: o.ajaxTimeout
                    });
                }
            },
            reload: function(cb) {
                resStore = {}, setLng(currentLng, cb);
            }
        }),
        returnObjectTrees: !1,
        fallbackLng: [ "dev" ],
        fallbackNS: [],
        detectLngQS: "setLng",
        detectLngFromLocalStorage: !1,
        ns: {
            namespaces: [ "translation" ],
            defaultNs: "translation"
        },
        fallbackOnNull: !0,
        fallbackOnEmpty: !1,
        fallbackToDefaultNS: !1,
        showKeyIfEmpty: !1,
        nsseparator: ":",
        keyseparator: ".",
        selectorAttr: "data-i18n",
        debug: !1,
        resGetPath: "locales/__lng__/__ns__.json",
        resPostPath: "locales/add/__lng__/__ns__",
        getAsync: !0,
        postAsync: !0,
        resStore: void 0,
        useLocalStorage: !1,
        localStorageExpirationTime: 6048e5,
        dynamicLoad: !1,
        sendMissing: !1,
        sendMissingTo: "fallback",
        sendType: "POST",
        interpolationPrefix: "__",
        interpolationSuffix: "__",
        defaultVariables: !1,
        reusePrefix: "$t(",
        reuseSuffix: ")",
        pluralSuffix: "_plural",
        pluralNotFound: [ "plural_not_found", Math.random() ].join(""),
        contextNotFound: [ "context_not_found", Math.random() ].join(""),
        escapeInterpolation: !1,
        indefiniteSuffix: "_indefinite",
        indefiniteNotFound: [ "indefinite_not_found", Math.random() ].join(""),
        setJqueryExt: !0,
        defaultValueFromContent: !0,
        useDataAttrOptions: !1,
        cookieExpirationTime: void 0,
        useCookie: !0,
        cookieName: "i18next",
        cookieDomain: void 0,
        objectTreeKeyHandler: void 0,
        postProcess: void 0,
        parseMissingKey: void 0,
        missingKeyHandler: sync.postMissing,
        ajaxTimeout: 0,
        shortcutFunction: "sprintf"
    }, _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;"
    }, addPostProcessor = {
        create: function(name, value, minutes, domain) {
            var expires = minutes ? ((expires = new Date()).setTime(expires.getTime() + 60 * minutes * 1e3), 
            "; expires=" + expires.toGMTString()) : "";
            domain = domain ? "domain=" + domain + ";" : "", document.cookie = name + "=" + value + expires + ";" + domain + "path=/";
        },
        read: function(name) {
            for (var nameEQ = name + "=", ca = document.cookie.split(";"), i = 0; i < ca.length; i++) {
                for (var c = ca[i]; " " == c.charAt(0); ) c = c.substring(1, c.length);
                if (0 === c.indexOf(nameEQ)) return c.substring(nameEQ.length, c.length);
            }
            return null;
        },
        remove: function(name) {
            this.create(name, "", -1);
        }
    }, f = {
        extend: $ ? $.extend : function(target, source) {
            if (!source || "function" == typeof source) return target;
            for (var attr in source) target[attr] = source[attr];
            return target;
        },
        deepExtend: function _deepExtend(target, source) {
            for (var prop in source) prop in target ? _deepExtend(target[prop], source[prop]) : target[prop] = source[prop];
            return target;
        },
        each: $ ? $.each : function(object, callback, args) {
            var name, i = 0, length = object.length, isObj = void 0 === length || "[object Array]" !== Object.prototype.toString.apply(object) || "function" == typeof object;
            if (args) if (isObj) {
                for (name in object) if (!1 === callback.apply(object[name], args)) break;
            } else for (;i < length && !1 !== callback.apply(object[i++], args); ) ; else if (isObj) {
                for (name in object) if (!1 === callback.call(object[name], name, object[name])) break;
            } else for (;i < length && !1 !== callback.call(object[i], i, object[i++]); ) ;
            return object;
        },
        ajax: $ ? $.ajax : "undefined" != typeof document ? function(options) {
            function base64(text) {
                var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                text = function(text) {
                    text = text.replace(/\r\n/g, "\n");
                    for (var result = "", i = 0; i < text.length; i++) {
                        var c = text.charCodeAt(i);
                        c < 128 ? result += String.fromCharCode(c) : (127 < c && c < 2048 ? result += String.fromCharCode(c >> 6 | 192) : (result += String.fromCharCode(c >> 12 | 224), 
                        result += String.fromCharCode(c >> 6 & 63 | 128)), result += String.fromCharCode(63 & c | 128));
                    }
                    return result;
                }(text);
                for (var chr2, chr3, enc1, enc2, enc3, enc4, result = "", i = 0; enc1 = (enc4 = text.charCodeAt(i++)) >> 2, 
                enc2 = (3 & enc4) << 4 | (chr2 = text.charCodeAt(i++)) >> 4, enc3 = (15 & chr2) << 2 | (chr3 = text.charCodeAt(i++)) >> 6, 
                enc4 = 63 & chr3, isNaN(chr2) ? enc3 = enc4 = 64 : isNaN(chr3) && (enc4 = 64), result += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4), 
                enc3 = enc4 = chr3 = "", i < text.length; ) ;
                return result;
            }
            var ajax = function(method, url, options, callback) {
                "function" == typeof options && (callback = options, options = {}), options.cache = options.cache || !1, 
                options.data = options.data || {}, options.headers = options.headers || {}, options.jsonp = options.jsonp || !1, 
                options.async = void 0 === options.async || options.async;
                var headers = function() {
                    for (var result = arguments[0], i = 1; i < arguments.length; i++) {
                        var header, currentHeaders = arguments[i];
                        for (header in currentHeaders) currentHeaders.hasOwnProperty(header) && (result[header] = currentHeaders[header]);
                    }
                    return result;
                }({
                    accept: "*/*",
                    "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
                }, ajax.headers, options.headers), payload = "application/json" === headers["content-type"] ? JSON.stringify(options.data) : function(data) {
                    if ("string" == typeof data) return data;
                    var dataItem, result = [];
                    for (dataItem in data) data.hasOwnProperty(dataItem) && result.push(encodeURIComponent(dataItem) + "=" + encodeURIComponent(data[dataItem]));
                    return result.join("&");
                }(options.data);
                if ("GET" === method) {
                    var script = [];
                    if (payload && (script.push(payload), payload = null), options.cache || script.push("_=" + new Date().getTime()), 
                    options.jsonp && (script.push("callback=" + options.jsonp), script.push("jsonp=" + options.jsonp)), 
                    1 < (script = script.join("&")).length && (-1 < url.indexOf("?") ? url += "&" + script : url += "?" + script), 
                    options.jsonp) {
                        var head = document.getElementsByTagName("head")[0], script = document.createElement("script");
                        return script.type = "text/javascript", script.src = url, void head.appendChild(script);
                    }
                }
                !function(callback) {
                    if (window.XMLHttpRequest) return callback(null, new XMLHttpRequest());
                    if (window.ActiveXObject) try {
                        return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                    } catch (e) {
                        return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                    }
                    callback(new Error());
                }(function(err, xhr) {
                    if (err) return callback(err);
                    for (var header in xhr.open(method, url, options.async), headers) headers.hasOwnProperty(header) && xhr.setRequestHeader(header, headers[header]);
                    xhr.onreadystatechange = function() {
                        var data;
                        4 === xhr.readyState && (data = xhr.responseText || "", callback && callback(xhr.status, {
                            text: function() {
                                return data;
                            },
                            json: function() {
                                try {
                                    return JSON.parse(data);
                                } catch (e) {
                                    return f.error("Can not parse JSON. URL: " + url), {};
                                }
                            }
                        }));
                    }, xhr.send(payload);
                });
            };
            ({
                authBasic: function(username, password) {
                    ajax.headers.Authorization = "Basic " + base64(username + ":" + password);
                },
                connect: function(url, options, callback) {
                    return ajax("CONNECT", url, options, callback);
                },
                del: function(url, options, callback) {
                    return ajax("DELETE", url, options, callback);
                },
                get: function(url, options, callback) {
                    return ajax("GET", url, options, callback);
                },
                head: function(url, options, callback) {
                    return ajax("HEAD", url, options, callback);
                },
                headers: function(headers) {
                    ajax.headers = headers || {};
                },
                isAllowed: function(url, verb, callback) {
                    this.options(url, function(status, data) {
                        callback(-1 !== data.text().indexOf(verb));
                    });
                },
                options: function(url, options, callback) {
                    return ajax("OPTIONS", url, options, callback);
                },
                patch: function(url, options, callback) {
                    return ajax("PATCH", url, options, callback);
                },
                post: function(url, options, callback) {
                    return ajax("POST", url, options, callback);
                },
                put: function(url, options, callback) {
                    return ajax("PUT", url, options, callback);
                },
                trace: function(url, options, callback) {
                    return ajax("TRACE", url, options, callback);
                }
            })[options.type ? options.type.toLowerCase() : "get"](options.url, options, function(status, data) {
                200 === status || 0 === status && data.text() ? options.success(data.json(), status, null) : options.error(data.text(), status, null);
            });
        } : function() {},
        cookie: "undefined" != typeof document ? addPostProcessor : {
            create: function(name, value, minutes, domain) {},
            read: function(name) {
                return null;
            },
            remove: function(name) {}
        },
        detectLanguage: function() {
            var detectedLng, whitelist = o.lngWhitelist || [], userLngChoices = [];
            "undefined" != typeof window && function() {
                for (var params = window.location.search.substring(1).split("&"), i = 0; i < params.length; i++) {
                    var pos = params[i].indexOf("=");
                    0 < pos && params[i].substring(0, pos) == o.detectLngQS && userLngChoices.push(params[i].substring(pos + 1));
                }
            }();
            !o.useCookie || "undefined" == typeof document || (lang = f.cookie.read(o.cookieName)) && userLngChoices.push(lang);
            {
                var lang;
                o.detectLngFromLocalStorage && "undefined" != typeof window && window.localStorage && ((lang = f.localStorage.getItem("i18next_lng")) && userLngChoices.push(lang));
            }
            if ("undefined" != typeof navigator) {
                if (navigator.languages) for (var i = 0; i < navigator.languages.length; i++) userLngChoices.push(navigator.languages[i]);
                navigator.userLanguage && userLngChoices.push(navigator.userLanguage), navigator.language && userLngChoices.push(navigator.language);
            }
            (function() {
                for (var i = 0; i < userLngChoices.length; i++) {
                    var parts, lng = userLngChoices[i];
                    if (-1 < lng.indexOf("-") && (parts = lng.split("-"), lng = o.lowerCaseLng ? parts[0].toLowerCase() + "-" + parts[1].toLowerCase() : parts[0].toLowerCase() + "-" + parts[1].toUpperCase()), 
                    0 === whitelist.length || -1 < whitelist.indexOf(lng)) {
                        detectedLng = lng;
                        break;
                    }
                }
            })(), detectedLng = detectedLng || o.fallbackLng[0];
            return detectedLng;
        },
        escape: function(data) {
            return "string" == typeof data ? data.replace(/[&<>"'\/]/g, function(s) {
                return _entityMap[s];
            }) : data;
        },
        log: function(str) {
            o.debug && "undefined" != typeof console && console.log(str);
        },
        error: function(str) {
            "undefined" != typeof console && console.error(str);
        },
        getCountyIndexOfLng: function(lng) {
            return "nb-NO" !== lng && "nn-NO" !== lng && "nb-no" !== lng && "nn-no" !== lng ? 0 : 1;
        },
        toLanguages: function(lng) {
            var log = this.log;
            function applyCase(l) {
                var parts;
                return "string" == typeof l && -1 < l.indexOf("-") ? (parts = l.split("-"), o.lowerCaseLng ? parts[0].toLowerCase() + "-" + parts[1].toLowerCase() : parts[0].toLowerCase() + "-" + parts[1].toUpperCase()) : o.lowerCaseLng ? l.toLowerCase() : l;
            }
            function addLanguage(language) {
                !whitelist || -1 < whitelist.indexOf(language) ? languages.push(language) : log("rejecting non-whitelisted language: " + language);
            }
            var parts, languages = [], whitelist = o.lngWhitelist || !1;
            "string" == typeof lng && -1 < lng.indexOf("-") ? (parts = lng.split("-"), "unspecific" !== o.load && addLanguage(applyCase(lng)), 
            "current" !== o.load && addLanguage(applyCase(parts[this.getCountyIndexOfLng(lng)]))) : addLanguage(applyCase(lng));
            for (var i = 0; i < o.fallbackLng.length; i++) -1 === languages.indexOf(o.fallbackLng[i]) && o.fallbackLng[i] && languages.push(applyCase(o.fallbackLng[i]));
            return languages;
        },
        regexEscape: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        },
        regexReplacementEscape: function(strOrFn) {
            return "string" == typeof strOrFn ? strOrFn.replace(/\$/g, "$$$$") : strOrFn;
        },
        localStorage: {
            setItem: function(key, value) {
                if (window.localStorage) try {
                    window.localStorage.setItem(key, value);
                } catch (e) {
                    f.log('failed to set value for key "' + key + '" to localStorage.');
                }
            },
            getItem: function(key, value) {
                if (window.localStorage) try {
                    return window.localStorage.getItem(key, value);
                } catch (e) {
                    return void f.log('failed to get value for key "' + key + '" from localStorage.');
                }
            }
        }
    };
    function init(options, cb) {
        "function" == typeof options && (cb = options, options = {}), options = options || {}, 
        f.extend(o, options), delete o.fixLng, o.functions && (delete o.functions, f.extend(f, options.functions)), 
        "string" == typeof o.ns && (o.ns = {
            namespaces: [ o.ns ],
            defaultNs: o.ns
        }), "string" == typeof o.fallbackNS && (o.fallbackNS = [ o.fallbackNS ]), "string" != typeof o.fallbackLng && "boolean" != typeof o.fallbackLng || (o.fallbackLng = [ o.fallbackLng ]), 
        o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix), o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix), 
        o.lng || (o.lng = f.detectLanguage()), languages = f.toLanguages(o.lng), currentLng = languages[0], 
        f.log("currentLng set to: " + currentLng), o.useCookie && f.cookie.read(o.cookieName) !== currentLng && f.cookie.create(o.cookieName, currentLng, o.cookieExpirationTime, o.cookieDomain), 
        o.detectLngFromLocalStorage && "undefined" != typeof document && window.localStorage && f.localStorage.setItem("i18next_lng", currentLng);
        var deferred, lngTranslate = translate;
        function parse(ele, key, options) {
            var attr, dataAttr, optionsToUse, translated;
            0 !== key.length && (attr = "text", 0 === key.indexOf("[") && (key = (translated = key.split("]"))[1], 
            attr = translated[0].substr(1, translated[0].length - 1)), key.indexOf(";") === key.length - 1 && (key = key.substr(0, key.length - 2)), 
            "html" === attr ? (optionsToUse = o.defaultValueFromContent ? $.extend({
                defaultValue: ele.html()
            }, options) : options, ele.html($.t(key, optionsToUse))) : "text" === attr ? (optionsToUse = o.defaultValueFromContent ? $.extend({
                defaultValue: ele.text()
            }, options) : options, ele.text($.t(key, optionsToUse))) : "prepend" === attr ? (optionsToUse = o.defaultValueFromContent ? $.extend({
                defaultValue: ele.html()
            }, options) : options, ele.prepend($.t(key, optionsToUse))) : "append" === attr ? (optionsToUse = o.defaultValueFromContent ? $.extend({
                defaultValue: ele.html()
            }, options) : options, ele.append($.t(key, optionsToUse))) : 0 === attr.indexOf("data-") ? (dataAttr = attr.substr("data-".length), 
            optionsToUse = o.defaultValueFromContent ? $.extend({
                defaultValue: ele.data(dataAttr)
            }, options) : options, translated = $.t(key, optionsToUse), ele.data(dataAttr, translated), 
            ele.attr(attr, translated)) : (optionsToUse = o.defaultValueFromContent ? $.extend({
                defaultValue: ele.attr(attr)
            }, options) : options, ele.attr(attr, $.t(key, optionsToUse))));
        }
        function localize(ele, options) {
            var target, keys, key = ele.attr(o.selectorAttr);
            (key = !key && void 0 !== key && !1 !== key ? ele.text() || ele.val() : key) && ((keys = (target = ele).data("i18n-target")) && (target = ele.find(keys) || ele), 
            options = (options = !options && !0 === o.useDataAttrOptions ? ele.data("i18n-options") : options) || {}, 
            0 <= key.indexOf(";") ? (keys = key.split(";"), $.each(keys, function(m, k) {
                "" !== k && parse(target, k, options);
            })) : parse(target, key, options), !0 === o.useDataAttrOptions && ele.data("i18n-options", options));
        }
        if (options.fixLng && ((lngTranslate = function(key, options) {
            return (options = options || {}).lng = options.lng || lngTranslate.lng, translate(key, options);
        }).lng = currentLng), pluralExtensions.setCurrentLng(currentLng), $ && o.setJqueryExt && ($.t = $.t || translate, 
        $.fn.i18n = function(options) {
            return this.each(function() {
                localize($(this), options), $(this).find("[" + o.selectorAttr + "]").each(function() {
                    localize($(this), options);
                });
            });
        }), $ && $.Deferred && (deferred = $.Deferred()), o.resStore) return resStore = o.resStore, 
        initialized = !0, cb && cb(lngTranslate), deferred && deferred.resolve(lngTranslate), 
        deferred ? deferred.promise() : void 0;
        var lngsToLoad = f.toLanguages(o.lng);
        "string" == typeof o.preload && (o.preload = [ o.preload ]);
        for (var i = 0, l = o.preload.length; i < l; i++) for (var pres = f.toLanguages(o.preload[i]), y = 0, len = pres.length; y < len; y++) lngsToLoad.indexOf(pres[y]) < 0 && lngsToLoad.push(pres[y]);
        return i18n.sync.load(lngsToLoad, o, function(err, store) {
            resStore = store, initialized = !0, cb && cb(lngTranslate), deferred && deferred.resolve(lngTranslate);
        }), deferred ? deferred.promise() : void 0;
    }
    function addResource(lng, ns, key, value) {
        "string" != typeof ns ? (resource = ns, ns = o.ns.defaultNs) : o.ns.namespaces.indexOf(ns) < 0 && o.ns.namespaces.push(ns), 
        resStore[lng] = resStore[lng] || {}, resStore[lng][ns] = resStore[lng][ns] || {};
        for (var keys = key.split(o.keyseparator), x = 0, node = resStore[lng][ns]; keys[x]; ) x == keys.length - 1 ? node[keys[x]] = value : (null == node[keys[x]] && (node[keys[x]] = {}), 
        node = node[keys[x]]), x++;
        o.useLocalStorage && sync._storeLocal(resStore);
    }
    function loadNamespaces(namespaces, cb) {
        var opts = {
            dynamicLoad: o.dynamicLoad,
            resGetPath: o.resGetPath,
            getAsync: o.getAsync,
            customLoad: o.customLoad,
            ns: {
                namespaces: namespaces,
                defaultNs: ""
            }
        }, lngsToLoad = f.toLanguages(o.lng);
        "string" == typeof o.preload && (o.preload = [ o.preload ]);
        for (var i = 0, l = o.preload.length; i < l; i++) for (var pres = f.toLanguages(o.preload[i]), y = 0, len = pres.length; y < len; y++) lngsToLoad.indexOf(pres[y]) < 0 && lngsToLoad.push(pres[y]);
        for (var lngNeedLoad = [], a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
            var needLoad = !1, resSet = resStore[lngsToLoad[a]];
            if (resSet) for (var b = 0, lenB = namespaces.length; b < lenB; b++) resSet[namespaces[b]] || (needLoad = !0); else needLoad = !0;
            needLoad && lngNeedLoad.push(lngsToLoad[a]);
        }
        lngNeedLoad.length ? i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
            var todo = namespaces.length * lngNeedLoad.length;
            f.each(namespaces, function(nsIndex, nsValue) {
                o.ns.namespaces.indexOf(nsValue) < 0 && o.ns.namespaces.push(nsValue), f.each(lngNeedLoad, function(lngIndex, lngValue) {
                    resStore[lngValue] = resStore[lngValue] || {}, resStore[lngValue][nsValue] = store[lngValue][nsValue], 
                    0 === --todo && cb && (o.useLocalStorage && i18n.sync._storeLocal(resStore), cb());
                });
            });
        }) : cb && cb();
    }
    function setLng(lng, options, cb) {
        return (options = "function" == typeof options ? (cb = options, {}) : options || {}).lng = lng, 
        init(options, cb);
    }
    function applyReplacement(str, hash, nestedKey, options) {
        if (!str) return str;
        if (options = options || hash, str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;
        var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped, suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped, unEscapingSuffix = "HTML" + suffix, hash = hash.replace && "object" == typeof hash.replace ? hash.replace : hash;
        return f.each(hash, function(nextKey, value) {
            nextKey = nestedKey ? nestedKey + o.keyseparator + nextKey : nextKey;
            str = "object" == typeof value && null !== value ? applyReplacement(str, value, nextKey, options) : options.escapeInterpolation || o.escapeInterpolation ? (str = str.replace(new RegExp([ prefix, nextKey, unEscapingSuffix ].join(""), "g"), f.regexReplacementEscape(value))).replace(new RegExp([ prefix, nextKey, suffix ].join(""), "g"), f.regexReplacementEscape(f.escape(value))) : str.replace(new RegExp([ prefix, nextKey, suffix ].join(""), "g"), f.regexReplacementEscape(value));
        }), str;
    }
    function applyReuse(translated, options) {
        var opts = f.extend({}, options);
        for (delete opts.postProcess; -1 != translated.indexOf(o.reusePrefix) && !(++replacementCounter > o.maxRecursion); ) {
            var translated_token = translated.lastIndexOf(o.reusePrefix), index_of_end_of_closing = translated.indexOf(o.reuseSuffix, translated_token) + o.reuseSuffix.length, token = translated.substring(translated_token, index_of_end_of_closing), token_without_symbols = token.replace(o.reusePrefix, "").replace(o.reuseSuffix, "");
            if (index_of_end_of_closing <= translated_token) return f.error("there is an missing closing in following translation value", translated), 
            "";
            if (-1 != token_without_symbols.indexOf(",")) {
                var index_of_token_end_of_closing = token_without_symbols.indexOf(",");
                if (-1 != token_without_symbols.indexOf("{", index_of_token_end_of_closing) && -1 != token_without_symbols.indexOf("}", index_of_token_end_of_closing)) {
                    var index_of_opts_opening = token_without_symbols.indexOf("{", index_of_token_end_of_closing), index_of_opts_end_of_closing = token_without_symbols.indexOf("}", index_of_opts_opening) + "}".length;
                    try {
                        opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing))), 
                        token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                    } catch (e) {}
                }
            }
            translated_token = _translate(token_without_symbols, opts);
            translated = translated.replace(token, f.regexReplacementEscape(translated_token));
        }
        return translated;
    }
    function needsPlural(options) {
        return void 0 !== options.count && "string" != typeof options.count;
    }
    function exists(key, found) {
        var notFound = _getDefaultValue(key, found = found || {}), found = _find(key, found);
        return void 0 !== found || found === notFound;
    }
    function translate(key, options) {
        return options = options || {}, initialized ? (replacementCounter = 0, _translate.apply(null, arguments)) : (f.log("i18next not finished initialization. you might have called t function before loading resources finished."), 
        options.defaultValue || "");
    }
    function _getDefaultValue(key, options) {
        return void 0 !== options.defaultValue ? options.defaultValue : key;
    }
    function _translate(potentialKeys, options) {
        if (options && "object" != typeof options ? "sprintf" === o.shortcutFunction ? options = function() {
            for (var values = [], i = 1; i < arguments.length; i++) values.push(arguments[i]);
            return {
                postProcess: "sprintf",
                sprintf: values
            };
        }.apply(null, arguments) : "defaultValue" === o.shortcutFunction && (options = {
            defaultValue: options
        }) : options = options || {}, "object" == typeof o.defaultVariables && (options = f.extend({}, o.defaultVariables, options)), 
        null == potentialKeys || "" === potentialKeys) return "";
        var key = (potentialKeys = "string" == typeof (potentialKeys = "number" == typeof potentialKeys ? String(potentialKeys) : potentialKeys) ? [ potentialKeys ] : potentialKeys)[0];
        if (1 < potentialKeys.length) for (var i = 0; i < potentialKeys.length && !exists(key = potentialKeys[i], options); i++) ;
        var parts, notFound = _getDefaultValue(key, options), found = _find(key, options), splitNotFound = options.lng ? f.toLanguages(options.lng, options.fallbackLng) : languages, postProcessorsToApply = options.ns || o.ns.defaultNs;
        -1 < key.indexOf(o.nsseparator) && (postProcessorsToApply = (parts = key.split(o.nsseparator))[0], 
        key = parts[1]), void 0 === found && o.sendMissing && "function" == typeof o.missingKeyHandler && (options.lng ? o.missingKeyHandler(splitNotFound[0], postProcessorsToApply, key, notFound, splitNotFound) : o.missingKeyHandler(o.lng, postProcessorsToApply, key, notFound, splitNotFound)), 
        postProcessorsToApply = "string" == typeof o.postProcess && "" !== o.postProcess ? [ o.postProcess ] : "array" == typeof o.postProcess || "object" == typeof o.postProcess ? o.postProcess : [], 
        "string" == typeof options.postProcess && "" !== options.postProcess ? postProcessorsToApply = postProcessorsToApply.concat([ options.postProcess ]) : "array" != typeof options.postProcess && "object" != typeof options.postProcess || (postProcessorsToApply = postProcessorsToApply.concat(options.postProcess)), 
        void 0 !== found && postProcessorsToApply.length && postProcessorsToApply.forEach(function(postProcessor) {
            postProcessors[postProcessor] && (found = postProcessors[postProcessor](found, key, options));
        });
        var val, splitNotFound = notFound;
        return (splitNotFound = -1 < notFound.indexOf(o.nsseparator) ? (parts = notFound.split(o.nsseparator))[1] : splitNotFound) === key && o.parseMissingKey && (notFound = o.parseMissingKey(notFound)), 
        void 0 === found && (notFound = applyReuse(notFound = applyReplacement(notFound, options), options), 
        postProcessorsToApply.length && (val = _getDefaultValue(key, options), postProcessorsToApply.forEach(function(postProcessor) {
            postProcessors[postProcessor] && (found = postProcessors[postProcessor](val, key, options));
        }))), void 0 !== found ? found : notFound;
    }
    function _find(key, options) {
        var oldAsync, notFound = _getDefaultValue(key, options = options || {}), lngs = languages;
        if (!resStore) return notFound;
        if ("cimode" === lngs[0].toLowerCase()) return notFound;
        options.lngs && (lngs = options.lngs), options.lng && (lngs = f.toLanguages(options.lng, options.fallbackLng), 
        resStore[lngs[0]] || (oldAsync = o.getAsync, o.getAsync = !1, i18n.sync.load(lngs, o, function(err, store) {
            f.extend(resStore, store), o.getAsync = oldAsync;
        })));
        var translated, pluralExtension, ns = options.ns || o.ns.defaultNs;
        if ((-1 < key.indexOf(o.nsseparator) && (pluralExtension = key.split(o.nsseparator), 
        ns = pluralExtension[0], key = pluralExtension[1]), function(options) {
            return options.context && ("string" == typeof options.context || "number" == typeof options.context);
        }(options)) && (delete (optionsWithoutIndef = f.extend({}, options)).context, optionsWithoutIndef.defaultValue = o.contextNotFound, 
        (translated = translate(ns + o.nsseparator + key + "_" + options.context, optionsWithoutIndef)) != o.contextNotFound)) return applyReplacement(translated, {
            context: options.context
        });
        if (needsPlural(options, lngs[0])) {
            if (delete (optionsWithoutIndef = f.extend({
                lngs: [ lngs[0] ]
            }, options)).count, optionsWithoutIndef._origLng = optionsWithoutIndef._origLng || optionsWithoutIndef.lng || lngs[0], 
            delete optionsWithoutIndef.lng, optionsWithoutIndef.defaultValue = o.pluralNotFound, 
            pluralExtensions.needsPlural(lngs[0], options.count) ? (clone = ns + o.nsseparator + key + o.pluralSuffix, 
            0 <= (pluralExtension = pluralExtensions.get(lngs[0], options.count)) ? clone = clone + "_" + pluralExtension : 1 === pluralExtension && (clone = ns + o.nsseparator + key)) : clone = ns + o.nsseparator + key, 
            (translated = translate(clone, optionsWithoutIndef)) != o.pluralNotFound) return applyReplacement(translated, {
                count: options.count,
                interpolationPrefix: options.interpolationPrefix,
                interpolationSuffix: options.interpolationSuffix
            });
            if (!(1 < lngs.length)) return optionsWithoutIndef.lng = optionsWithoutIndef._origLng, 
            delete optionsWithoutIndef._origLng, applyReplacement(translated = translate(ns + o.nsseparator + key, optionsWithoutIndef), {
                count: options.count,
                interpolationPrefix: options.interpolationPrefix,
                interpolationSuffix: options.interpolationSuffix
            });
            var clone = lngs.slice();
            if (clone.shift(), (options = f.extend(options, {
                lngs: clone
            }))._origLng = optionsWithoutIndef._origLng, delete options.lng, (translated = translate(ns + o.nsseparator + key, options)) != o.pluralNotFound) return translated;
        }
        if (function(options) {
            return void 0 !== options.indefinite_article && "string" != typeof options.indefinite_article && options.indefinite_article;
        }(options)) {
            var optionsWithoutIndef = f.extend({}, options);
            if (delete optionsWithoutIndef.indefinite_article, optionsWithoutIndef.defaultValue = o.indefiniteNotFound, 
            (translated = translate(ns + o.nsseparator + key + (options.count && !needsPlural(options, lngs[0]) || !options.count ? o.indefiniteSuffix : ""), optionsWithoutIndef)) != o.indefiniteNotFound) return translated;
        }
        for (var keys = key.split(o.keyseparator), i = 0, len = lngs.length; i < len && void 0 === found; i++) {
            for (var valueType, copy, l = lngs[i], x = 0, value = resStore[l] && resStore[l][ns]; keys[x]; ) value = value && value[keys[x]], 
            x++;
            void 0 === value || o.showKeyIfEmpty && "" === value || (valueType = Object.prototype.toString.apply(value), 
            "string" == typeof value ? value = applyReuse(value = applyReplacement(value, options), options) : "[object Array]" !== valueType || o.returnObjectTrees || options.returnObjectTrees ? null === value && !0 === o.fallbackOnNull ? value = void 0 : null !== value && (o.returnObjectTrees || options.returnObjectTrees ? "[object Number]" !== valueType && "[object Function]" !== valueType && "[object RegExp]" !== valueType && (copy = "[object Array]" === valueType ? [] : {}, 
            f.each(value, function(m) {
                copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
            }), value = copy) : o.objectTreeKeyHandler && "function" == typeof o.objectTreeKeyHandler ? value = o.objectTreeKeyHandler(key, value, l, ns, options) : (value = "key '" + ns + ":" + key + " (" + l + ")' returned an object instead of string.", 
            f.log(value))) : value = applyReuse(value = applyReplacement(value = value.join("\n"), options), options), 
            found = value = "string" == typeof value && "" === value.trim() && !0 === o.fallbackOnEmpty ? void 0 : value);
        }
        if (void 0 === found && !options.isFallbackLookup && (!0 === o.fallbackToDefaultNS || o.fallbackNS && 0 < o.fallbackNS.length)) {
            if (options.isFallbackLookup = !0, o.fallbackNS.length) for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                var found = _find(o.fallbackNS[y] + o.nsseparator + key, options);
                if (found || "" === found && !1 === o.fallbackOnEmpty) if ((-1 < found.indexOf(o.nsseparator) ? found.split(o.nsseparator)[1] : found) !== (-1 < notFound.indexOf(o.nsseparator) ? notFound.split(o.nsseparator)[1] : notFound)) break;
            } else options.ns = o.ns.defaultNs, found = _find(key, options);
            options.isFallbackLookup = !1;
        }
        return found;
    }
    f.applyReplacement = applyReplacement;
    var str_format, _rules = [ [ "ach", "Acholi", [ 1, 2 ], 1 ], [ "af", "Afrikaans", [ 1, 2 ], 2 ], [ "ak", "Akan", [ 1, 2 ], 1 ], [ "am", "Amharic", [ 1, 2 ], 1 ], [ "an", "Aragonese", [ 1, 2 ], 2 ], [ "ar", "Arabic", [ 0, 1, 2, 3, 11, 100 ], 5 ], [ "arn", "Mapudungun", [ 1, 2 ], 1 ], [ "ast", "Asturian", [ 1, 2 ], 2 ], [ "ay", "Aymar", [ 1 ], 3 ], [ "az", "Azerbaijani", [ 1, 2 ], 2 ], [ "be", "Belarusian", [ 1, 2, 5 ], 4 ], [ "bg", "Bulgarian", [ 1, 2 ], 2 ], [ "bn", "Bengali", [ 1, 2 ], 2 ], [ "bo", "Tibetan", [ 1 ], 3 ], [ "br", "Breton", [ 1, 2 ], 1 ], [ "bs", "Bosnian", [ 1, 2, 5 ], 4 ], [ "ca", "Catalan", [ 1, 2 ], 2 ], [ "cgg", "Chiga", [ 1 ], 3 ], [ "cs", "Czech", [ 1, 2, 5 ], 6 ], [ "csb", "Kashubian", [ 1, 2, 5 ], 7 ], [ "cy", "Welsh", [ 1, 2, 3, 8 ], 8 ], [ "da", "Danish", [ 1, 2 ], 2 ], [ "de", "German", [ 1, 2 ], 2 ], [ "dev", "Development Fallback", [ 1, 2 ], 2 ], [ "dz", "Dzongkha", [ 1 ], 3 ], [ "el", "Greek", [ 1, 2 ], 2 ], [ "en", "English", [ 1, 2 ], 2 ], [ "eo", "Esperanto", [ 1, 2 ], 2 ], [ "es", "Spanish", [ 1, 2 ], 2 ], [ "es_ar", "Argentinean Spanish", [ 1, 2 ], 2 ], [ "et", "Estonian", [ 1, 2 ], 2 ], [ "eu", "Basque", [ 1, 2 ], 2 ], [ "fa", "Persian", [ 1 ], 3 ], [ "fi", "Finnish", [ 1, 2 ], 2 ], [ "fil", "Filipino", [ 1, 2 ], 1 ], [ "fo", "Faroese", [ 1, 2 ], 2 ], [ "fr", "French", [ 1, 2 ], 9 ], [ "fur", "Friulian", [ 1, 2 ], 2 ], [ "fy", "Frisian", [ 1, 2 ], 2 ], [ "ga", "Irish", [ 1, 2, 3, 7, 11 ], 10 ], [ "gd", "Scottish Gaelic", [ 1, 2, 3, 20 ], 11 ], [ "gl", "Galician", [ 1, 2 ], 2 ], [ "gu", "Gujarati", [ 1, 2 ], 2 ], [ "gun", "Gun", [ 1, 2 ], 1 ], [ "ha", "Hausa", [ 1, 2 ], 2 ], [ "he", "Hebrew", [ 1, 2 ], 2 ], [ "hi", "Hindi", [ 1, 2 ], 2 ], [ "hr", "Croatian", [ 1, 2, 5 ], 4 ], [ "hu", "Hungarian", [ 1, 2 ], 2 ], [ "hy", "Armenian", [ 1, 2 ], 2 ], [ "ia", "Interlingua", [ 1, 2 ], 2 ], [ "id", "Indonesian", [ 1 ], 3 ], [ "is", "Icelandic", [ 1, 2 ], 12 ], [ "it", "Italian", [ 1, 2 ], 2 ], [ "ja", "Japanese", [ 1 ], 3 ], [ "jbo", "Lojban", [ 1 ], 3 ], [ "jv", "Javanese", [ 0, 1 ], 13 ], [ "ka", "Georgian", [ 1 ], 3 ], [ "kk", "Kazakh", [ 1 ], 3 ], [ "km", "Khmer", [ 1 ], 3 ], [ "kn", "Kannada", [ 1, 2 ], 2 ], [ "ko", "Korean", [ 1 ], 3 ], [ "ku", "Kurdish", [ 1, 2 ], 2 ], [ "kw", "Cornish", [ 1, 2, 3, 4 ], 14 ], [ "ky", "Kyrgyz", [ 1 ], 3 ], [ "lb", "Letzeburgesch", [ 1, 2 ], 2 ], [ "ln", "Lingala", [ 1, 2 ], 1 ], [ "lo", "Lao", [ 1 ], 3 ], [ "lt", "Lithuanian", [ 1, 2, 10 ], 15 ], [ "lv", "Latvian", [ 1, 2, 0 ], 16 ], [ "mai", "Maithili", [ 1, 2 ], 2 ], [ "mfe", "Mauritian Creole", [ 1, 2 ], 1 ], [ "mg", "Malagasy", [ 1, 2 ], 1 ], [ "mi", "Maori", [ 1, 2 ], 1 ], [ "mk", "Macedonian", [ 1, 2 ], 17 ], [ "ml", "Malayalam", [ 1, 2 ], 2 ], [ "mn", "Mongolian", [ 1, 2 ], 2 ], [ "mnk", "Mandinka", [ 0, 1, 2 ], 18 ], [ "mr", "Marathi", [ 1, 2 ], 2 ], [ "ms", "Malay", [ 1 ], 3 ], [ "mt", "Maltese", [ 1, 2, 11, 20 ], 19 ], [ "nah", "Nahuatl", [ 1, 2 ], 2 ], [ "nap", "Neapolitan", [ 1, 2 ], 2 ], [ "nb", "Norwegian Bokmal", [ 1, 2 ], 2 ], [ "ne", "Nepali", [ 1, 2 ], 2 ], [ "nl", "Dutch", [ 1, 2 ], 2 ], [ "nn", "Norwegian Nynorsk", [ 1, 2 ], 2 ], [ "no", "Norwegian", [ 1, 2 ], 2 ], [ "nso", "Northern Sotho", [ 1, 2 ], 2 ], [ "oc", "Occitan", [ 1, 2 ], 1 ], [ "or", "Oriya", [ 2, 1 ], 2 ], [ "pa", "Punjabi", [ 1, 2 ], 2 ], [ "pap", "Papiamento", [ 1, 2 ], 2 ], [ "pl", "Polish", [ 1, 2, 5 ], 7 ], [ "pms", "Piemontese", [ 1, 2 ], 2 ], [ "ps", "Pashto", [ 1, 2 ], 2 ], [ "pt", "Portuguese", [ 1, 2 ], 2 ], [ "pt_br", "Brazilian Portuguese", [ 1, 2 ], 2 ], [ "rm", "Romansh", [ 1, 2 ], 2 ], [ "ro", "Romanian", [ 1, 2, 20 ], 20 ], [ "ru", "Russian", [ 1, 2, 5 ], 4 ], [ "sah", "Yakut", [ 1 ], 3 ], [ "sco", "Scots", [ 1, 2 ], 2 ], [ "se", "Northern Sami", [ 1, 2 ], 2 ], [ "si", "Sinhala", [ 1, 2 ], 2 ], [ "sk", "Slovak", [ 1, 2, 5 ], 6 ], [ "sl", "Slovenian", [ 5, 1, 2, 3 ], 21 ], [ "so", "Somali", [ 1, 2 ], 2 ], [ "son", "Songhay", [ 1, 2 ], 2 ], [ "sq", "Albanian", [ 1, 2 ], 2 ], [ "sr", "Serbian", [ 1, 2, 5 ], 4 ], [ "su", "Sundanese", [ 1 ], 3 ], [ "sv", "Swedish", [ 1, 2 ], 2 ], [ "sw", "Swahili", [ 1, 2 ], 2 ], [ "ta", "Tamil", [ 1, 2 ], 2 ], [ "te", "Telugu", [ 1, 2 ], 2 ], [ "tg", "Tajik", [ 1, 2 ], 1 ], [ "th", "Thai", [ 1 ], 3 ], [ "ti", "Tigrinya", [ 1, 2 ], 1 ], [ "tk", "Turkmen", [ 1, 2 ], 2 ], [ "tr", "Turkish", [ 1, 2 ], 1 ], [ "tt", "Tatar", [ 1 ], 3 ], [ "ug", "Uyghur", [ 1 ], 3 ], [ "uk", "Ukrainian", [ 1, 2, 5 ], 4 ], [ "ur", "Urdu", [ 1, 2 ], 2 ], [ "uz", "Uzbek", [ 1, 2 ], 1 ], [ "vi", "Vietnamese", [ 1 ], 3 ], [ "wa", "Walloon", [ 1, 2 ], 1 ], [ "wo", "Wolof", [ 1 ], 3 ], [ "yo", "Yoruba", [ 1, 2 ], 2 ], [ "zh", "Chinese", [ 1 ], 3 ] ], _rulesPluralsTypes = {
        1: function(n) {
            return Number(1 < n);
        },
        2: function(n) {
            return Number(1 != n);
        },
        3: function(n) {
            return 0;
        },
        4: function(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : 2 <= n % 10 && n % 10 <= 4 && (n % 100 < 10 || 20 <= n % 100) ? 1 : 2);
        },
        5: function(n) {
            return Number(0 === n ? 0 : 1 == n ? 1 : 2 == n ? 2 : 3 <= n % 100 && n % 100 <= 10 ? 3 : 11 <= n % 100 ? 4 : 5);
        },
        6: function(n) {
            return Number(1 == n ? 0 : 2 <= n && n <= 4 ? 1 : 2);
        },
        7: function(n) {
            return Number(1 == n ? 0 : 2 <= n % 10 && n % 10 <= 4 && (n % 100 < 10 || 20 <= n % 100) ? 1 : 2);
        },
        8: function(n) {
            return Number(1 == n ? 0 : 2 == n ? 1 : 8 != n && 11 != n ? 2 : 3);
        },
        9: function(n) {
            return Number(2 <= n);
        },
        10: function(n) {
            return Number(1 == n ? 0 : 2 == n ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
        },
        11: function(n) {
            return Number(1 == n || 11 == n ? 0 : 2 == n || 12 == n ? 1 : 2 < n && n < 20 ? 2 : 3);
        },
        12: function(n) {
            return Number(n % 10 != 1 || n % 100 == 11);
        },
        13: function(n) {
            return Number(0 !== n);
        },
        14: function(n) {
            return Number(1 == n ? 0 : 2 == n ? 1 : 3 == n ? 2 : 3);
        },
        15: function(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : 2 <= n % 10 && (n % 100 < 10 || 20 <= n % 100) ? 1 : 2);
        },
        16: function(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : 0 !== n ? 1 : 2);
        },
        17: function(n) {
            return Number(1 == n || n % 10 == 1 ? 0 : 1);
        },
        18: function(n) {
            return Number(1 == n ? 1 : 2);
        },
        19: function(n) {
            return Number(1 == n ? 0 : 0 === n || 1 < n % 100 && n % 100 < 11 ? 1 : 10 < n % 100 && n % 100 < 20 ? 2 : 3);
        },
        20: function(n) {
            return Number(1 == n ? 0 : 0 === n || 0 < n % 100 && n % 100 < 20 ? 1 : 2);
        },
        21: function(n) {
            return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
        }
    }, pluralExtensions = {
        rules: function() {
            for (var rules = {}, l = _rules.length; l--; ) rules[_rules[l][0]] = {
                name: _rules[l][1],
                numbers: _rules[l][2],
                plurals: _rulesPluralsTypes[_rules[l][3]]
            };
            return rules;
        }(),
        addRule: function(lng, obj) {
            pluralExtensions.rules[lng] = obj;
        },
        setCurrentLng: function(lng) {
            var parts;
            pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng || (parts = lng.split("-"), 
            pluralExtensions.currentRule = {
                lng: lng,
                rule: pluralExtensions.rules[parts[0]]
            });
        },
        needsPlural: function(lng, count) {
            var ext = lng.split("-"), ext = pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng ? pluralExtensions.currentRule.rule : pluralExtensions.rules[ext[f.getCountyIndexOfLng(lng)]];
            return !(ext && ext.numbers.length <= 1) && 1 !== this.get(lng, count);
        },
        get: function(lng, count) {
            return function(number, c) {
                var ext = pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng ? pluralExtensions.currentRule.rule : pluralExtensions.rules[number];
                if (ext) {
                    number = ext.noAbs ? ext.plurals(c) : ext.plurals(Math.abs(c)), number = ext.numbers[number];
                    return 2 === ext.numbers.length && 1 === ext.numbers[0] && (2 === number ? number = -1 : 1 === number && (number = 1)), 
                    number;
                }
                return 1 === c ? "1" : "-1";
            }(lng.split("-")[f.getCountyIndexOfLng(lng)], count);
        }
    }, postProcessors = {}, addPostProcessor = function(name, fc) {
        postProcessors[name] = fc;
    }, sprintf = ((str_format = function() {
        return str_format.cache.hasOwnProperty(arguments[0]) || (str_format.cache[arguments[0]] = str_format.parse(arguments[0])), 
        str_format.format.call(null, str_format.cache[arguments[0]], arguments);
    }).format = function(parse_tree, argv) {
        for (var node_type, arg, k, match, pad_character, pad, cursor = 1, tree_length = parse_tree.length, output = [], i = 0; i < tree_length; i++) if ("string" === (node_type = get_type(parse_tree[i]))) output.push(parse_tree[i]); else if ("array" === node_type) {
            if ((match = parse_tree[i])[2]) for (arg = argv[cursor], k = 0; k < match[2].length; k++) {
                if (!arg.hasOwnProperty(match[2][k])) throw sprintf('[sprintf] property "%s" does not exist', match[2][k]);
                arg = arg[match[2][k]];
            } else arg = match[1] ? argv[match[1]] : argv[cursor++];
            if (/[^s]/.test(match[8]) && "number" != get_type(arg)) throw sprintf("[sprintf] expecting number but found %s", get_type(arg));
            switch (match[8]) {
              case "b":
                arg = arg.toString(2);
                break;

              case "c":
                arg = String.fromCharCode(arg);
                break;

              case "d":
                arg = parseInt(arg, 10);
                break;

              case "e":
                arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                break;

              case "f":
                arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                break;

              case "o":
                arg = arg.toString(8);
                break;

              case "s":
                arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
                break;

              case "u":
                arg = Math.abs(arg);
                break;

              case "x":
                arg = arg.toString(16);
                break;

              case "X":
                arg = arg.toString(16).toUpperCase();
            }
            arg = /[def]/.test(match[8]) && match[3] && 0 <= arg ? "+" + arg : arg, pad_character = match[4] ? "0" == match[4] ? "0" : match[4].charAt(1) : " ", 
            pad = match[6] - String(arg).length, pad = match[6] ? function(input, multiplier) {
                for (var output = []; 0 < multiplier; output[--multiplier] = input) ;
                return output.join("");
            }(pad_character, pad) : "", output.push(match[5] ? arg + pad : pad + arg);
        }
        return output.join("");
    }, str_format.cache = {}, str_format.parse = function(fmt) {
        for (var _fmt = fmt, match = [], parse_tree = [], arg_names = 0; _fmt; ) {
            if (null !== (match = /^[^\x25]+/.exec(_fmt))) parse_tree.push(match[0]); else if (null !== (match = /^\x25{2}/.exec(_fmt))) parse_tree.push("%"); else {
                if (null === (match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt))) throw "[sprintf] huh?";
                if (match[2]) {
                    arg_names |= 1;
                    var field_list = [], replacement_field = match[2], field_match = [];
                    if (null === (field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field))) throw "[sprintf] huh?";
                    for (field_list.push(field_match[1]); "" !== (replacement_field = replacement_field.substring(field_match[0].length)); ) if (null !== (field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field))) field_list.push(field_match[1]); else {
                        if (null === (field_match = /^\[(\d+)\]/.exec(replacement_field))) throw "[sprintf] huh?";
                        field_list.push(field_match[1]);
                    }
                    match[2] = field_list;
                } else arg_names |= 2;
                if (3 === arg_names) throw "[sprintf] mixing positional and named placeholders is not (yet) supported";
                parse_tree.push(match);
            }
            _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
    }, str_format);
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
    }
    addPostProcessor("sprintf", function(val, key, opts) {
        return opts.sprintf ? "[object Array]" === Object.prototype.toString.apply(opts.sprintf) ? (fmt = val, 
        (argv = opts.sprintf).unshift(fmt), sprintf.apply(null, argv)) : "object" == typeof opts.sprintf ? sprintf(val, opts.sprintf) : val : val;
        var fmt, argv;
    }), i18n.init = init, i18n.isInitialized = function() {
        return initialized;
    }, i18n.setLng = setLng, i18n.preload = function(lngs, cb) {
        for (var i = 0, l = (lngs = "string" == typeof lngs ? [ lngs ] : lngs).length; i < l; i++) o.preload.indexOf(lngs[i]) < 0 && o.preload.push(lngs[i]);
        return init(cb);
    }, i18n.addResourceBundle = function(lng, ns, resources, deep) {
        "string" != typeof ns ? (resources = ns, ns = o.ns.defaultNs) : o.ns.namespaces.indexOf(ns) < 0 && o.ns.namespaces.push(ns), 
        resStore[lng] = resStore[lng] || {}, resStore[lng][ns] = resStore[lng][ns] || {}, 
        deep ? f.deepExtend(resStore[lng][ns], resources) : f.extend(resStore[lng][ns], resources), 
        o.useLocalStorage && sync._storeLocal(resStore);
    }, i18n.hasResourceBundle = function(lng, ns) {
        "string" != typeof ns && (ns = o.ns.defaultNs), resStore[lng] = resStore[lng] || {};
        var prop, res = resStore[lng][ns] || {}, hasValues = !1;
        for (prop in res) res.hasOwnProperty(prop) && (hasValues = !0);
        return hasValues;
    }, i18n.getResourceBundle = function(lng, ns) {
        return "string" != typeof ns && (ns = o.ns.defaultNs), resStore[lng] = resStore[lng] || {}, 
        f.extend({}, resStore[lng][ns]);
    }, i18n.addResource = addResource, i18n.addResources = function(lng, ns, resources) {
        for (var m in "string" != typeof ns ? (resource = ns, ns = o.ns.defaultNs) : o.ns.namespaces.indexOf(ns) < 0 && o.ns.namespaces.push(ns), 
        resources) "string" == typeof resources[m] && addResource(lng, ns, m, resources[m]);
    }, i18n.removeResourceBundle = function(lng, ns) {
        "string" != typeof ns && (ns = o.ns.defaultNs), resStore[lng] = resStore[lng] || {}, 
        resStore[lng][ns] = {}, o.useLocalStorage && sync._storeLocal(resStore);
    }, i18n.loadNamespace = function(namespace, cb) {
        loadNamespaces([ namespace ], cb);
    }, i18n.loadNamespaces = loadNamespaces, i18n.setDefaultNamespace = function(ns) {
        o.ns.defaultNs = ns;
    }, i18n.t = translate, i18n.translate = translate, i18n.exists = exists, i18n.detectLanguage = f.detectLanguage, 
    i18n.pluralExtensions = pluralExtensions, i18n.sync = sync, i18n.functions = f, 
    i18n.lng = function() {
        return currentLng;
    }, i18n.addPostProcessor = addPostProcessor, i18n.applyReplacement = f.applyReplacement, 
    i18n.options = o, i18n.noConflict = function() {
        window.i18next = window.i18n, conflictReference ? window.i18n = conflictReference : delete window.i18n;
    };
}("undefined" == typeof exports ? window : exports), angular.module("jm.i18next", [ "ng", "ngSanitize" ]), 
angular.module("jm.i18next").provider("$i18next", function() {
    "use strict";
    var self = this, t = null, translations = {}, globalOptions = {}, triesToLoadI18next = 0;
    self.options = globalOptions, self.$get = [ "$rootScope", "$timeout", "$q", function($rootScope, $timeout, $q) {
        var i18nDeferred;
        function optionsChange(newOptions, oldOptions) {
            return $i18nextTanslate.debugMsg.push([ "i18next options changed:", oldOptions, newOptions ]), 
            function init(options) {
                options.noConflict && window.i18n && window.i18n.noConflict();
                var i18n = window.i18next || window.i18n;
                if (i18n) return i18nDeferred = $q.defer(), i18n.init(options, function(localize) {
                    translations = {}, t = localize, $rootScope.$$phase || $rootScope.$digest(), $rootScope.$broadcast("i18nextLanguageChange", i18n.lng()), 
                    i18nDeferred.resolve();
                }), i18nDeferred.promise;
                if (!(++triesToLoadI18next < 5)) throw new Error("[ng-i18next] Can't find i18next!");
                $timeout(function() {
                    return init(options);
                }, 400);
            }(globalOptions = newOptions);
        }
        function $i18nextTanslate(key, mergedOptions) {
            var hasOwnOptions = !!mergedOptions, hasOwnNsOption = hasOwnOptions && mergedOptions.ns, hasGlobalNsObj = globalOptions && globalOptions.ns, lng = globalOptions;
            return !hasOwnNsOption && hasGlobalNsObj && ((lng = angular.copy(globalOptions)).ns = lng.ns.defaultNs), 
            lng = (mergedOptions = hasOwnOptions ? angular.extend({}, lng, mergedOptions) : lng).lng, 
            function(key, options, hasOwnOptions) {
                var lng = options.lng || "auto";
                translations[lng] || (translations[lng] = {}), t ? translations[lng][key] && !hasOwnOptions || (translations[lng][key] = t(key, options)) : translations[lng][key] = "defaultLoadingValue" in options ? options.defaultLoadingValue : "defaultValue" in options ? options.defaultValue : "defaultLoadingValue" in globalOptions ? globalOptions.defaultLoadingValue : key;
            }(key, mergedOptions, hasOwnOptions), (lng ? translations[lng] : translations.auto)[key];
        }
        return $i18nextTanslate.debugMsg = [], $i18nextTanslate.options = self.options, 
        self.options !== globalOptions && optionsChange(self.options, globalOptions), $i18nextTanslate.reInit = function() {
            return optionsChange(globalOptions, globalOptions);
        }, $rootScope.$watch(function() {
            return $i18nextTanslate.options;
        }, function(newOptions, oldOptions) {
            !newOptions || oldOptions === newOptions && globalOptions === newOptions || optionsChange(newOptions, oldOptions);
        }, !0), $i18nextTanslate;
    } ];
}), angular.module("jm.i18next").directive("ngI18next", [ "$i18next", "$compile", "$parse", "$interpolate", "$sanitize", function($i18next, $compile, $parse, $interpolate, $sanitize) {
    "use strict";
    function parseKey(key) {
        var tmp, options = {
            attr: "text"
        }, i18nOptions = "{}";
        return 0 === (key = key.trim()).indexOf("[") && (options = function(options) {
            var res = {
                attr: "text"
            };
            options = options.split(":");
            for (var i = 0; i < options.length; ++i) "i18next" === options[i] ? res[options[i]] = !0 : res.attr = options[i];
            return res;
        }((tmp = key.split("]")).shift().substr(1).trim()), key = tmp.join("]")), options.i18next && 0 === key.indexOf("(") && 0 <= key.indexOf(")") && (key = (tmp = key.split(")")).pop().trim(), 
        i18nOptions = tmp.join(")").substr(1).trim()), {
            key: key,
            options: options,
            i18nOptions: $parse(i18nOptions)
        };
    }
    return {
        restrict: "A",
        scope: !1,
        controller: [ "$scope", "$element", function($scope, $element) {
            var argsUnregister, stringUnregister;
            this.localize = function(key, noWatch) {
                for (var keys = key.split(";"), i = 0; i < keys.length; ++i) "" !== (key = keys[i].trim()) && function(key, noWatch) {
                    var parsedKey = parseKey(key);
                    function render(i18nOptions) {
                        i18nOptions.sprintf && (i18nOptions.postProcess = "sprintf"), "html" === parsedKey.options.attr && angular.forEach(i18nOptions, function(value, key) {
                            i18nOptions[key] = $sanitize(value);
                        });
                        var string = $i18next(parsedKey.key, i18nOptions);
                        if ("html" === parsedKey.options.attr) return $element.empty().append(string), void $compile($element.contents())($scope);
                        stringUnregister && stringUnregister();
                        var insertText = $element.text.bind($element);
                        "text" !== parsedKey.options.attr && (insertText = $element.attr.bind($element, parsedKey.options.attr)), 
                        string = $interpolate(string), noWatch || (stringUnregister = $scope.$watch(string, insertText)), 
                        insertText(string($scope));
                    }
                    argsUnregister && argsUnregister(), stringUnregister && stringUnregister(), noWatch || (argsUnregister = $scope.$watch(parsedKey.i18nOptions, render, !0)), 
                    render(parsedKey.i18nOptions($scope));
                }(key, noWatch);
            };
        } ],
        require: "ngI18next",
        link: function(scope, element, attrs, ctrl) {
            var translationValue = "";
            function observe(value) {
                if ("" === (translationValue = value.replace(/^\s+|\s+$/g, ""))) return setupWatcher();
                ctrl.localize(translationValue);
            }
            function setupWatcher() {
                var interpolation;
                setupWatcher.done || (interpolation = $interpolate(element.html()), scope.$watch(interpolation, observe), 
                setupWatcher.done = !0);
            }
            (translationValue = attrs.ngI18next.replace(/^\s+|\s+$/g, "")).indexOf("__once__") < 0 ? attrs.$observe("ngI18next", observe) : (translationValue = translationValue.split("__once__").join(""), 
            ctrl.localize(translationValue, !0)), scope.$on("i18nextLanguageChange", function() {
                ctrl.localize(translationValue);
            });
        }
    };
} ]), angular.module("jm.i18next").directive("boI18next", [ "$i18next", "$compile", function($i18next, $compile) {
    "use strict";
    return {
        restrict: "A",
        scope: !1,
        link: function(scope, element, attrs) {
            var newElement = element.clone();
            newElement.attr("ng-i18next", "__once__" + attrs.boI18next), newElement.removeAttr("bo-i18next"), 
            element.replaceWith($compile(newElement)(scope));
        }
    };
} ]), angular.module("jm.i18next").filter("i18next", [ "$i18next", function($i18next) {
    "use strict";
    function i18nextFilter(string, options) {
        return $i18next(string, options);
    }
    return i18nextFilter.$stateful = !0, i18nextFilter;
} ]), function(dndLists) {
    var MIME_TYPE = "application/x-dnd", ALL_EFFECTS = [ "move", "copy", "link" ];
    function filterEffects(effects, effectAllowed) {
        return "all" == effectAllowed ? effects : effects.filter(function(effect) {
            return -1 != effectAllowed.toLowerCase().indexOf(effect);
        });
    }
    dndLists.directive("dndDraggable", [ "$parse", "$timeout", function($parse, $timeout) {
        return function(scope, element, attr) {
            element.attr("draggable", "true"), attr.dndDisableIf && scope.$watch(attr.dndDisableIf, function(disabled) {
                element.attr("draggable", !disabled);
            }), element.on("dragstart", function(event) {
                if (event = event.originalEvent || event, "false" == element.attr("draggable")) return !0;
                dndState.isDragging = !0, dndState.itemType = attr.dndType && scope.$eval(attr.dndType).toLowerCase(), 
                dndState.dropEffect = "none", dndState.effectAllowed = attr.dndEffectAllowed || ALL_EFFECTS[0], 
                event.dataTransfer.effectAllowed = dndState.effectAllowed;
                var callback, item = scope.$eval(attr.dndDraggable), mimeType = MIME_TYPE + (dndState.itemType ? "-" + dndState.itemType : "");
                try {
                    event.dataTransfer.setData(mimeType, angular.toJson(item));
                } catch (e) {
                    var data = angular.toJson({
                        item: item,
                        type: dndState.itemType
                    });
                    try {
                        event.dataTransfer.setData("application/json", data);
                    } catch (e) {
                        var effectsAllowed = filterEffects(ALL_EFFECTS, dndState.effectAllowed);
                        event.dataTransfer.effectAllowed = effectsAllowed[0], event.dataTransfer.setData("Text", data);
                    }
                }
                element.addClass("dndDragging"), $timeout(function() {
                    element.addClass("dndDraggingSource");
                }, 0), event._dndHandle && event.dataTransfer.setDragImage && event.dataTransfer.setDragImage(element[0], 0, 0), 
                $parse(attr.dndDragstart)(scope, {
                    event: event
                }), attr.dndCallback && (callback = $parse(attr.dndCallback), dndState.callback = function(params) {
                    return callback(scope, params || {});
                }), event.stopPropagation();
            }), element.on("dragend", function(event) {
                event = event.originalEvent || event, scope.$apply(function() {
                    var dropEffect = dndState.dropEffect;
                    $parse(attr[{
                        copy: "dndCopied",
                        link: "dndLinked",
                        move: "dndMoved",
                        none: "dndCanceled"
                    }[dropEffect]])(scope, {
                        event: event
                    }), $parse(attr.dndDragend)(scope, {
                        event: event,
                        dropEffect: dropEffect
                    });
                }), dndState.isDragging = !1, dndState.callback = void 0, element.removeClass("dndDragging"), 
                element.removeClass("dndDraggingSource"), event.stopPropagation(), $timeout(function() {
                    element.removeClass("dndDraggingSource");
                }, 0);
            }), element.on("click", function(event) {
                attr.dndSelected && (event = event.originalEvent || event, scope.$apply(function() {
                    $parse(attr.dndSelected)(scope, {
                        event: event
                    });
                }), event.stopPropagation());
            }), element.on("selectstart", function() {
                this.dragDrop && this.dragDrop();
            });
        };
    } ]), dndLists.directive("dndList", [ "$parse", function($parse) {
        return function(scope, element, attr) {
            var placeholder = function() {
                var placeholder;
                return angular.forEach(element.children(), function(child) {
                    child = angular.element(child);
                    child.hasClass("dndPlaceholder") && (placeholder = child);
                }), placeholder || angular.element("<li class='dndPlaceholder'></li>");
            }();
            placeholder.remove();
            var placeholderNode = placeholder[0], listNode = element[0], listSettings = {};
            function getMimeType(types) {
                if (!types) return "Text";
                for (var i = 0; i < types.length; i++) if ("Text" == types[i] || "application/json" == types[i] || types[i].substr(0, MIME_TYPE.length) == MIME_TYPE) return types[i];
                return null;
            }
            function getItemType(mimeType) {
                return dndState.isDragging ? dndState.itemType || void 0 : "Text" == mimeType || "application/json" == mimeType ? null : mimeType && mimeType.substr(MIME_TYPE.length + 1) || void 0;
            }
            function isDropAllowed(itemType) {
                return !listSettings.disabled && ((listSettings.externalSources || dndState.isDragging) && (!listSettings.allowedTypes || null === itemType || itemType && -1 != listSettings.allowedTypes.indexOf(itemType)));
            }
            function getDropEffect(event, ignoreDataTransfer) {
                var effects = ALL_EFFECTS;
                return ignoreDataTransfer || (effects = filterEffects(effects, event.dataTransfer.effectAllowed)), 
                dndState.isDragging && (effects = filterEffects(effects, dndState.effectAllowed)), 
                (effects = attr.dndEffectAllowed ? filterEffects(effects, attr.dndEffectAllowed) : effects).length ? event.ctrlKey && -1 != effects.indexOf("copy") ? "copy" : event.altKey && -1 != effects.indexOf("link") ? "link" : effects[0] : "none";
            }
            function stopDragover() {
                return placeholder.remove(), element.removeClass("dndDragover"), !0;
            }
            function invokeCallback(expression, event, dropEffect, itemType, index, item) {
                return $parse(expression)(scope, {
                    callback: dndState.callback,
                    dropEffect: dropEffect,
                    event: event,
                    external: !dndState.isDragging,
                    index: void 0 !== index ? index : getPlaceholderIndex(),
                    item: item || void 0,
                    type: itemType
                });
            }
            function getPlaceholderIndex() {
                return Array.prototype.indexOf.call(listNode.children, placeholderNode);
            }
            element.on("dragenter", function(event) {
                event = event.originalEvent || event;
                var mimeType = attr.dndAllowedTypes && scope.$eval(attr.dndAllowedTypes);
                listSettings = {
                    allowedTypes: angular.isArray(mimeType) && mimeType.join("|").toLowerCase().split("|"),
                    disabled: attr.dndDisableIf && scope.$eval(attr.dndDisableIf),
                    externalSources: attr.dndExternalSources && scope.$eval(attr.dndExternalSources),
                    horizontal: attr.dndHorizontalList && scope.$eval(attr.dndHorizontalList)
                };
                mimeType = getMimeType(event.dataTransfer.types);
                if (!mimeType || !isDropAllowed(getItemType(mimeType))) return !0;
                event.preventDefault();
            }), element.on("dragover", function(event) {
                var dropEffect = getMimeType((event = event.originalEvent || event).dataTransfer.types), itemType = getItemType(dropEffect);
                if (!dropEffect || !isDropAllowed(itemType)) return !0;
                if (placeholderNode.parentNode != listNode && element.append(placeholder), event.target != listNode) {
                    for (var listItemNode = event.target; listItemNode.parentNode != listNode && listItemNode.parentNode; ) listItemNode = listItemNode.parentNode;
                    listItemNode.parentNode == listNode && listItemNode != placeholderNode && (ignoreDataTransfer = listItemNode.getBoundingClientRect(), 
                    ignoreDataTransfer = listSettings.horizontal ? event.clientX < ignoreDataTransfer.left + ignoreDataTransfer.width / 2 : event.clientY < ignoreDataTransfer.top + ignoreDataTransfer.height / 2, 
                    listNode.insertBefore(placeholderNode, ignoreDataTransfer ? listItemNode : listItemNode.nextSibling));
                }
                var ignoreDataTransfer = "Text" == dropEffect, dropEffect = getDropEffect(event, ignoreDataTransfer);
                return "none" == dropEffect || attr.dndDragover && !invokeCallback(attr.dndDragover, event, dropEffect, itemType) ? stopDragover() : (event.preventDefault(), 
                ignoreDataTransfer || (event.dataTransfer.dropEffect = dropEffect), element.addClass("dndDragover"), 
                event.stopPropagation(), !1);
            }), element.on("drop", function(event) {
                var mimeType = getMimeType((event = event.originalEvent || event).dataTransfer.types), itemType = getItemType(mimeType);
                if (!mimeType || !isDropAllowed(itemType)) return !0;
                event.preventDefault();
                try {
                    var data = JSON.parse(event.dataTransfer.getData(mimeType));
                } catch (e) {
                    return stopDragover();
                }
                if (("Text" == mimeType || "application/json" == mimeType) && (itemType = data.type || void 0, 
                data = data.item, !isDropAllowed(itemType))) return stopDragover();
                var ignoreDataTransfer = "Text" == mimeType, dropEffect = getDropEffect(event, ignoreDataTransfer);
                if ("none" == dropEffect) return stopDragover();
                var index = getPlaceholderIndex();
                return attr.dndDrop && !(data = invokeCallback(attr.dndDrop, event, dropEffect, itemType, index, data)) ? stopDragover() : (dndState.dropEffect = dropEffect, 
                ignoreDataTransfer || (event.dataTransfer.dropEffect = dropEffect), !0 !== data && scope.$apply(function() {
                    scope.$eval(attr.dndList).splice(index, 0, data);
                }), invokeCallback(attr.dndInserted, event, dropEffect, itemType, index, data), 
                stopDragover(), event.stopPropagation(), !1);
            }), element.on("dragleave", function(event) {
                event = event.originalEvent || event;
                var newTarget = document.elementFromPoint(event.clientX, event.clientY);
                listNode.contains(newTarget) && !event._dndPhShown ? event._dndPhShown = !0 : stopDragover();
            });
        };
    } ]), dndLists.directive("dndNodrag", function() {
        return function(scope, element, attr) {
            element.attr("draggable", "true"), element.on("dragstart", function(event) {
                (event = event.originalEvent || event)._dndHandle || (event.dataTransfer.types && event.dataTransfer.types.length || event.preventDefault(), 
                event.stopPropagation());
            }), element.on("dragend", function(event) {
                (event = event.originalEvent || event)._dndHandle || event.stopPropagation();
            });
        };
    }), dndLists.directive("dndHandle", function() {
        return function(scope, element, attr) {
            element.attr("draggable", "true"), element.on("dragstart dragend", function(event) {
                (event = event.originalEvent || event)._dndHandle = !0;
            });
        };
    });
    var dndState = {};
}(angular.module("dndLists", [])), (mod = angular.module("infinite-scroll", [])).value("THROTTLE_MILLISECONDS", null), 
mod.directive("infiniteScroll", [ "$rootScope", "$window", "$interval", "THROTTLE_MILLISECONDS", function($rootScope, $window, $interval, THROTTLE_MILLISECONDS) {
    return {
        scope: {
            infiniteScroll: "&",
            infiniteScrollContainer: "=",
            infiniteScrollDistance: "=",
            infiniteScrollDisabled: "=",
            infiniteScrollUseDocumentBottom: "="
        },
        link: function(scope, elem, attrs) {
            var changeContainer, handleInfiniteScrollContainer, windowElement = angular.element($window), scrollDistance = null, scrollEnabled = null, checkWhenEnabled = null, container = null, immediateCheck = !0, useDocumentBottom = !1, height = function(elem) {
                return elem = elem[0] || elem, isNaN(elem.offsetHeight) ? elem.document.documentElement.clientHeight : elem.offsetHeight;
            }, offsetTop = function(elem) {
                if (elem[0].getBoundingClientRect && !elem.css("none")) return elem[0].getBoundingClientRect().top + pageYOffset(elem);
            }, pageYOffset = function(elem) {
                return elem = elem[0] || elem, isNaN(window.pageYOffset) ? elem.document.documentElement.scrollTop : elem.ownerDocument.defaultView.pageYOffset;
            }, handler = function() {
                var containerBottom, elementBottom = container === windowElement ? (containerBottom = height(container) + pageYOffset(container[0].document.documentElement), 
                offsetTop(elem) + height(elem)) : (containerBottom = height(container), void (elementBottom = 0) !== offsetTop(container) && (elementBottom = offsetTop(container)), 
                offsetTop(elem) - elementBottom + height(elem));
                return (elementBottom = useDocumentBottom ? height((elem[0].ownerDocument || elem[0].document).documentElement) : elementBottom) - containerBottom <= height(container) * scrollDistance + 1 ? (checkWhenEnabled = !0, 
                scrollEnabled ? scope.$$phase || $rootScope.$$phase ? scope.infiniteScroll() : scope.$apply(scope.infiniteScroll) : void 0) : checkWhenEnabled = !1;
            };
            return null != THROTTLE_MILLISECONDS && (handler = function(func, wait) {
                var timeout = null, previous = 0, later = function() {
                    return previous = new Date().getTime(), $interval.cancel(timeout), timeout = null, 
                    func.call(), null;
                };
                return function() {
                    var now = new Date().getTime(), remaining = wait - (now - previous);
                    return remaining <= 0 ? (clearTimeout(timeout), $interval.cancel(timeout), timeout = null, 
                    previous = now, func.call()) : timeout ? void 0 : timeout = $interval(later, remaining, 1);
                };
            }(handler, THROTTLE_MILLISECONDS)), scope.$on("$destroy", function() {
                return container.unbind("scroll", handler);
            }), handleInfiniteScrollContainer = function(v) {
                return scrollDistance = parseFloat(v) || 0;
            }, scope.$watch("infiniteScrollDistance", handleInfiniteScrollContainer), handleInfiniteScrollContainer(scope.infiniteScrollDistance), 
            handleInfiniteScrollContainer = function(v) {
                if ((scrollEnabled = !v) && checkWhenEnabled) return checkWhenEnabled = !1, handler();
            }, scope.$watch("infiniteScrollDisabled", handleInfiniteScrollContainer), handleInfiniteScrollContainer(scope.infiniteScrollDisabled), 
            handleInfiniteScrollContainer = function(v) {
                return useDocumentBottom = v;
            }, scope.$watch("infiniteScrollUseDocumentBottom", handleInfiniteScrollContainer), 
            handleInfiniteScrollContainer(scope.infiniteScrollUseDocumentBottom), (changeContainer = function(newContainer) {
                if (null != container && container.unbind("scroll", handler), null != (container = newContainer)) return container.bind("scroll", handler);
            })(windowElement), handleInfiniteScrollContainer = function(newContainer) {
                if (null != newContainer && 0 !== newContainer.length) {
                    if (newContainer instanceof HTMLElement ? newContainer = angular.element(newContainer) : "function" == typeof newContainer.append ? newContainer = angular.element(newContainer[newContainer.length - 1]) : "string" == typeof newContainer && (newContainer = angular.element(document.querySelector(newContainer))), 
                    null != newContainer) return changeContainer(newContainer);
                    throw new Exception("invalid infinite-scroll-container attribute.");
                }
            }, scope.$watch("infiniteScrollContainer", handleInfiniteScrollContainer), handleInfiniteScrollContainer(scope.infiniteScrollContainer || []), 
            null != attrs.infiniteScrollParent && changeContainer(angular.element(elem.parent())), 
            null != attrs.infiniteScrollImmediateCheck && (immediateCheck = scope.$eval(attrs.infiniteScrollImmediateCheck)), 
            $interval(function() {
                if (immediateCheck) return handler();
            }, 0, 1);
        }
    };
} ]), function(root, factory) {
    "function" == typeof define && define.amd ? define([], factory) : "object" == typeof module && "undefined" != typeof exports ? module.exports = factory() : root.Papa = factory();
}(this, function moduleFactory() {
    "use strict";
    var global = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== global ? global : {};
    var $, IS_WORKER = !global.document && !!global.postMessage, IS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol), workers = {}, workerIdCounter = 0, Papa = {};
    function ChunkStreamer(config) {
        this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, 
        this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, 
        this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = {
            data: [],
            errors: [],
            meta: {}
        }, function(config) {
            var configCopy = copy(config);
            configCopy.chunkSize = parseInt(configCopy.chunkSize), config.step || config.chunk || (configCopy.chunkSize = null);
            this._handle = new ParserHandle(configCopy), (this._handle.streamer = this)._config = configCopy;
        }.call(this, config), this.parseChunk = function(finishedIncludingPreview, isFakeChunk) {
            this.isFirstChunk && isFunction(this._config.beforeFirstChunk) && (void 0 !== (results = this._config.beforeFirstChunk(finishedIncludingPreview)) && (finishedIncludingPreview = results)), 
            this.isFirstChunk = !1, this._halted = !1;
            var aggregate = this._partialLine + finishedIncludingPreview;
            this._partialLine = "";
            var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);
            if (!this._handle.paused() && !this._handle.aborted()) {
                finishedIncludingPreview = results.meta.cursor;
                this._finished || (this._partialLine = aggregate.substring(finishedIncludingPreview - this._baseIndex), 
                this._baseIndex = finishedIncludingPreview), results && results.data && (this._rowCount += results.data.length);
                finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;
                if (IS_PAPA_WORKER) global.postMessage({
                    results: results,
                    workerId: Papa.WORKER_ID,
                    finished: finishedIncludingPreview
                }); else if (isFunction(this._config.chunk) && !isFakeChunk) {
                    if (this._config.chunk(results, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
                    results = void 0, this._completeResults = void 0;
                }
                return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(results.data), 
                this._completeResults.errors = this._completeResults.errors.concat(results.errors), 
                this._completeResults.meta = results.meta), this._completed || !finishedIncludingPreview || !isFunction(this._config.complete) || results && results.meta.aborted || (this._config.complete(this._completeResults, this._input), 
                this._completed = !0), finishedIncludingPreview || results && results.meta.paused || this._nextChunk(), 
                results;
            }
            this._halted = !0;
        }, this._sendError = function(error) {
            isFunction(this._config.error) ? this._config.error(error) : IS_PAPA_WORKER && this._config.error && global.postMessage({
                workerId: Papa.WORKER_ID,
                error: error,
                finished: !1
            });
        };
    }
    function NetworkStreamer(config) {
        var xhr;
        (config = config || {}).chunkSize || (config.chunkSize = Papa.RemoteChunkSize), 
        ChunkStreamer.call(this, config), this._nextChunk = IS_WORKER ? function() {
            this._readChunk(), this._chunkLoaded();
        } : function() {
            this._readChunk();
        }, this.stream = function(url) {
            this._input = url, this._nextChunk();
        }, this._readChunk = function() {
            if (this._finished) this._chunkLoaded(); else {
                if (xhr = new XMLHttpRequest(), this._config.withCredentials && (xhr.withCredentials = this._config.withCredentials), 
                IS_WORKER || (xhr.onload = bindFunction(this._chunkLoaded, this), xhr.onerror = bindFunction(this._chunkError, this)), 
                xhr.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !IS_WORKER), 
                this._config.downloadRequestHeaders) {
                    var headerName, headers = this._config.downloadRequestHeaders;
                    for (headerName in headers) xhr.setRequestHeader(headerName, headers[headerName]);
                }
                var end;
                this._config.chunkSize && (end = this._start + this._config.chunkSize - 1, xhr.setRequestHeader("Range", "bytes=" + this._start + "-" + end));
                try {
                    xhr.send(this._config.downloadRequestBody);
                } catch (err) {
                    this._chunkError(err.message);
                }
                IS_WORKER && 0 === xhr.status && this._chunkError();
            }
        }, this._chunkLoaded = function() {
            4 === xhr.readyState && (xhr.status < 200 || 400 <= xhr.status ? this._chunkError() : (this._start += this._config.chunkSize || xhr.responseText.length, 
            this._finished = !this._config.chunkSize || this._start >= function(contentRange) {
                contentRange = contentRange.getResponseHeader("Content-Range");
                return null !== contentRange ? parseInt(contentRange.substring(contentRange.lastIndexOf("/") + 1)) : -1;
            }(xhr), this.parseChunk(xhr.responseText)));
        }, this._chunkError = function(errorText) {
            errorText = xhr.statusText || errorText;
            this._sendError(new Error(errorText));
        };
    }
    function FileStreamer(config) {
        var reader, slice;
        (config = config || {}).chunkSize || (config.chunkSize = Papa.LocalChunkSize), ChunkStreamer.call(this, config);
        var usingAsyncReader = "undefined" != typeof FileReader;
        this.stream = function(file) {
            this._input = file, slice = file.slice || file.webkitSlice || file.mozSlice, usingAsyncReader ? ((reader = new FileReader()).onload = bindFunction(this._chunkLoaded, this), 
            reader.onerror = bindFunction(this._chunkError, this)) : reader = new FileReaderSync(), 
            this._nextChunk();
        }, this._nextChunk = function() {
            this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
            var end, txt = this._input;
            this._config.chunkSize && (end = Math.min(this._start + this._config.chunkSize, this._input.size), 
            txt = slice.call(txt, this._start, end));
            txt = reader.readAsText(txt, this._config.encoding);
            usingAsyncReader || this._chunkLoaded({
                target: {
                    result: txt
                }
            });
        }, this._chunkLoaded = function(event) {
            this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, 
            this.parseChunk(event.target.result);
        }, this._chunkError = function() {
            this._sendError(reader.error);
        };
    }
    function StringStreamer(config) {
        var remaining;
        ChunkStreamer.call(this, config = config || {}), this.stream = function(s) {
            return remaining = s, this._nextChunk();
        }, this._nextChunk = function() {
            if (!this._finished) {
                var chunk, size = this._config.chunkSize;
                return remaining = size ? (chunk = remaining.substring(0, size), remaining.substring(size)) : (chunk = remaining, 
                ""), this._finished = !remaining, this.parseChunk(chunk);
            }
        };
    }
    function ReadableStreamStreamer(config) {
        ChunkStreamer.call(this, config = config || {});
        var queue = [], parseOnData = !0, streamHasEnded = !1;
        this.pause = function() {
            ChunkStreamer.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
            ChunkStreamer.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(stream) {
            this._input = stream, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), 
            this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
            streamHasEnded && 1 === queue.length && (this._finished = !0);
        }, this._nextChunk = function() {
            this._checkIsFinished(), queue.length ? this.parseChunk(queue.shift()) : parseOnData = !0;
        }, this._streamData = bindFunction(function(chunk) {
            try {
                queue.push("string" == typeof chunk ? chunk : chunk.toString(this._config.encoding)), 
                parseOnData && (parseOnData = !1, this._checkIsFinished(), this.parseChunk(queue.shift()));
            } catch (error) {
                this._streamError(error);
            }
        }, this), this._streamError = bindFunction(function(error) {
            this._streamCleanUp(), this._sendError(error);
        }, this), this._streamEnd = bindFunction(function() {
            this._streamCleanUp(), streamHasEnded = !0, this._streamData("");
        }, this), this._streamCleanUp = bindFunction(function() {
            this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), 
            this._input.removeListener("error", this._streamError);
        }, this);
    }
    function DuplexStreamStreamer(_config) {
        var Duplex = require("stream").Duplex, config = copy(_config), parseOnWrite = !0, writeStreamHasFinished = !1, parseCallbackQueue = [], stream = null;
        this._onCsvData = function(data) {
            data = data.data;
            stream.push(data) || this._handle.paused() || this._handle.pause();
        }, this._onCsvComplete = function() {
            stream.push(null);
        }, config.step = bindFunction(this._onCsvData, this), config.complete = bindFunction(this._onCsvComplete, this), 
        ChunkStreamer.call(this, config), this._nextChunk = function() {
            writeStreamHasFinished && 1 === parseCallbackQueue.length && (this._finished = !0), 
            parseCallbackQueue.length ? parseCallbackQueue.shift()() : parseOnWrite = !0;
        }, this._addToParseQueue = function(chunk, callback) {
            parseCallbackQueue.push(bindFunction(function() {
                if (this.parseChunk("string" == typeof chunk ? chunk : chunk.toString(config.encoding)), 
                isFunction(callback)) return callback();
            }, this)), parseOnWrite && (parseOnWrite = !1, this._nextChunk());
        }, this._onRead = function() {
            this._handle.paused() && this._handle.resume();
        }, this._onWrite = function(chunk, encoding, callback) {
            this._addToParseQueue(chunk, callback);
        }, this._onWriteComplete = function() {
            writeStreamHasFinished = !0, this._addToParseQueue("");
        }, this.getStream = function() {
            return stream;
        }, (stream = new Duplex({
            readableObjectMode: !0,
            decodeStrings: !1,
            read: bindFunction(this._onRead, this),
            write: bindFunction(this._onWrite, this)
        })).once("finish", bindFunction(this._onWriteComplete, this));
    }
    function ParserHandle(_config) {
        var _input, _parser, _delimiterError, userStep, MAX_FLOAT = Math.pow(2, 53), MIN_FLOAT = -MAX_FLOAT, FLOAT = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)(e[-+]?\d+)?\s*$/, ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/, self = this, _stepCounter = 0, _rowCounter = 0, _paused = !1, _aborted = !1, _fields = [], _results = {
            data: [],
            errors: [],
            meta: {}
        };
        function testEmptyLine(s) {
            return "greedy" === _config.skipEmptyLines ? "" === s.join("").trim() : 1 === s.length && 0 === s[0].length;
        }
        function processResults() {
            if (_results && _delimiterError && (addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'"), 
            _delimiterError = !1), _config.skipEmptyLines) for (var i = 0; i < _results.data.length; i++) testEmptyLine(_results.data[i]) && _results.data.splice(i--, 1);
            return needsHeaderRow() && function() {
                if (_results) if (Array.isArray(_results.data[0])) {
                    for (var i = 0; needsHeaderRow() && i < _results.data.length; i++) _results.data[i].forEach(addHeder);
                    _results.data.splice(0, 1);
                } else _results.data.forEach(addHeder);
                function addHeder(header) {
                    isFunction(_config.transformHeader) && (header = _config.transformHeader(header)), 
                    _fields.push(header);
                }
            }(), function() {
                if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;
                function processRow(rowSource, i) {
                    for (var row = _config.header ? {} : [], j = 0; j < rowSource.length; j++) {
                        var field = j, value = rowSource[j], value = function(field, value) {
                            if (function(field) {
                                _config.dynamicTypingFunction && void 0 === _config.dynamicTyping[field] && (_config.dynamicTyping[field] = _config.dynamicTypingFunction(field));
                                return !0 === (_config.dynamicTyping[field] || _config.dynamicTyping);
                            }(field)) return "true" === value || "TRUE" === value || "false" !== value && "FALSE" !== value && (function(floatValue) {
                                if (FLOAT.test(floatValue)) {
                                    floatValue = parseFloat(floatValue);
                                    if (MIN_FLOAT < floatValue && floatValue < MAX_FLOAT) return 1;
                                }
                            }(value) ? parseFloat(value) : ISO_DATE.test(value) ? new Date(value) : "" === value ? null : value);
                            return value;
                        }(field = _config.header ? j >= _fields.length ? "__parsed_extra" : _fields[j] : field, value = _config.transform ? _config.transform(value, field) : value);
                        "__parsed_extra" === field ? (row[field] = row[field] || [], row[field].push(value)) : row[field] = value;
                    }
                    return _config.header && (j > _fields.length ? addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, _rowCounter + i) : j < _fields.length && addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, _rowCounter + i)), 
                    row;
                }
                var incrementBy = 1;
                !_results.data.length || Array.isArray(_results.data[0]) ? (_results.data = _results.data.map(processRow), 
                incrementBy = _results.data.length) : _results.data = processRow(_results.data, 0);
                _config.header && _results.meta && (_results.meta.fields = _fields);
                return _rowCounter += incrementBy, _results;
            }();
        }
        function needsHeaderRow() {
            return _config.header && 0 === _fields.length;
        }
        function addError(type, code, error, row) {
            error = {
                type: type,
                code: code,
                message: error
            };
            void 0 !== row && (error.row = row), _results.errors.push(error);
        }
        isFunction(_config.step) && (userStep = _config.step, _config.step = function(results) {
            _results = results, needsHeaderRow() ? processResults() : (processResults(), 0 !== _results.data.length && (_stepCounter += results.data.length, 
            _config.preview && _stepCounter > _config.preview ? _parser.abort() : (_results.data = _results.data[0], 
            userStep(_results, self))));
        }), this.parse = function(input, baseIndex, ignoreLastRow) {
            var quoteChar = _config.quoteChar || '"';
            _config.newline || (_config.newline = function(nAppearsFirst, re) {
                nAppearsFirst = nAppearsFirst.substring(0, 1048576);
                var re = new RegExp(escapeRegExp(re) + "([^]*?)" + escapeRegExp(re), "gm"), r = (nAppearsFirst = nAppearsFirst.replace(re, "")).split("\r"), nAppearsFirst = nAppearsFirst.split("\n"), nAppearsFirst = 1 < nAppearsFirst.length && nAppearsFirst[0].length < r[0].length;
                if (1 === r.length || nAppearsFirst) return "\n";
                for (var numWithN = 0, i = 0; i < r.length; i++) "\n" === r[i][0] && numWithN++;
                return numWithN >= r.length / 2 ? "\r\n" : "\r";
            }(input, quoteChar)), _delimiterError = !1, _config.delimiter ? isFunction(_config.delimiter) && (_config.delimiter = _config.delimiter(input), 
            _results.meta.delimiter = _config.delimiter) : ((parserConfig = function(input, newline, skipEmptyLines, comments, delimitersToGuess) {
                var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;
                delimitersToGuess = delimitersToGuess || [ ",", "\t", "|", ";", Papa.RECORD_SEP, Papa.UNIT_SEP ];
                for (var i = 0; i < delimitersToGuess.length; i++) {
                    var delim = delimitersToGuess[i], delta = 0, avgFieldCount = 0, emptyLinesCount = 0;
                    fieldCountPrevRow = void 0;
                    for (var fieldCount, preview = new Parser({
                        comments: comments,
                        delimiter: delim,
                        newline: newline,
                        preview: 10
                    }).parse(input), j = 0; j < preview.data.length; j++) skipEmptyLines && testEmptyLine(preview.data[j]) ? emptyLinesCount++ : (fieldCount = preview.data[j].length, 
                    avgFieldCount += fieldCount, void 0 !== fieldCountPrevRow ? 0 < fieldCount && (delta += Math.abs(fieldCount - fieldCountPrevRow), 
                    fieldCountPrevRow = fieldCount) : fieldCountPrevRow = fieldCount);
                    0 < preview.data.length && (avgFieldCount /= preview.data.length - emptyLinesCount), 
                    (void 0 === bestDelta || delta <= bestDelta) && (void 0 === maxFieldCount || maxFieldCount < avgFieldCount) && 1.99 < avgFieldCount && (bestDelta = delta, 
                    bestDelim = delim, maxFieldCount = avgFieldCount);
                }
                return {
                    successful: !!(_config.delimiter = bestDelim),
                    bestDelimiter: bestDelim
                };
            }(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess)).successful ? _config.delimiter = parserConfig.bestDelimiter : (_delimiterError = !0, 
            _config.delimiter = Papa.DefaultDelimiter), _results.meta.delimiter = _config.delimiter);
            var parserConfig = copy(_config);
            return _config.preview && _config.header && parserConfig.preview++, _input = input, 
            _parser = new Parser(parserConfig), _results = _parser.parse(_input, baseIndex, ignoreLastRow), 
            processResults(), _paused ? {
                meta: {
                    paused: !0
                }
            } : _results || {
                meta: {
                    paused: !1
                }
            };
        }, this.paused = function() {
            return _paused;
        }, this.pause = function() {
            _paused = !0, _parser.abort(), _input = isFunction(_config.chunk) ? "" : _input.substring(_parser.getCharIndex());
        }, this.resume = function() {
            self.streamer._halted ? (_paused = !1, self.streamer.parseChunk(_input, !0)) : setTimeout(self.resume, 3);
        }, this.aborted = function() {
            return _aborted;
        }, this.abort = function() {
            _aborted = !0, _parser.abort(), _results.meta.aborted = !0, isFunction(_config.complete) && _config.complete(_results), 
            _input = "";
        };
    }
    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Parser(config) {
        var delim = (config = config || {}).delimiter, newline = config.newline, comments = config.comments, step = config.step, preview = config.preview, fastMode = config.fastMode, quoteChar = void 0 === config.quoteChar ? '"' : config.quoteChar, escapeChar = quoteChar;
        if (void 0 !== config.escapeChar && (escapeChar = config.escapeChar), ("string" != typeof delim || -1 < Papa.BAD_DELIMITERS.indexOf(delim)) && (delim = ","), 
        comments === delim) throw new Error("Comment character same as delimiter");
        !0 === comments ? comments = "#" : ("string" != typeof comments || -1 < Papa.BAD_DELIMITERS.indexOf(comments)) && (comments = !1), 
        "\n" !== newline && "\r" !== newline && "\r\n" !== newline && (newline = "\n");
        var cursor = 0, aborted = !1;
        this.parse = function(input, baseIndex, ignoreLastRow) {
            if ("string" != typeof input) throw new Error("Input must be a string");
            var inputLen = input.length, delimLen = delim.length, newlineLen = newline.length, commentsLen = comments.length, stepIsFunction = isFunction(step), data = [], errors = [], row = [], lastCursor = cursor = 0;
            if (!input) return returnable();
            if (fastMode || !1 !== fastMode && -1 === input.indexOf(quoteChar)) {
                for (var rows = input.split(newline), i = 0; i < rows.length; i++) {
                    if (row = rows[i], cursor += row.length, i !== rows.length - 1) cursor += newline.length; else if (ignoreLastRow) return returnable();
                    if (!comments || row.substring(0, commentsLen) !== comments) {
                        if (stepIsFunction) {
                            if (data = [], pushRow(row.split(delim)), doStep(), aborted) return returnable();
                        } else pushRow(row.split(delim));
                        if (preview && preview <= i) return data = data.slice(0, preview), returnable(!0);
                    }
                }
                return returnable();
            }
            for (var nextDelim = input.indexOf(delim, cursor), nextNewline = input.indexOf(newline, cursor), quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), "g"), quoteSearch = input.indexOf(quoteChar, cursor); ;) if (input[cursor] !== quoteChar) if (comments && 0 === row.length && input.substring(cursor, cursor + commentsLen) === comments) {
                if (-1 === nextNewline) return returnable();
                cursor = nextNewline + newlineLen, nextNewline = input.indexOf(newline, cursor), 
                nextDelim = input.indexOf(delim, cursor);
            } else {
                if (-1 !== nextDelim && (nextDelim < nextNewline || -1 === nextNewline)) {
                    if (!(nextDelim < quoteSearch)) {
                        row.push(input.substring(cursor, nextDelim)), cursor = nextDelim + delimLen, nextDelim = input.indexOf(delim, cursor);
                        continue;
                    }
                    var nextDelimObj = function getNextUnquotedDelimiter(nextDelim, quoteSearch, newLine) {
                        var result = {
                            nextDelim: void 0,
                            quoteSearch: void 0
                        };
                        var nextQuoteSearch = input.indexOf(quoteChar, quoteSearch + 1);
                        if (quoteSearch < nextDelim && nextDelim < nextQuoteSearch && (nextQuoteSearch < newLine || -1 === newLine)) {
                            var nextNextDelim = input.indexOf(delim, nextQuoteSearch);
                            if (-1 === nextNextDelim) return result;
                            nextQuoteSearch < nextNextDelim && (nextQuoteSearch = input.indexOf(quoteChar, nextQuoteSearch + 1)), 
                            result = getNextUnquotedDelimiter(nextNextDelim, nextQuoteSearch, newLine);
                        } else result = {
                            nextDelim: nextDelim,
                            quoteSearch: quoteSearch
                        };
                        return result;
                    }(nextDelim, quoteSearch, nextNewline);
                    if (nextDelimObj && void 0 !== nextDelimObj.nextDelim) {
                        nextDelim = nextDelimObj.nextDelim, quoteSearch = nextDelimObj.quoteSearch, row.push(input.substring(cursor, nextDelim)), 
                        cursor = nextDelim + delimLen, nextDelim = input.indexOf(delim, cursor);
                        continue;
                    }
                }
                if (-1 === nextNewline) break;
                if (row.push(input.substring(cursor, nextNewline)), saveRow(nextNewline + newlineLen), 
                stepIsFunction && (doStep(), aborted)) return returnable();
                if (preview && data.length >= preview) return returnable(!0);
            } else for (quoteSearch = cursor, cursor++; ;) {
                if (-1 === (quoteSearch = input.indexOf(quoteChar, quoteSearch + 1))) return ignoreLastRow || errors.push({
                    type: "Quotes",
                    code: "MissingQuotes",
                    message: "Quoted field unterminated",
                    row: data.length,
                    index: cursor
                }), finish();
                if (quoteSearch === inputLen - 1) return finish(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
                if (quoteChar !== escapeChar || input[quoteSearch + 1] !== escapeChar) {
                    if (quoteChar === escapeChar || 0 === quoteSearch || input[quoteSearch - 1] !== escapeChar) {
                        -1 !== nextDelim && nextDelim < quoteSearch + 1 && (nextDelim = input.indexOf(delim, quoteSearch + 1));
                        var spacesBetweenQuoteAndNewLine = extraSpaces(-1 === (nextNewline = -1 !== nextNewline && nextNewline < quoteSearch + 1 ? input.indexOf(newline, quoteSearch + 1) : nextNewline) ? nextDelim : Math.min(nextDelim, nextNewline));
                        if (input[quoteSearch + 1 + spacesBetweenQuoteAndNewLine] === delim) {
                            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar)), 
                            input[cursor = quoteSearch + 1 + spacesBetweenQuoteAndNewLine + delimLen] !== quoteChar && (quoteSearch = input.indexOf(quoteChar, cursor)), 
                            nextDelim = input.indexOf(delim, cursor), nextNewline = input.indexOf(newline, cursor);
                            break;
                        }
                        spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);
                        if (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline) {
                            if (row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar)), 
                            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen), nextDelim = input.indexOf(delim, cursor), 
                            quoteSearch = input.indexOf(quoteChar, cursor), stepIsFunction && (doStep(), aborted)) return returnable();
                            if (preview && data.length >= preview) return returnable(!0);
                            break;
                        }
                        errors.push({
                            type: "Quotes",
                            code: "InvalidQuotes",
                            message: "Trailing quote on quoted field is malformed",
                            row: data.length,
                            index: cursor
                        }), quoteSearch++;
                    }
                } else quoteSearch++;
            }
            return finish();
            function pushRow(row) {
                data.push(row), lastCursor = cursor;
            }
            function extraSpaces(textBetweenClosingQuoteAndIndex) {
                var spaceLength = 0;
                return -1 === textBetweenClosingQuoteAndIndex || (textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, textBetweenClosingQuoteAndIndex)) && "" === textBetweenClosingQuoteAndIndex.trim() && (spaceLength = textBetweenClosingQuoteAndIndex.length), 
                spaceLength;
            }
            function finish(value) {
                return ignoreLastRow || (void 0 === value && (value = input.substring(cursor)), 
                row.push(value), cursor = inputLen, pushRow(row), stepIsFunction && doStep()), returnable();
            }
            function saveRow(newCursor) {
                cursor = newCursor, pushRow(row), row = [], nextNewline = input.indexOf(newline, cursor);
            }
            function returnable(stopped) {
                return {
                    data: data,
                    errors: errors,
                    meta: {
                        delimiter: delim,
                        linebreak: newline,
                        aborted: aborted,
                        truncated: !!stopped,
                        cursor: lastCursor + (baseIndex || 0)
                    }
                };
            }
            function doStep() {
                step(returnable()), data = [], errors = [];
            }
        }, this.abort = function() {
            aborted = !0;
        }, this.getCharIndex = function() {
            return cursor;
        };
    }
    function mainThreadReceivedMessage(e) {
        var msg = e.data, worker = workers[msg.workerId], aborted = !1;
        if (msg.error) worker.userError(msg.error, msg.file); else if (msg.results && msg.results.data) {
            var handle = {
                abort: function() {
                    aborted = !0, completeWorker(msg.workerId, {
                        data: [],
                        errors: [],
                        meta: {
                            aborted: !0
                        }
                    });
                },
                pause: notImplemented,
                resume: notImplemented
            };
            if (isFunction(worker.userStep)) {
                for (var i = 0; i < msg.results.data.length && (worker.userStep({
                    data: msg.results.data[i],
                    errors: msg.results.errors,
                    meta: msg.results.meta
                }, handle), !aborted); i++) ;
                delete msg.results;
            } else isFunction(worker.userChunk) && (worker.userChunk(msg.results, handle, msg.file), 
            delete msg.results);
        }
        msg.finished && !aborted && completeWorker(msg.workerId, msg.results);
    }
    function completeWorker(workerId, results) {
        var worker = workers[workerId];
        isFunction(worker.userComplete) && worker.userComplete(results), worker.terminate(), 
        delete workers[workerId];
    }
    function notImplemented() {
        throw new Error("Not implemented.");
    }
    function copy(obj) {
        if ("object" != typeof obj || null === obj) return obj;
        var key, cpy = Array.isArray(obj) ? [] : {};
        for (key in obj) cpy[key] = copy(obj[key]);
        return cpy;
    }
    function bindFunction(f, self) {
        return function() {
            f.apply(self, arguments);
        };
    }
    function isFunction(func) {
        return "function" == typeof func;
    }
    return Papa.parse = function(_input, _config) {
        var dynamicTyping = (_config = _config || {}).dynamicTyping || !1;
        isFunction(dynamicTyping) && (_config.dynamicTypingFunction = dynamicTyping, dynamicTyping = {});
        if (_config.dynamicTyping = dynamicTyping, _config.transform = !!isFunction(_config.transform) && _config.transform, 
        _config.worker && Papa.WORKERS_SUPPORTED) {
            var streamer = function() {
                if (!Papa.WORKERS_SUPPORTED) return !1;
                var w = function() {
                    var URL = global.URL || global.webkitURL || null, code = moduleFactory.toString();
                    return Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob([ "(", code, ")();" ], {
                        type: "text/javascript"
                    })));
                }(), w = new global.Worker(w);
                return w.onmessage = mainThreadReceivedMessage, w.id = workerIdCounter++, workers[w.id] = w;
            }();
            return streamer.userStep = _config.step, streamer.userChunk = _config.chunk, streamer.userComplete = _config.complete, 
            streamer.userError = _config.error, _config.step = isFunction(_config.step), _config.chunk = isFunction(_config.chunk), 
            _config.complete = isFunction(_config.complete), _config.error = isFunction(_config.error), 
            delete _config.worker, void streamer.postMessage({
                input: _input,
                config: _config,
                workerId: streamer.id
            });
        }
        streamer = null;
        {
            if (_input === Papa.NODE_STREAM_INPUT && "undefined" == typeof PAPA_BROWSER_CONTEXT) return (streamer = new DuplexStreamStreamer(_config)).getStream();
            "string" == typeof _input ? streamer = new (_config.download ? NetworkStreamer : StringStreamer)(_config) : !0 === _input.readable && isFunction(_input.read) && isFunction(_input.on) ? streamer = new ReadableStreamStreamer(_config) : (global.File && _input instanceof File || _input instanceof Object) && (streamer = new FileStreamer(_config));
        }
        return streamer.stream(_input);
    }, Papa.unparse = function(_input, _config) {
        var _quotes = !1, _writeHeader = !0, _delimiter = ",", _newline = "\r\n", _quoteChar = '"', _escapedQuote = _quoteChar + _quoteChar, _skipEmptyLines = !1, _columns = null;
        !function() {
            if ("object" == typeof _config) {
                if ("string" != typeof _config.delimiter || Papa.BAD_DELIMITERS.filter(function(value) {
                    return -1 !== _config.delimiter.indexOf(value);
                }).length || (_delimiter = _config.delimiter), "boolean" != typeof _config.quotes && "function" != typeof _config.quotes && !Array.isArray(_config.quotes) || (_quotes = _config.quotes), 
                "boolean" != typeof _config.skipEmptyLines && "string" != typeof _config.skipEmptyLines || (_skipEmptyLines = _config.skipEmptyLines), 
                "string" == typeof _config.newline && (_newline = _config.newline), "string" == typeof _config.quoteChar && (_quoteChar = _config.quoteChar), 
                "boolean" == typeof _config.header && (_writeHeader = _config.header), Array.isArray(_config.columns)) {
                    if (0 === _config.columns.length) throw new Error("Option columns is empty");
                    _columns = _config.columns;
                }
                void 0 !== _config.escapeChar && (_escapedQuote = _config.escapeChar + _quoteChar);
            }
        }();
        var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), "g");
        "string" == typeof _input && (_input = JSON.parse(_input));
        if (Array.isArray(_input)) {
            if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);
            if ("object" == typeof _input[0]) return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);
        } else if ("object" == typeof _input) return "string" == typeof _input.data && (_input.data = JSON.parse(_input.data)), 
        Array.isArray(_input.data) && (_input.fields || (_input.fields = _input.meta && _input.meta.fields), 
        _input.fields || (_input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0])), 
        Array.isArray(_input.data[0]) || "object" == typeof _input.data[0] || (_input.data = [ _input.data ])), 
        serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
        throw new Error("Unable to serialize unrecognized input");
        function objectKeys(obj) {
            if ("object" != typeof obj) return [];
            var key, keys = [];
            for (key in obj) keys.push(key);
            return keys;
        }
        function serialize(fields, data, skipEmptyLines) {
            var csv = "";
            "string" == typeof fields && (fields = JSON.parse(fields)), "string" == typeof data && (data = JSON.parse(data));
            var hasHeader = Array.isArray(fields) && 0 < fields.length, dataKeyedByField = !Array.isArray(data[0]);
            if (hasHeader && _writeHeader) {
                for (var i = 0; i < fields.length; i++) 0 < i && (csv += _delimiter), csv += safe(fields[i], i);
                0 < data.length && (csv += _newline);
            }
            for (var row = 0; row < data.length; row++) {
                var maxCol = (hasHeader ? fields : data[row]).length, emptyLine = !1, nullLine = hasHeader ? 0 === Object.keys(data[row]).length : 0 === data[row].length;
                if (skipEmptyLines && !hasHeader && (emptyLine = "greedy" === skipEmptyLines ? "" === data[row].join("").trim() : 1 === data[row].length && 0 === data[row][0].length), 
                "greedy" === skipEmptyLines && hasHeader) {
                    for (var line = [], c = 0; c < maxCol; c++) {
                        var cx = dataKeyedByField ? fields[c] : c;
                        line.push(data[row][cx]);
                    }
                    emptyLine = "" === line.join("").trim();
                }
                if (!emptyLine) {
                    for (var col = 0; col < maxCol; col++) {
                        0 < col && !nullLine && (csv += _delimiter);
                        var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
                        csv += safe(data[row][colIdx], col);
                    }
                    row < data.length - 1 && (!skipEmptyLines || 0 < maxCol && !nullLine) && (csv += _newline);
                }
            }
            return csv;
        }
        function safe(str, col) {
            if (null == str) return "";
            if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);
            var escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);
            return "boolean" == typeof _quotes && _quotes || "function" == typeof _quotes && _quotes(str, col) || Array.isArray(_quotes) && _quotes[col] || function(str, substrings) {
                for (var i = 0; i < substrings.length; i++) if (-1 < str.indexOf(substrings[i])) return !0;
                return !1;
            }(escapedQuoteStr, Papa.BAD_DELIMITERS) || -1 < escapedQuoteStr.indexOf(_delimiter) || " " === escapedQuoteStr.charAt(0) || " " === escapedQuoteStr.charAt(escapedQuoteStr.length - 1) ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;
        }
    }, Papa.RECORD_SEP = String.fromCharCode(30), Papa.UNIT_SEP = String.fromCharCode(31), 
    Papa.BYTE_ORDER_MARK = "\ufeff", Papa.BAD_DELIMITERS = [ "\r", "\n", '"', Papa.BYTE_ORDER_MARK ], 
    Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker, Papa.NODE_STREAM_INPUT = 1, 
    Papa.LocalChunkSize = 10485760, Papa.RemoteChunkSize = 5242880, Papa.DefaultDelimiter = ",", 
    Papa.Parser = Parser, Papa.ParserHandle = ParserHandle, Papa.NetworkStreamer = NetworkStreamer, 
    Papa.FileStreamer = FileStreamer, Papa.StringStreamer = StringStreamer, Papa.ReadableStreamStreamer = ReadableStreamStreamer, 
    "undefined" == typeof PAPA_BROWSER_CONTEXT && (Papa.DuplexStreamStreamer = DuplexStreamStreamer), 
    global.jQuery && (($ = global.jQuery).fn.parse = function(options) {
        var config = options.config || {}, queue = [];
        return this.each(function(idx) {
            if (!("INPUT" === $(this).prop("tagName").toUpperCase() && "file" === $(this).attr("type").toLowerCase() && global.FileReader) || !this.files || 0 === this.files.length) return !0;
            for (var i = 0; i < this.files.length; i++) queue.push({
                file: this.files[i],
                inputElem: this,
                instanceConfig: $.extend({}, config)
            });
        }), parseNextFile(), this;
        function parseNextFile() {
            if (0 !== queue.length) {
                var name, file, elem, reason, f = queue[0];
                if (isFunction(options.before)) {
                    var returned = options.before(f.file, f.inputElem);
                    if ("object" == typeof returned) {
                        if ("abort" === returned.action) return name = "AbortError", file = f.file, elem = f.inputElem, 
                        reason = returned.reason, void (isFunction(options.error) && options.error({
                            name: name
                        }, file, elem, reason));
                        if ("skip" === returned.action) return void fileComplete();
                        "object" == typeof returned.config && (f.instanceConfig = $.extend(f.instanceConfig, returned.config));
                    } else if ("skip" === returned) return void fileComplete();
                }
                var userCompleteFunc = f.instanceConfig.complete;
                f.instanceConfig.complete = function(results) {
                    isFunction(userCompleteFunc) && userCompleteFunc(results, f.file, f.inputElem), 
                    fileComplete();
                }, Papa.parse(f.file, f.instanceConfig);
            } else isFunction(options.complete) && options.complete();
        }
        function fileComplete() {
            queue.splice(0, 1), parseNextFile();
        }
    }), IS_PAPA_WORKER && (global.onmessage = function(results) {
        results = results.data;
        void 0 === Papa.WORKER_ID && results && (Papa.WORKER_ID = results.workerId);
        "string" == typeof results.input ? global.postMessage({
            workerId: Papa.WORKER_ID,
            results: Papa.parse(results.input, results.config),
            finished: !0
        }) : !(global.File && results.input instanceof File || results.input instanceof Object) || (results = Papa.parse(results.input, results.config)) && global.postMessage({
            workerId: Papa.WORKER_ID,
            results: results,
            finished: !0
        });
    }), (NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype)).constructor = NetworkStreamer, 
    (FileStreamer.prototype = Object.create(ChunkStreamer.prototype)).constructor = FileStreamer, 
    (StringStreamer.prototype = Object.create(StringStreamer.prototype)).constructor = StringStreamer, 
    (ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype)).constructor = ReadableStreamStreamer, 
    "undefined" == typeof PAPA_BROWSER_CONTEXT && ((DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype)).constructor = DuplexStreamStreamer), 
    Papa;
}), function(global, factory) {
    "function" == typeof define && define.amd ? define([], factory) : "undefined" != typeof exports ? factory() : (factory(), 
    global.FileSaver = {});
}(this, function() {
    "use strict";
    var _global = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0;
    function download(url, name, opts) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url), xhr.responseType = "blob", xhr.onload = function() {
            saveAs(xhr.response, name, opts);
        }, xhr.onerror = function() {
            console.error("could not download file");
        }, xhr.send();
    }
    function corsEnabled(url) {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, !1);
        try {
            xhr.send();
        } catch (e) {}
        return 200 <= xhr.status && xhr.status <= 299;
    }
    function click(node) {
        try {
            node.dispatchEvent(new MouseEvent("click"));
        } catch (e) {
            var evt = document.createEvent("MouseEvents");
            evt.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), 
            node.dispatchEvent(evt);
        }
    }
    var isMacOSWebView = _global.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), saveAs = _global.saveAs || ("object" != typeof window || window !== _global ? function() {} : "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? function(blob, name, opts) {
        var URL = _global.URL || _global.webkitURL, a = document.createElement("a");
        name = name || blob.name || "download", a.download = name, a.rel = "noopener", "string" == typeof blob ? (a.href = blob, 
        a.origin !== location.origin ? corsEnabled(a.href) ? download(blob, name, opts) : click(a, a.target = "_blank") : click(a)) : (a.href = URL.createObjectURL(blob), 
        setTimeout(function() {
            URL.revokeObjectURL(a.href);
        }, 4e4), setTimeout(function() {
            click(a);
        }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(blob, name, opts) {
        var a;
        name = name || blob.name || "download", "string" == typeof blob ? corsEnabled(blob) ? download(blob, name, opts) : ((a = document.createElement("a")).href = blob, 
        a.target = "_blank", setTimeout(function() {
            click(a);
        })) : navigator.msSaveOrOpenBlob(function(blob, opts) {
            return void 0 === opts ? opts = {
                autoBom: !1
            } : "object" != typeof opts && (console.warn("Deprecated: Expected third argument to be a object"), 
            opts = {
                autoBom: !opts
            }), opts.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type) ? new Blob([ String.fromCharCode(65279), blob ], {
                type: blob.type
            }) : blob;
        }(blob, opts), name);
    } : function(blob, force, isSafari, popup) {
        if ((popup = popup || open("", "_blank")) && (popup.document.title = popup.document.body.innerText = "downloading..."), 
        "string" == typeof blob) return download(blob, force, isSafari);
        var reader, URL, url, force = "application/octet-stream" === blob.type, isSafari = /constructor/i.test(_global.HTMLElement) || _global.safari, isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
        (isChromeIOS || force && isSafari || isMacOSWebView) && "undefined" != typeof FileReader ? ((reader = new FileReader()).onloadend = function() {
            var url = reader.result, url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
            popup ? popup.location.href = url : location = url, popup = null;
        }, reader.readAsDataURL(blob)) : (URL = _global.URL || _global.webkitURL, url = URL.createObjectURL(blob), 
        popup ? popup.location = url : location.href = url, popup = null, setTimeout(function() {
            URL.revokeObjectURL(url);
        }, 4e4));
    });
    _global.saveAs = saveAs.saveAs = saveAs, "undefined" != typeof module && (module.exports = saveAs);
}), function() {
    var fnName, newFn;
    window.XMLHttpRequest && !window.XMLHttpRequest.__isFileAPIShim && (fnName = "setRequestHeader", 
    newFn = function(orig) {
        return function(header, value) {
            var val;
            "__setXHR_" === header ? (val = value(this)) instanceof Function && val(this) : orig.apply(this, arguments);
        };
    }, window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]));
    var angularFileUpload = angular.module("angularFileUpload", []);
    function dropAvailable() {
        var div = document.createElement("div");
        return "draggable" in div && "ondrop" in div;
    }
    function globStringToRegex(str) {
        if (2 < str.length && "/" === str[0] && "/" === str[str.length - 1]) return str.substring(1, str.length - 1);
        var split = str.split(","), result = "";
        if (1 < split.length) for (var i = 0; i < split.length; i++) result += "(" + globStringToRegex(split[i]) + ")", 
        i < split.length - 1 && (result += "|"); else result = (result = "^" + (str = 0 == str.indexOf(".") ? "*" + str : str).replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]", "g"), "\\$&") + "$").replace(/\\\*/g, ".*").replace(/\\\?/g, ".");
        return result;
    }
    angularFileUpload.version = "3.0.7", angularFileUpload.service("$upload", [ "$http", "$q", "$timeout", function($http, $q, $timeout) {
        function sendHttp(config) {
            config.method = config.method || "POST", config.headers = config.headers || {}, 
            config.transformRequest = config.transformRequest || function(data, headersGetter) {
                return window.ArrayBuffer && data instanceof window.ArrayBuffer ? data : $http.defaults.transformRequest[0](data, headersGetter);
            };
            var deferred = $q.defer(), promise = deferred.promise;
            return config.headers.__setXHR_ = function() {
                return function(xhr) {
                    xhr && (config.__XHR = xhr, config.xhrFn && config.xhrFn(xhr), xhr.upload.addEventListener("progress", function(e) {
                        e.config = config, deferred.notify ? deferred.notify(e) : promise.progress_fn && $timeout(function() {
                            promise.progress_fn(e);
                        });
                    }, !1), xhr.upload.addEventListener("load", function(e) {
                        e.lengthComputable && (e.config = config, deferred.notify ? deferred.notify(e) : promise.progress_fn && $timeout(function() {
                            promise.progress_fn(e);
                        }));
                    }, !1));
                };
            }, $http(config).then(function(r) {
                deferred.resolve(r);
            }, function(e) {
                deferred.reject(e);
            }, function(n) {
                deferred.notify(n);
            }), promise.success = function(fn) {
                return promise.then(function(response) {
                    fn(response.data, response.status, response.headers, config);
                }), promise;
            }, promise.error = function(fn) {
                return promise.then(null, function(response) {
                    fn(response.data, response.status, response.headers, config);
                }), promise;
            }, promise.progress = function(fn) {
                return promise.progress_fn = fn, promise.then(null, null, function(update) {
                    fn(update);
                }), promise;
            }, promise.abort = function() {
                return config.__XHR && $timeout(function() {
                    config.__XHR.abort();
                }), promise;
            }, promise.xhr = function(fn) {
                var origXhrFn;
                return config.xhrFn = (origXhrFn = config.xhrFn, function() {
                    origXhrFn && origXhrFn.apply(promise, arguments), fn.apply(promise, arguments);
                }), promise;
            }, promise;
        }
        this.upload = function(config) {
            config.headers = config.headers || {}, config.headers["Content-Type"] = void 0;
            config.transformRequest;
            return config.transformRequest = config.transformRequest ? "[object Array]" === Object.prototype.toString.call(config.transformRequest) ? config.transformRequest : [ config.transformRequest ] : [], 
            config.transformRequest.push(function(data, headerGetter) {
                var formData = new FormData(), allFields = {};
                for (key in config.fields) allFields[key] = config.fields[key];
                if (data && (allFields.data = data), config.formDataAppender) for (var key in allFields) config.formDataAppender(formData, key, allFields[key]); else for (var key in allFields) {
                    var val = allFields[key];
                    void 0 !== val && ("[object String]" === Object.prototype.toString.call(val) ? formData.append(key, val) : config.sendObjectsAsJsonBlob && "object" == typeof val ? formData.append(key, new Blob([ val ], {
                        type: "application/json"
                    })) : formData.append(key, JSON.stringify(val)));
                }
                if (null != config.file) {
                    var fileFormName = config.fileFormDataName || "file";
                    if ("[object Array]" === Object.prototype.toString.call(config.file)) for (var isFileFormNameString = "[object String]" === Object.prototype.toString.call(fileFormName), i = 0; i < config.file.length; i++) formData.append(isFileFormNameString ? fileFormName : fileFormName[i], config.file[i], config.fileName && config.fileName[i] || config.file[i].name); else formData.append(fileFormName, config.file, config.fileName || config.file.name);
                }
                return formData;
            }), sendHttp(config);
        }, this.http = sendHttp;
    } ]), angularFileUpload.directive("ngFileSelect", [ "$parse", "$timeout", "$compile", function($parse, $timeout, $compile) {
        return {
            restrict: "AEC",
            require: "?ngModel",
            link: function(scope, elem, attr, ngModel) {
                !function(scope, elem, attr, ngModel, $parse, $timeout, $compile) {
                    var watchers = [];
                    function recompileElem() {
                        var clone = elem.clone();
                        if (elem.attr("__afu_gen__") && angular.element(document.getElementById(elem.attr("id").substring(1))).remove(), 
                        elem.parent().length) {
                            for (var i = 0; i < watchers.length; i++) watchers[i]();
                            elem.replaceWith(clone), $compile(clone)(scope);
                        }
                        return clone;
                    }
                    function bindAttr(val, attrName) {
                        var attrVal;
                        val && (attrVal = val, $timeout(function() {
                            elem.parent().length && watchers.push(scope.$watch(attrVal, function(val, oldVal) {
                                val != oldVal && recompileElem();
                            }));
                        }), (val = $parse(val)(scope)) ? (elem.attr(attrName, val), attr[attrName] = val) : (elem.attr(attrName, null), 
                        delete attr[attrName]));
                    }
                    function onChangeFn(evt) {
                        !function(fileList, attr, ngModel, scope, evt) {
                            for (var files = [], rejFiles = [], regexp = attr.accept ? new RegExp(globStringToRegex(attr.accept), "gi") : null, i = 0; i < fileList.length; i++) {
                                var file = fileList.item(i);
                                (!regexp || file.type.match(regexp) || null != file.name && file.name.match(regexp) ? files : rejFiles).push(file);
                            }
                            $timeout(function() {
                                ngModel && ($parse(attr.ngModel).assign(scope, files), ngModel && ngModel.$setViewValue(null != files && 0 == files.length ? "" : files), 
                                attr.ngModelRejected && $parse(attr.ngModelRejected).assign(scope, rejFiles)), attr.ngFileChange && "" != attr.ngFileChange && $parse(attr.ngFileChange)(scope, {
                                    $files: files,
                                    $rejectedFiles: rejFiles,
                                    $event: evt
                                });
                            });
                        }(evt.__files_ || evt.target && evt.target.files, attr, ngModel, scope, evt);
                    }
                    bindAttr(attr.ngMultiple, "multiple"), bindAttr(attr.ngAccept, "accept"), bindAttr(attr.ngCapture, "capture"), 
                    "" != attr.ngFileSelect && (attr.ngFileChange = attr.ngFileSelect);
                    var name, fileElem = elem;
                    if ("input" === elem[0].tagName.toLowerCase() && elem.attr("type") && "file" === elem.attr("type").toLowerCase()) elem.bind("click", resetAndClick); else {
                        for (var key in fileElem = angular.element('<input type="file">'), attr.multiple && fileElem.attr("multiple", attr.multiple), 
                        attr.accept && fileElem.attr("accept", attr.accept), attr.capture && fileElem.attr("capture", attr.capture), 
                        attr) 0 == key.indexOf("inputFile") && (name = (name = key.substring("inputFile".length))[0].toLowerCase() + name.substring(1), 
                        fileElem.attr(name, attr[key]));
                        fileElem.css("width", "0px").css("height", "0px").css("position", "absolute").css("padding", 0).css("margin", 0).css("overflow", "hidden").attr("tabindex", "-1").css("opacity", 0).attr("__afu_gen__", !0), 
                        elem.attr("__refElem__", !0), fileElem[0].__refElem__ = elem[0], elem.parent()[0].insertBefore(fileElem[0], elem[0]), 
                        elem.css("overflow", "hidden"), elem.bind("click", function(e) {
                            resetAndClick(e) || fileElem[0].click();
                        });
                    }
                    function resetAndClick(evt) {
                        if (null != fileElem[0].value && "" != fileElem[0].value && (fileElem[0].value = null, 
                        -1 === navigator.userAgent.indexOf("Trident/7") && onChangeFn({
                            target: {
                                files: []
                            }
                        })), elem.attr("__afu_clone__")) elem.attr("__afu_clone__", null); else if (-1 !== navigator.appVersion.indexOf("MSIE 10") || -1 !== navigator.userAgent.indexOf("Trident/7")) {
                            var clone = recompileElem();
                            return clone.attr("__afu_clone__", !0), clone[0].click(), evt.preventDefault(), 
                            evt.stopPropagation(), !0;
                        }
                    }
                    fileElem.bind("change", onChangeFn), elem.on("$destroy", function() {
                        for (var i = 0; i < watchers.length; i++) watchers[i]();
                        elem[0] != fileElem[0] && fileElem.remove();
                    }), watchers.push(scope.$watch(attr.ngModel, function(val, oldVal) {
                        val == oldVal || null != val && val.length || (-1 !== navigator.appVersion.indexOf("MSIE 10") ? recompileElem() : fileElem[0].value = null);
                    }));
                }(scope, elem, attr, ngModel, $parse, $timeout, $compile);
            }
        };
    } ]), angularFileUpload.directive("ngFileDrop", [ "$parse", "$timeout", "$location", function($parse, $timeout, $location) {
        return {
            restrict: "AEC",
            require: "?ngModel",
            link: function(scope, elem, attr, ngModel) {
                !function(scope, elem, attr, ngModel, $parse, $timeout, $location) {
                    var available = dropAvailable();
                    if (attr.dropAvailable && $timeout(function() {
                        scope.dropAvailable ? scope.dropAvailable.value = available : scope.dropAvailable = available;
                    }), !available) return 0 != $parse(attr.hideOnDropNotAvailable)(scope) && elem.css("display", "none");
                    var actualDragOverClass, leaveTimeout = null, stopPropagation = $parse(attr.stopPropagation)(scope), dragOverDelay = 1, accept = $parse(attr.ngAccept)(scope) || attr.accept, regexp = accept ? new RegExp(globStringToRegex(accept), "gi") : null;
                    function extractFiles(evt, callback, allowDir, multiple) {
                        var files = [], rejFiles = [], items = evt.dataTransfer.items, processing = 0;
                        function addFile(file) {
                            (!regexp || file.type.match(regexp) || null != file.name && file.name.match(regexp) ? files : rejFiles).push(file);
                        }
                        if (items && 0 < items.length && "file" != $location.protocol()) for (var i = 0; i < items.length; i++) {
                            if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
                                var f = items[i].webkitGetAsEntry();
                                if (f.isDirectory && !allowDir) continue;
                                null != f && !function traverseFileTree(files, entry, path) {
                                    {
                                        var filePath, dirReader, entries, readEntries;
                                        null != entry && (entry.isDirectory ? (filePath = (path || "") + entry.name, addFile({
                                            name: entry.name,
                                            type: "directory",
                                            path: filePath
                                        }), dirReader = entry.createReader(), entries = [], processing++, (readEntries = function() {
                                            dirReader.readEntries(function(results) {
                                                try {
                                                    if (results.length) entries = entries.concat(Array.prototype.slice.call(results || [], 0)), 
                                                    readEntries(); else {
                                                        for (var i = 0; i < entries.length; i++) traverseFileTree(files, entries[i], (path || "") + entry.name + "/");
                                                        processing--;
                                                    }
                                                } catch (e) {
                                                    processing--, console.error(e);
                                                }
                                            }, function() {
                                                processing--;
                                            });
                                        })()) : (processing++, entry.file(function(file) {
                                            try {
                                                processing--, file.path = (path || "") + file.name, addFile(file);
                                            } catch (e) {
                                                processing--, console.error(e);
                                            }
                                        }, function(e) {
                                            processing--;
                                        })));
                                    }
                                }(files, f);
                            } else {
                                f = items[i].getAsFile();
                                null != f && addFile(f);
                            }
                            if (!multiple && 0 < files.length) break;
                        } else {
                            var fileList = evt.dataTransfer.files;
                            if (null != fileList) for (i = 0; i < fileList.length && (addFile(fileList.item(i)), 
                            multiple || !(0 < files.length)); i++) ;
                        }
                        var delays = 0;
                        !function waitForProcess(delay) {
                            $timeout(function() {
                                if (processing) 10 * delays++ < 2e4 && waitForProcess(10); else {
                                    if (!multiple && 1 < files.length) {
                                        for (var i = 0; "directory" == files[i].type; ) i++;
                                        files = [ files[i] ];
                                    }
                                    callback(files, rejFiles);
                                }
                            }, delay || 0);
                        }();
                    }
                    elem[0].addEventListener("dragover", function(evt) {
                        var b;
                        evt.preventDefault(), stopPropagation && evt.stopPropagation(), -1 < navigator.userAgent.indexOf("Chrome") && (b = evt.dataTransfer.effectAllowed, 
                        evt.dataTransfer.dropEffect = "move" === b || "linkMove" === b ? "move" : "copy"), 
                        $timeout.cancel(leaveTimeout), scope.actualDragOverClass || (actualDragOverClass = function(scope, attr, clazz) {
                            var valid = !0;
                            if (regexp) {
                                var items = clazz.dataTransfer.items;
                                if (null != items) for (var i = 0; i < items.length && valid; i++) valid = valid && ("file" == items[i].kind || "" == items[i].kind) && (null != items[i].type.match(regexp) || null != items[i].name && null != items[i].name.match(regexp));
                            }
                            clazz = $parse(attr.dragOverClass)(scope, {
                                $event: clazz
                            });
                            clazz && (clazz.delay && (dragOverDelay = clazz.delay), clazz.accept && (clazz = valid ? clazz.accept : clazz.reject));
                            return clazz || attr.dragOverClass || "dragover";
                        }(scope, attr, evt)), elem.addClass(actualDragOverClass);
                    }, !1), elem[0].addEventListener("dragenter", function(evt) {
                        evt.preventDefault(), stopPropagation && evt.stopPropagation();
                    }, !1), elem[0].addEventListener("dragleave", function(evt) {
                        leaveTimeout = $timeout(function() {
                            elem.removeClass(actualDragOverClass), actualDragOverClass = null;
                        }, dragOverDelay || 1);
                    }, !1), "" != attr.ngFileDrop && (attr.ngFileChange = scope.ngFileDrop), elem[0].addEventListener("drop", function(evt) {
                        evt.preventDefault(), stopPropagation && evt.stopPropagation(), elem.removeClass(actualDragOverClass), 
                        actualDragOverClass = null, extractFiles(evt, function(files, rejFiles) {
                            $timeout(function() {
                                ngModel && ($parse(attr.ngModel).assign(scope, files), ngModel && ngModel.$setViewValue(null != files && 0 == files.length ? "" : files)), 
                                attr.ngModelRejected && scope[attr.ngModelRejected] && $parse(attr.ngModelRejected).assign(scope, rejFiles);
                            }), $timeout(function() {
                                $parse(attr.ngFileChange)(scope, {
                                    $files: files,
                                    $rejectedFiles: rejFiles,
                                    $event: evt
                                });
                            });
                        }, 0 != $parse(attr.allowDir)(scope), attr.multiple || $parse(attr.ngMultiple)(scope));
                    }, !1);
                }(scope, elem, attr, ngModel, $parse, $timeout, $location);
            }
        };
    } ]), angularFileUpload.directive("ngNoFileDrop", function() {
        return function(scope, elem, attr) {
            dropAvailable() && elem.css("display", "none");
        };
    }), angularFileUpload.directive("ngFileDropAvailable", [ "$parse", "$timeout", function($parse, $timeout) {
        return function(scope, elem, attr) {
            var fn;
            dropAvailable() && (fn = $parse(attr.ngFileDropAvailable), $timeout(function() {
                fn(scope);
            }));
        };
    } ]);
    var key, ngFileUpload = angular.module("ngFileUpload", []);
    for (key in angularFileUpload) ngFileUpload[key] = angularFileUpload[key];
}(), function() {
    this.ResizeSensor = function(element, callback) {
        function EventQueue() {
            var i, j;
            this.q = [], this.add = function(ev) {
                this.q.push(ev);
            }, this.call = function() {
                for (i = 0, j = this.q.length; i < j; i++) this.q[i].call();
            };
        }
        function attachResizeEvent(element, addEvent) {
            if (element.resizedAttached) {
                if (element.resizedAttached) return void element.resizedAttached.add(addEvent);
            } else element.resizedAttached = new EventQueue(), element.resizedAttached.add(addEvent);
            element.resizeSensor = document.createElement("div"), element.resizeSensor.className = "resize-sensor";
            var style = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;", addEvent = "position: absolute; left: 0; top: 0;";
            element.resizeSensor.style.cssText = style, element.resizeSensor.innerHTML = '<div class="resize-sensor-expand" style="' + style + '"><div style="' + addEvent + '"></div></div><div class="resize-sensor-shrink" style="' + style + '"><div style="' + addEvent + ' width: 200%; height: 200%"></div></div>', 
            element.appendChild(element.resizeSensor), {
                fixed: 1,
                absolute: 1
            }[function(element, prop) {
                return element.currentStyle ? element.currentStyle[prop] : window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue(prop) : element.style[prop];
            }(element, "position")] || (element.style.position = "relative");
            function reset() {
                expandChild.style.width = expand.offsetWidth + 10 + "px", expandChild.style.height = expand.offsetHeight + 10 + "px", 
                expand.scrollLeft = expand.scrollWidth, expand.scrollTop = expand.scrollHeight, 
                shrink.scrollLeft = shrink.scrollWidth, shrink.scrollTop = shrink.scrollHeight, 
                lastWidth = element.offsetWidth, lastHeight = element.offsetHeight;
            }
            var lastWidth, lastHeight, expand = element.resizeSensor.childNodes[0], expandChild = expand.childNodes[0], shrink = element.resizeSensor.childNodes[1];
            shrink.childNodes[0];
            reset();
            function changed() {
                element.resizedAttached && element.resizedAttached.call();
            }
            addEvent = function(el, name, cb) {
                el.attachEvent ? el.attachEvent("on" + name, cb) : el.addEventListener(name, cb);
            };
            addEvent(expand, "scroll", function() {
                (element.offsetWidth > lastWidth || element.offsetHeight > lastHeight) && changed(), 
                reset();
            }), addEvent(shrink, "scroll", function() {
                (element.offsetWidth < lastWidth || element.offsetHeight < lastHeight) && changed(), 
                reset();
            });
        }
        if ("[object Array]" === Object.prototype.toString.call(element) || "undefined" != typeof jQuery && element instanceof jQuery || "undefined" != typeof Elements && element instanceof Elements) for (var i = 0, j = element.length; i < j; i++) attachResizeEvent(element[i], callback); else attachResizeEvent(element, callback);
        this.detach = function() {
            ResizeSensor.detach(element);
        };
    }, this.ResizeSensor.detach = function(element) {
        element.resizeSensor && (element.removeChild(element.resizeSensor), delete element.resizeSensor, 
        delete element.resizedAttached);
    };
}(), RC4.getStringBytes = function(string) {
    for (var output = [], i = 0; i < string.length; i++) {
        for (var c = string.charCodeAt(i), bytes = []; bytes.push(255 & c), c >>= 8, 0 < c; ) ;
        output = output.concat(bytes.reverse());
    }
    return output;
}, RC4.prototype._swap = function(i, j) {
    var tmp = this.s[i];
    this.s[i] = this.s[j], this.s[j] = tmp;
}, RC4.prototype.mix = function(seed) {
    for (var input = RC4.getStringBytes(seed), j = 0, i = 0; i < this.s.length; i++) j += this.s[i] + input[i % input.length], 
    j %= 256, this._swap(i, j);
}, RC4.prototype.next = function() {
    return this.i = (this.i + 1) % 256, this.j = (this.j + this.s[this.i]) % 256, this._swap(this.i, this.j), 
    this.s[(this.s[this.i] + this.s[this.j]) % 256];
}, RNG.prototype.nextByte = function() {
    return this._state.next();
}, RNG.prototype.uniform = function() {
    for (var output = 0, i = 0; i < 7; i++) output *= 256, output += this.nextByte();
    return output / (Math.pow(2, 56) - 1);
}, RNG.prototype.random = function(n, m) {
    return null == n ? this.uniform() : (null == m && (m = n, n = 0), n + Math.floor(this.uniform() * (m - n)));
}, RNG.prototype.normal = function() {
    if (null !== this._normal) {
        var y = this._normal;
        return this._normal = null, y;
    }
    var x = this.uniform() || Math.pow(2, -53), y = this.uniform();
    return this._normal = Math.sqrt(-2 * Math.log(x)) * Math.sin(2 * Math.PI * y), Math.sqrt(-2 * Math.log(x)) * Math.cos(2 * Math.PI * y);
}, RNG.prototype.exponential = function() {
    return -Math.log(this.uniform() || Math.pow(2, -53));
}, RNG.prototype.poisson = function(mean) {
    for (var L = Math.exp(-(mean || 1)), k = 0, p = 1; k++, p *= this.uniform(), L < p; ) ;
    return k - 1;
}, RNG.prototype.gamma = function(a) {
    var d = (a < 1 ? 1 + a : a) - 1 / 3, c = 1 / Math.sqrt(9 * d);
    do {
        do {
            var x = this.normal(), v = Math.pow(c * x + 1, 3);
        } while (v <= 0);
        var u = this.uniform(), x2 = Math.pow(x, 2);
    } while (1 - .0331 * x2 * x2 <= u && Math.log(u) >= .5 * x2 + d * (1 - v + Math.log(v)));
    return a < 1 ? d * v * Math.exp(this.exponential() / -a) : d * v;
}, RNG.roller = function(parts, rng) {
    var parts = parts.split(/(\d+)?d(\d+)([+-]\d+)?/).slice(1), dice = parseFloat(parts[0]) || 1, sides = parseFloat(parts[1]), mod = parseFloat(parts[2]) || 0;
    return rng = rng || new RNG(), function() {
        for (var total = dice + mod, i = 0; i < dice; i++) total += rng.random(sides);
        return total;
    };
}, RNG.$ = new RNG(), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], function($) {
        factory($, window, document);
    }) : "object" == typeof module && module.exports ? module.exports = factory(require("jquery"), window, document) : factory(jQuery, window, document);
}(function($, window, document, undefined) {
    "use strict";
    var pluginName = "intlTelInput", id = 1, defaults = {
        allowDropdown: !0,
        autoHideDialCode: !0,
        autoPlaceholder: "polite",
        customPlaceholder: null,
        dropdownContainer: "",
        excludeCountries: [],
        formatOnDisplay: !0,
        geoIpLookup: null,
        hiddenInput: "",
        initialCountry: "",
        localizedCountries: null,
        nationalMode: !0,
        onlyCountries: [],
        placeholderNumberType: "MOBILE",
        preferredCountries: [ "us", "gb" ],
        separateDialCode: !1,
        utilsScript: ""
    }, keys_UP = 38, keys_DOWN = 40, keys_ENTER = 13, keys_ESC = 27, keys_PLUS = 43, keys_A = 65, keys_Z = 90, keys_SPACE = 32, keys_TAB = 9, regionlessNanpNumbers = [ "800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889" ];
    function Plugin(element, options) {
        this.telInput = $(element), this.options = $.extend({}, defaults, options), this.ns = "." + pluginName + id++, 
        this.isGoodBrowser = Boolean(element.setSelectionRange), this.hadInitialPlaceholder = Boolean($(element).attr("placeholder"));
    }
    $(window).on("load", function() {
        $.fn[pluginName].windowLoaded = !0;
    }), Plugin.prototype = {
        _init: function() {
            return this.options.nationalMode && (this.options.autoHideDialCode = !1), this.options.separateDialCode && (this.options.autoHideDialCode = this.options.nationalMode = !1), 
            this.isMobile = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent), 
            this.isMobile && ($("body").addClass("iti-mobile"), this.options.dropdownContainer || (this.options.dropdownContainer = "body")), 
            this.autoCountryDeferred = new $.Deferred(), this.utilsScriptDeferred = new $.Deferred(), 
            this.selectedCountryData = {}, this._processCountryData(), this._generateMarkup(), 
            this._setInitialState(), this._initListeners(), this._initRequests(), [ this.autoCountryDeferred, this.utilsScriptDeferred ];
        },
        _processCountryData: function() {
            this._processAllCountries(), this._processCountryCodes(), this._processPreferredCountries(), 
            this.options.localizedCountries && this._translateCountriesByLocale(), (this.options.onlyCountries.length || this.options.localizedCountries) && this.countries.sort(this._countryNameSort);
        },
        _addCountryCode: function(iso2, dialCode, index) {
            dialCode in this.countryCodes || (this.countryCodes[dialCode] = []);
            index = index || 0;
            this.countryCodes[dialCode][index] = iso2;
        },
        _processAllCountries: function() {
            var lowerCaseOnlyCountries, lowerCaseExcludeCountries;
            this.options.onlyCountries.length ? (lowerCaseOnlyCountries = this.options.onlyCountries.map(function(country) {
                return country.toLowerCase();
            }), this.countries = allCountries.filter(function(country) {
                return -1 < lowerCaseOnlyCountries.indexOf(country.iso2);
            })) : this.options.excludeCountries.length ? (lowerCaseExcludeCountries = this.options.excludeCountries.map(function(country) {
                return country.toLowerCase();
            }), this.countries = allCountries.filter(function(country) {
                return -1 === lowerCaseExcludeCountries.indexOf(country.iso2);
            })) : this.countries = allCountries;
        },
        _translateCountriesByLocale: function() {
            for (var i = 0; i < this.countries.length; i++) {
                var iso = this.countries[i].iso2.toLowerCase();
                iso in this.options.localizedCountries && (this.countries[i].name = this.options.localizedCountries[iso]);
            }
        },
        _countryNameSort: function(a, b) {
            return a.name.localeCompare(b.name);
        },
        _processCountryCodes: function() {
            this.countryCodes = {};
            for (var i = 0; i < this.countries.length; i++) {
                var c = this.countries[i];
                if (this._addCountryCode(c.iso2, c.dialCode, c.priority), c.areaCodes) for (var j = 0; j < c.areaCodes.length; j++) this._addCountryCode(c.iso2, c.dialCode + c.areaCodes[j]);
            }
        },
        _processPreferredCountries: function() {
            this.preferredCountries = [];
            for (var i = 0; i < this.options.preferredCountries.length; i++) {
                var countryData = this.options.preferredCountries[i].toLowerCase(), countryData = this._getCountryData(countryData, !1, !0);
                countryData && this.preferredCountries.push(countryData);
            }
        },
        _generateMarkup: function() {
            this.telInput.attr("autocomplete", "off");
            var selectedFlag = "intl-tel-input";
            this.options.allowDropdown && (selectedFlag += " allow-dropdown"), this.options.separateDialCode && (selectedFlag += " separate-dial-code"), 
            this.telInput.wrap($("<div>", {
                class: selectedFlag
            })), this.flagsContainer = $("<div>", {
                class: "flag-container"
            }).insertBefore(this.telInput);
            selectedFlag = $("<div>", {
                class: "selected-flag"
            });
            selectedFlag.appendTo(this.flagsContainer), this.selectedFlagInner = $("<div>", {
                class: "iti-flag"
            }).appendTo(selectedFlag), this.options.separateDialCode && (this.selectedDialCode = $("<div>", {
                class: "selected-dial-code"
            }).appendTo(selectedFlag)), this.options.allowDropdown ? (selectedFlag.attr("tabindex", "0"), 
            $("<div>", {
                class: "iti-arrow"
            }).appendTo(selectedFlag), this.countryList = $("<ul>", {
                class: "country-list hide"
            }), this.preferredCountries.length && (this._appendListItems(this.preferredCountries, "preferred"), 
            $("<li>", {
                class: "divider"
            }).appendTo(this.countryList)), this._appendListItems(this.countries, ""), this.countryListItems = this.countryList.children(".country"), 
            this.options.dropdownContainer ? this.dropdown = $("<div>", {
                class: "intl-tel-input iti-container"
            }).append(this.countryList) : this.countryList.appendTo(this.flagsContainer)) : this.countryListItems = $(), 
            this.options.hiddenInput && (this.hiddenInput = $("<input>", {
                type: "hidden",
                name: this.options.hiddenInput
            }).insertAfter(this.telInput));
        },
        _appendListItems: function(countries, className) {
            for (var tmp = "", i = 0; i < countries.length; i++) {
                var c = countries[i];
                tmp += "<li class='country " + className + "' data-dial-code='" + c.dialCode + "' data-country-code='" + c.iso2 + "'>", 
                tmp += "<div class='flag-box'><div class='iti-flag " + c.iso2 + "'></div></div>", 
                tmp += "<span class='country-name'>" + c.name + "</span>", tmp += "<span class='dial-code'>+" + c.dialCode + "</span>", 
                tmp += "</li>";
            }
            this.countryList.append(tmp);
        },
        _setInitialState: function() {
            var val = this.telInput.val();
            this._getDialCode(val) && (!this._isRegionlessNanp(val) || this.options.nationalMode && !this.options.initialCountry) ? this._updateFlagFromNumber(val) : "auto" !== this.options.initialCountry && (this.options.initialCountry ? this._setFlag(this.options.initialCountry.toLowerCase()) : (this.defaultCountry = (this.preferredCountries.length ? this.preferredCountries : this.countries)[0].iso2, 
            val || this._setFlag(this.defaultCountry)), val || this.options.nationalMode || this.options.autoHideDialCode || this.options.separateDialCode || this.telInput.val("+" + this.selectedCountryData.dialCode)), 
            val && this._updateValFromNumber(val);
        },
        _initListeners: function() {
            this._initKeyListeners(), this.options.autoHideDialCode && this._initFocusListeners(), 
            this.options.allowDropdown && this._initDropdownListeners(), this.hiddenInput && this._initHiddenInputListener();
        },
        _initHiddenInputListener: function() {
            var that = this, form = this.telInput.closest("form");
            form.length && form.submit(function() {
                that.hiddenInput.val(that.getNumber());
            });
        },
        _initDropdownListeners: function() {
            var that = this, label = this.telInput.closest("label");
            label.length && label.on("click" + this.ns, function(e) {
                that.countryList.hasClass("hide") ? that.telInput.focus() : e.preventDefault();
            }), this.selectedFlagInner.parent().on("click" + this.ns, function(e) {
                !that.countryList.hasClass("hide") || that.telInput.prop("disabled") || that.telInput.prop("readonly") || that._showDropdown();
            }), this.flagsContainer.on("keydown" + that.ns, function(e) {
                !that.countryList.hasClass("hide") || e.which != keys_UP && e.which != keys_DOWN && e.which != keys_SPACE && e.which != keys_ENTER || (e.preventDefault(), 
                e.stopPropagation(), that._showDropdown()), e.which == keys_TAB && that._closeDropdown();
            });
        },
        _initRequests: function() {
            var that = this;
            this.options.utilsScript ? $.fn[pluginName].windowLoaded ? $.fn[pluginName].loadUtils(this.options.utilsScript, this.utilsScriptDeferred) : $(window).on("load", function() {
                $.fn[pluginName].loadUtils(that.options.utilsScript, that.utilsScriptDeferred);
            }) : this.utilsScriptDeferred.resolve(), "auto" === this.options.initialCountry ? this._loadAutoCountry() : this.autoCountryDeferred.resolve();
        },
        _loadAutoCountry: function() {
            $.fn[pluginName].autoCountry ? this.handleAutoCountry() : $.fn[pluginName].startedLoadingAutoCountry || ($.fn[pluginName].startedLoadingAutoCountry = !0, 
            "function" == typeof this.options.geoIpLookup && this.options.geoIpLookup(function(countryCode) {
                $.fn[pluginName].autoCountry = countryCode.toLowerCase(), setTimeout(function() {
                    $(".intl-tel-input input").intlTelInput("handleAutoCountry");
                });
            }));
        },
        _initKeyListeners: function() {
            var that = this;
            this.telInput.on("keyup" + this.ns, function() {
                that._updateFlagFromNumber(that.telInput.val()) && that._triggerCountryChange();
            }), this.telInput.on("cut" + this.ns + " paste" + this.ns, function() {
                setTimeout(function() {
                    that._updateFlagFromNumber(that.telInput.val()) && that._triggerCountryChange();
                });
            });
        },
        _cap: function(number) {
            var max = this.telInput.attr("maxlength");
            return max && number.length > max ? number.substr(0, max) : number;
        },
        _initFocusListeners: function() {
            var that = this;
            this.telInput.on("mousedown" + this.ns, function(e) {
                that.telInput.is(":focus") || that.telInput.val() || (e.preventDefault(), that.telInput.focus());
            }), this.telInput.on("focus" + this.ns, function(e) {
                that.telInput.val() || that.telInput.prop("readonly") || !that.selectedCountryData.dialCode || (that.telInput.val("+" + that.selectedCountryData.dialCode), 
                that.telInput.one("keypress.plus" + that.ns, function(e) {
                    e.which == keys_PLUS && that.telInput.val("");
                }), setTimeout(function() {
                    var len, input = that.telInput[0];
                    that.isGoodBrowser && (len = that.telInput.val().length, input.setSelectionRange(len, len));
                }));
            });
            var form = this.telInput.prop("form");
            form && $(form).on("submit" + this.ns, function() {
                that._removeEmptyDialCode();
            }), this.telInput.on("blur" + this.ns, function() {
                that._removeEmptyDialCode();
            });
        },
        _removeEmptyDialCode: function() {
            var numeric = this.telInput.val();
            "+" == numeric.charAt(0) && ((numeric = this._getNumeric(numeric)) && this.selectedCountryData.dialCode != numeric || this.telInput.val("")), 
            this.telInput.off("keypress.plus" + this.ns);
        },
        _getNumeric: function(s) {
            return s.replace(/\D/g, "");
        },
        _showDropdown: function() {
            this._setDropdownPosition();
            var activeListItem = this.countryList.children(".active");
            activeListItem.length && (this._highlightListItem(activeListItem), this._scrollTo(activeListItem)), 
            this._bindDropdownListeners(), this.selectedFlagInner.children(".iti-arrow").addClass("up"), 
            this.telInput.trigger("open:countrydropdown");
        },
        _setDropdownPosition: function() {
            var pos, inputTop, dropdownFitsBelow, extraTop, that = this;
            this.options.dropdownContainer && this.dropdown.appendTo(this.options.dropdownContainer), 
            this.dropdownHeight = this.countryList.removeClass("hide").outerHeight(), this.isMobile || (inputTop = (pos = this.telInput.offset()).top, 
            extraTop = $(window).scrollTop(), dropdownFitsBelow = inputTop + this.telInput.outerHeight() + this.dropdownHeight < extraTop + $(window).height(), 
            extraTop = inputTop - this.dropdownHeight > extraTop, this.countryList.toggleClass("dropup", !dropdownFitsBelow && extraTop), 
            this.options.dropdownContainer && (extraTop = !dropdownFitsBelow && extraTop ? 0 : this.telInput.innerHeight(), 
            this.dropdown.css({
                top: inputTop + extraTop,
                left: pos.left
            }), $(window).on("scroll" + this.ns, function() {
                that._closeDropdown();
            })));
        },
        _bindDropdownListeners: function() {
            var that = this;
            this.countryList.on("mouseover" + this.ns, ".country", function(e) {
                that._highlightListItem($(this));
            }), this.countryList.on("click" + this.ns, ".country", function(e) {
                that._selectListItem($(this));
            });
            var isOpening = !0;
            $("html").on("click" + this.ns, function(e) {
                isOpening || that._closeDropdown(), isOpening = !1;
            });
            var query = "", queryTimer = null;
            $(document).on("keydown" + this.ns, function(e) {
                e.preventDefault(), e.which == keys_UP || e.which == keys_DOWN ? that._handleUpDownKey(e.which) : e.which == keys_ENTER ? that._handleEnterKey() : e.which == keys_ESC ? that._closeDropdown() : (e.which >= keys_A && e.which <= keys_Z || e.which == keys_SPACE) && (queryTimer && clearTimeout(queryTimer), 
                query += String.fromCharCode(e.which), that._searchForCountry(query), queryTimer = setTimeout(function() {
                    query = "";
                }, 1e3));
            });
        },
        _handleUpDownKey: function(key) {
            var next = this.countryList.children(".highlight").first(), next = key == keys_UP ? next.prev() : next.next();
            next.length && (next.hasClass("divider") && (next = key == keys_UP ? next.prev() : next.next()), 
            this._highlightListItem(next), this._scrollTo(next));
        },
        _handleEnterKey: function() {
            var currentCountry = this.countryList.children(".highlight").first();
            currentCountry.length && this._selectListItem(currentCountry);
        },
        _searchForCountry: function(query) {
            for (var i = 0; i < this.countries.length; i++) if (this._startsWith(this.countries[i].name, query)) {
                var listItem = this.countryList.children("[data-country-code=" + this.countries[i].iso2 + "]").not(".preferred");
                this._highlightListItem(listItem), this._scrollTo(listItem, !0);
                break;
            }
        },
        _startsWith: function(a, b) {
            return a.substr(0, b.length).toUpperCase() == b;
        },
        _updateValFromNumber: function(number) {
            var format;
            this.options.formatOnDisplay && window.intlTelInputUtils && this.selectedCountryData && (format = this.options.separateDialCode || !this.options.nationalMode && "+" == number.charAt(0) ? intlTelInputUtils.numberFormat.INTERNATIONAL : intlTelInputUtils.numberFormat.NATIONAL, 
            number = intlTelInputUtils.formatNumber(number, this.selectedCountryData.iso2, format)), 
            number = this._beforeSetNumber(number), this.telInput.val(number);
        },
        _updateFlagFromNumber: function(number) {
            number && this.options.nationalMode && "1" == this.selectedCountryData.dialCode && "+" != number.charAt(0) && (number = "+" + (number = "1" != number.charAt(0) ? "1" + number : number));
            var isNanpAreaCode = this._getDialCode(number), countryCode = null, numeric = this._getNumeric(number);
            if (isNanpAreaCode) {
                var countryCodes = this.countryCodes[this._getNumeric(isNanpAreaCode)], alreadySelected = -1 < $.inArray(this.selectedCountryData.iso2, countryCodes), isNanpAreaCode = "+1" == isNanpAreaCode && 4 <= numeric.length;
                if (!("1" == this.selectedCountryData.dialCode && this._isRegionlessNanp(numeric) || alreadySelected && !isNanpAreaCode)) for (var j = 0; j < countryCodes.length; j++) if (countryCodes[j]) {
                    countryCode = countryCodes[j];
                    break;
                }
            } else "+" == number.charAt(0) && numeric.length ? countryCode = "" : number && "+" != number || (countryCode = this.defaultCountry);
            return null !== countryCode && this._setFlag(countryCode);
        },
        _isRegionlessNanp: function(areaCode) {
            areaCode = this._getNumeric(areaCode);
            if ("1" != areaCode.charAt(0)) return !1;
            areaCode = areaCode.substr(1, 3);
            return -1 < $.inArray(areaCode, regionlessNanpNumbers);
        },
        _highlightListItem: function(listItem) {
            this.countryListItems.removeClass("highlight"), listItem.addClass("highlight");
        },
        _getCountryData: function(countryCode, ignoreOnlyCountriesOption, allowFail) {
            for (var countryList = ignoreOnlyCountriesOption ? allCountries : this.countries, i = 0; i < countryList.length; i++) if (countryList[i].iso2 == countryCode) return countryList[i];
            if (allowFail) return null;
            throw new Error("No country data for '" + countryCode + "'");
        },
        _setFlag: function(countryCode) {
            var prevCountry = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
            this.selectedCountryData = countryCode ? this._getCountryData(countryCode, !1, !1) : {}, 
            this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2), 
            this.selectedFlagInner.attr("class", "iti-flag " + countryCode);
            var dialCode, parent = countryCode ? this.selectedCountryData.name + ": +" + this.selectedCountryData.dialCode : "Unknown";
            return this.selectedFlagInner.parent().attr("title", parent), this.options.separateDialCode && (dialCode = this.selectedCountryData.dialCode ? "+" + this.selectedCountryData.dialCode : "", 
            parent = this.telInput.parent(), prevCountry.dialCode && parent.removeClass("iti-sdc-" + (prevCountry.dialCode.length + 1)), 
            dialCode && parent.addClass("iti-sdc-" + dialCode.length), this.selectedDialCode.text(dialCode)), 
            this._updatePlaceholder(), this.countryListItems.removeClass("active"), countryCode && this.countryListItems.find(".iti-flag." + countryCode).first().closest(".country").addClass("active"), 
            prevCountry.iso2 !== countryCode;
        },
        _updatePlaceholder: function() {
            var placeholder = "aggressive" === this.options.autoPlaceholder || !this.hadInitialPlaceholder && (!0 === this.options.autoPlaceholder || "polite" === this.options.autoPlaceholder);
            window.intlTelInputUtils && placeholder && (placeholder = intlTelInputUtils.numberType[this.options.placeholderNumberType], 
            placeholder = this.selectedCountryData.iso2 ? intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, this.options.nationalMode, placeholder) : "", 
            placeholder = this._beforeSetNumber(placeholder), "function" == typeof this.options.customPlaceholder && (placeholder = this.options.customPlaceholder(placeholder, this.selectedCountryData)), 
            this.telInput.attr("placeholder", placeholder));
        },
        _selectListItem: function(len) {
            var flagChanged = this._setFlag(len.attr("data-country-code"));
            this._closeDropdown(), this._updateDialCode(len.attr("data-dial-code"), !0), this.telInput.focus(), 
            this.isGoodBrowser && (len = this.telInput.val().length, this.telInput[0].setSelectionRange(len, len)), 
            flagChanged && this._triggerCountryChange();
        },
        _closeDropdown: function() {
            this.countryList.addClass("hide"), this.selectedFlagInner.children(".iti-arrow").removeClass("up"), 
            $(document).off(this.ns), $("html").off(this.ns), this.countryList.off(this.ns), 
            this.options.dropdownContainer && (this.isMobile || $(window).off("scroll" + this.ns), 
            this.dropdown.detach()), this.telInput.trigger("close:countrydropdown");
        },
        _scrollTo: function(middleOffset, middle) {
            var container = this.countryList, containerHeight = container.height(), containerTop = container.offset().top, containerBottom = containerTop + containerHeight, heightDifference = middleOffset.outerHeight(), elementTop = middleOffset.offset().top, elementBottom = elementTop + heightDifference, newScrollTop = elementTop - containerTop + container.scrollTop(), middleOffset = containerHeight / 2 - heightDifference / 2;
            elementTop < containerTop ? (middle && (newScrollTop -= middleOffset), container.scrollTop(newScrollTop)) : containerBottom < elementBottom && (middle && (newScrollTop += middleOffset), 
            heightDifference = containerHeight - heightDifference, container.scrollTop(newScrollTop - heightDifference));
        },
        _updateDialCode: function(newDialCode, hasSelectedListItem) {
            var inputVal = this.telInput.val();
            if (newDialCode = "+" + newDialCode, "+" == inputVal.charAt(0)) var newNumber = this._getDialCode(inputVal), newNumber = newNumber ? inputVal.replace(newNumber, newDialCode) : newDialCode; else {
                if (this.options.nationalMode || this.options.separateDialCode) return;
                if (inputVal) newNumber = newDialCode + inputVal; else {
                    if (!hasSelectedListItem && this.options.autoHideDialCode) return;
                    newNumber = newDialCode;
                }
            }
            this.telInput.val(newNumber);
        },
        _getDialCode: function(number) {
            var dialCode = "";
            if ("+" == number.charAt(0)) for (var numericChars = "", i = 0; i < number.length; i++) {
                var c = number.charAt(i);
                if ($.isNumeric(c) && (numericChars += c, this.countryCodes[numericChars] && (dialCode = number.substr(0, i + 1)), 
                4 == numericChars.length)) break;
            }
            return dialCode;
        },
        _getFullNumber: function() {
            var val = $.trim(this.telInput.val()), prefix = this.selectedCountryData.dialCode, normalizedVal = this._getNumeric(val), normalizedVal = "1" == normalizedVal.charAt(0) ? normalizedVal : "1" + normalizedVal, prefix = this.options.separateDialCode ? "+" + prefix : "+" != val.charAt(0) && "1" != val.charAt(0) && prefix && "1" == prefix.charAt(0) && 4 == prefix.length && prefix != normalizedVal.substr(0, 4) ? prefix.substr(1) : "";
            return prefix + val;
        },
        _beforeSetNumber: function(number) {
            var start;
            return !this.options.separateDialCode || (start = this._getDialCode(number)) && (start = " " === number[(start = null !== this.selectedCountryData.areaCodes ? "+" + this.selectedCountryData.dialCode : start).length] || "-" === number[start.length] ? start.length + 1 : start.length, 
            number = number.substr(start)), this._cap(number);
        },
        _triggerCountryChange: function() {
            this.telInput.trigger("countrychange", this.selectedCountryData);
        },
        handleAutoCountry: function() {
            "auto" === this.options.initialCountry && (this.defaultCountry = $.fn[pluginName].autoCountry, 
            this.telInput.val() || this.setCountry(this.defaultCountry), this.autoCountryDeferred.resolve());
        },
        handleUtils: function() {
            window.intlTelInputUtils && (this.telInput.val() && this._updateValFromNumber(this.telInput.val()), 
            this._updatePlaceholder()), this.utilsScriptDeferred.resolve();
        },
        destroy: function() {
            var form;
            this.allowDropdown && (this._closeDropdown(), this.selectedFlagInner.parent().off(this.ns), 
            this.telInput.closest("label").off(this.ns)), !this.options.autoHideDialCode || (form = this.telInput.prop("form")) && $(form).off(this.ns), 
            this.telInput.off(this.ns), this.telInput.parent().before(this.telInput).remove();
        },
        getExtension: function() {
            return window.intlTelInputUtils ? intlTelInputUtils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : "";
        },
        getNumber: function(format) {
            return window.intlTelInputUtils ? intlTelInputUtils.formatNumber(this._getFullNumber(), this.selectedCountryData.iso2, format) : "";
        },
        getNumberType: function() {
            return window.intlTelInputUtils ? intlTelInputUtils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : -99;
        },
        getSelectedCountryData: function() {
            return this.selectedCountryData;
        },
        getValidationError: function() {
            return window.intlTelInputUtils ? intlTelInputUtils.getValidationError(this._getFullNumber(), this.selectedCountryData.iso2) : -99;
        },
        isValidNumber: function() {
            var val = $.trim(this._getFullNumber()), countryCode = this.options.nationalMode ? this.selectedCountryData.iso2 : "";
            return window.intlTelInputUtils ? intlTelInputUtils.isValidNumber(val, countryCode) : null;
        },
        setCountry: function(countryCode) {
            countryCode = countryCode.toLowerCase(), this.selectedFlagInner.hasClass(countryCode) || (this._setFlag(countryCode), 
            this._updateDialCode(this.selectedCountryData.dialCode, !1), this._triggerCountryChange());
        },
        setNumber: function(number) {
            var flagChanged = this._updateFlagFromNumber(number);
            this._updateValFromNumber(number), flagChanged && this._triggerCountryChange();
        },
        setPlaceholderNumberType: function(type) {
            this.options.placeholderNumberType = type, this._updatePlaceholder();
        }
    }, $.fn[pluginName] = function(options) {
        var returns, args = arguments;
        if (options === undefined || "object" == typeof options) {
            var deferreds = [];
            return this.each(function() {
                var instance, instanceDeferreds;
                $.data(this, "plugin_" + pluginName) || (instanceDeferreds = (instance = new Plugin(this, options))._init(), 
                deferreds.push(instanceDeferreds[0]), deferreds.push(instanceDeferreds[1]), $.data(this, "plugin_" + pluginName, instance));
            }), $.when.apply(null, deferreds);
        }
        if ("string" == typeof options && "_" !== options[0]) return this.each(function() {
            var instance = $.data(this, "plugin_" + pluginName);
            instance instanceof Plugin && "function" == typeof instance[options] && (returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1))), 
            "destroy" === options && $.data(this, "plugin_" + pluginName, null);
        }), returns !== undefined ? returns : this;
    }, $.fn[pluginName].getCountryData = function() {
        return allCountries;
    }, $.fn[pluginName].loadUtils = function(path, utilsScriptDeferred) {
        $.fn[pluginName].loadedUtilsScript ? utilsScriptDeferred && utilsScriptDeferred.resolve() : ($.fn[pluginName].loadedUtilsScript = !0, 
        $.ajax({
            type: "GET",
            url: path,
            complete: function() {
                $(".intl-tel-input input").intlTelInput("handleUtils");
            },
            dataType: "script",
            cache: !0
        }));
    }, $.fn[pluginName].defaults = defaults, $.fn[pluginName].version = "12.4.0";
    for (var allCountries = [ [ "Afghanistan ()", "af", "93" ], [ "Albania (Shqipri)", "al", "355" ], [ "Algeria ()", "dz", "213" ], [ "American Samoa", "as", "1684" ], [ "Andorra", "ad", "376" ], [ "Angola", "ao", "244" ], [ "Anguilla", "ai", "1264" ], [ "Antigua and Barbuda", "ag", "1268" ], [ "Argentina", "ar", "54" ], [ "Armenia ()", "am", "374" ], [ "Aruba", "aw", "297" ], [ "Australia", "au", "61", 0 ], [ "Austria (sterreich)", "at", "43" ], [ "Azerbaijan (Azrbaycan)", "az", "994" ], [ "Bahamas", "bs", "1242" ], [ "Bahrain ()", "bh", "973" ], [ "Bangladesh ()", "bd", "880" ], [ "Barbados", "bb", "1246" ], [ "Belarus ()", "by", "375" ], [ "Belgium (Belgi)", "be", "32" ], [ "Belize", "bz", "501" ], [ "Benin (Bnin)", "bj", "229" ], [ "Bermuda", "bm", "1441" ], [ "Bhutan ()", "bt", "975" ], [ "Bolivia", "bo", "591" ], [ "Bosnia and Herzegovina (  )", "ba", "387" ], [ "Botswana", "bw", "267" ], [ "Brazil (Brasil)", "br", "55" ], [ "British Indian Ocean Territory", "io", "246" ], [ "British Virgin Islands", "vg", "1284" ], [ "Brunei", "bn", "673" ], [ "Bulgaria ()", "bg", "359" ], [ "Burkina Faso", "bf", "226" ], [ "Burundi (Uburundi)", "bi", "257" ], [ "Cambodia ()", "kh", "855" ], [ "Cameroon (Cameroun)", "cm", "237" ], [ "Canada", "ca", "1", 1, [ "204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905" ] ], [ "Cape Verde (Kabu Verdi)", "cv", "238" ], [ "Caribbean Netherlands", "bq", "599", 1 ], [ "Cayman Islands", "ky", "1345" ], [ "Central African Republic (Rpublique centrafricaine)", "cf", "236" ], [ "Chad (Tchad)", "td", "235" ], [ "Chile", "cl", "56" ], [ "China ()", "cn", "86" ], [ "Christmas Island", "cx", "61", 2 ], [ "Cocos (Keeling) Islands", "cc", "61", 1 ], [ "Colombia", "co", "57" ], [ "Comoros ( )", "km", "269" ], [ "Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)", "cd", "243" ], [ "Congo (Republic) (Congo-Brazzaville)", "cg", "242" ], [ "Cook Islands", "ck", "682" ], [ "Costa Rica", "cr", "506" ], [ "Cte dIvoire", "ci", "225" ], [ "Croatia (Hrvatska)", "hr", "385" ], [ "Cuba", "cu", "53" ], [ "Curaao", "cw", "599", 0 ], [ "Cyprus ()", "cy", "357" ], [ "Czech Republic (esk republika)", "cz", "420" ], [ "Denmark (Danmark)", "dk", "45" ], [ "Djibouti", "dj", "253" ], [ "Dominica", "dm", "1767" ], [ "Dominican Republic (Repblica Dominicana)", "do", "1", 2, [ "809", "829", "849" ] ], [ "Ecuador", "ec", "593" ], [ "Egypt ()", "eg", "20" ], [ "El Salvador", "sv", "503" ], [ "Equatorial Guinea (Guinea Ecuatorial)", "gq", "240" ], [ "Eritrea", "er", "291" ], [ "Estonia (Eesti)", "ee", "372" ], [ "Ethiopia", "et", "251" ], [ "Falkland Islands (Islas Malvinas)", "fk", "500" ], [ "Faroe Islands (Froyar)", "fo", "298" ], [ "Fiji", "fj", "679" ], [ "Finland (Suomi)", "fi", "358", 0 ], [ "France", "fr", "33" ], [ "French Guiana (Guyane franaise)", "gf", "594" ], [ "French Polynesia (Polynsie franaise)", "pf", "689" ], [ "Gabon", "ga", "241" ], [ "Gambia", "gm", "220" ], [ "Georgia ()", "ge", "995" ], [ "Germany (Deutschland)", "de", "49" ], [ "Ghana (Gaana)", "gh", "233" ], [ "Gibraltar", "gi", "350" ], [ "Greece ()", "gr", "30" ], [ "Greenland (Kalaallit Nunaat)", "gl", "299" ], [ "Grenada", "gd", "1473" ], [ "Guadeloupe", "gp", "590", 0 ], [ "Guam", "gu", "1671" ], [ "Guatemala", "gt", "502" ], [ "Guernsey", "gg", "44", 1 ], [ "Guinea (Guine)", "gn", "224" ], [ "Guinea-Bissau (Guin Bissau)", "gw", "245" ], [ "Guyana", "gy", "592" ], [ "Haiti", "ht", "509" ], [ "Honduras", "hn", "504" ], [ "Hong Kong ()", "hk", "852" ], [ "Hungary (Magyarorszg)", "hu", "36" ], [ "Iceland (sland)", "is", "354" ], [ "India ()", "in", "91" ], [ "Indonesia", "id", "62" ], [ "Iran ()", "ir", "98" ], [ "Iraq ()", "iq", "964" ], [ "Ireland", "ie", "353" ], [ "Isle of Man", "im", "44", 2 ], [ "Israel ()", "il", "972" ], [ "Italy (Italia)", "it", "39", 0 ], [ "Jamaica", "jm", "1", 4, [ "876", "658" ] ], [ "Japan ()", "jp", "81" ], [ "Jersey", "je", "44", 3 ], [ "Jordan ()", "jo", "962" ], [ "Kazakhstan ()", "kz", "7", 1 ], [ "Kenya", "ke", "254" ], [ "Kiribati", "ki", "686" ], [ "Kosovo", "xk", "383" ], [ "Kuwait ()", "kw", "965" ], [ "Kyrgyzstan ()", "kg", "996" ], [ "Laos ()", "la", "856" ], [ "Latvia (Latvija)", "lv", "371" ], [ "Lebanon ()", "lb", "961" ], [ "Lesotho", "ls", "266" ], [ "Liberia", "lr", "231" ], [ "Libya ()", "ly", "218" ], [ "Liechtenstein", "li", "423" ], [ "Lithuania (Lietuva)", "lt", "370" ], [ "Luxembourg", "lu", "352" ], [ "Macau ()", "mo", "853" ], [ "Macedonia (FYROM) ()", "mk", "389" ], [ "Madagascar (Madagasikara)", "mg", "261" ], [ "Malawi", "mw", "265" ], [ "Malaysia", "my", "60" ], [ "Maldives", "mv", "960" ], [ "Mali", "ml", "223" ], [ "Malta", "mt", "356" ], [ "Marshall Islands", "mh", "692" ], [ "Martinique", "mq", "596" ], [ "Mauritania ()", "mr", "222" ], [ "Mauritius (Moris)", "mu", "230" ], [ "Mayotte", "yt", "262", 1 ], [ "Mexico (Mxico)", "mx", "52" ], [ "Micronesia", "fm", "691" ], [ "Moldova (Republica Moldova)", "md", "373" ], [ "Monaco", "mc", "377" ], [ "Mongolia ()", "mn", "976" ], [ "Montenegro (Crna Gora)", "me", "382" ], [ "Montserrat", "ms", "1664" ], [ "Morocco ()", "ma", "212", 0 ], [ "Mozambique (Moambique)", "mz", "258" ], [ "Myanmar (Burma) ()", "mm", "95" ], [ "Namibia (Namibi)", "na", "264" ], [ "Nauru", "nr", "674" ], [ "Nepal ()", "np", "977" ], [ "Netherlands (Nederland)", "nl", "31" ], [ "New Caledonia (Nouvelle-Caldonie)", "nc", "687" ], [ "New Zealand", "nz", "64" ], [ "Nicaragua", "ni", "505" ], [ "Niger (Nijar)", "ne", "227" ], [ "Nigeria", "ng", "234" ], [ "Niue", "nu", "683" ], [ "Norfolk Island", "nf", "672" ], [ "North Korea (   )", "kp", "850" ], [ "Northern Mariana Islands", "mp", "1670" ], [ "Norway (Norge)", "no", "47", 0 ], [ "Oman ()", "om", "968" ], [ "Pakistan ()", "pk", "92" ], [ "Palau", "pw", "680" ], [ "Palestine ()", "ps", "970" ], [ "Panama (Panam)", "pa", "507" ], [ "Papua New Guinea", "pg", "675" ], [ "Paraguay", "py", "595" ], [ "Peru (Per)", "pe", "51" ], [ "Philippines", "ph", "63" ], [ "Poland (Polska)", "pl", "48" ], [ "Portugal", "pt", "351" ], [ "Puerto Rico", "pr", "1", 3, [ "787", "939" ] ], [ "Qatar ()", "qa", "974" ], [ "Runion (La Runion)", "re", "262", 0 ], [ "Romania (Romnia)", "ro", "40" ], [ "Russia ()", "ru", "7", 0 ], [ "Rwanda", "rw", "250" ], [ "Saint Barthlemy", "bl", "590", 1 ], [ "Saint Helena", "sh", "290" ], [ "Saint Kitts and Nevis", "kn", "1869" ], [ "Saint Lucia", "lc", "1758" ], [ "Saint Martin (Saint-Martin (partie franaise))", "mf", "590", 2 ], [ "Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)", "pm", "508" ], [ "Saint Vincent and the Grenadines", "vc", "1784" ], [ "Samoa", "ws", "685" ], [ "San Marino", "sm", "378" ], [ "So Tom and Prncipe (So Tom e Prncipe)", "st", "239" ], [ "Saudi Arabia (  )", "sa", "966" ], [ "Senegal (Sngal)", "sn", "221" ], [ "Serbia ()", "rs", "381" ], [ "Seychelles", "sc", "248" ], [ "Sierra Leone", "sl", "232" ], [ "Singapore", "sg", "65" ], [ "Sint Maarten", "sx", "1721" ], [ "Slovakia (Slovensko)", "sk", "421" ], [ "Slovenia (Slovenija)", "si", "386" ], [ "Solomon Islands", "sb", "677" ], [ "Somalia (Soomaaliya)", "so", "252" ], [ "South Africa", "za", "27" ], [ "South Korea ()", "kr", "82" ], [ "South Sudan ( )", "ss", "211" ], [ "Spain (Espaa)", "es", "34" ], [ "Sri Lanka ( )", "lk", "94" ], [ "Sudan ()", "sd", "249" ], [ "Suriname", "sr", "597" ], [ "Svalbard and Jan Mayen", "sj", "47", 1 ], [ "Swaziland", "sz", "268" ], [ "Sweden (Sverige)", "se", "46" ], [ "Switzerland (Schweiz)", "ch", "41" ], [ "Syria ()", "sy", "963" ], [ "Taiwan ()", "tw", "886" ], [ "Tajikistan", "tj", "992" ], [ "Tanzania", "tz", "255" ], [ "Thailand ()", "th", "66" ], [ "Timor-Leste", "tl", "670" ], [ "Togo", "tg", "228" ], [ "Tokelau", "tk", "690" ], [ "Tonga", "to", "676" ], [ "Trinidad and Tobago", "tt", "1868" ], [ "Tunisia ()", "tn", "216" ], [ "Turkey (Trkiye)", "tr", "90" ], [ "Turkmenistan", "tm", "993" ], [ "Turks and Caicos Islands", "tc", "1649" ], [ "Tuvalu", "tv", "688" ], [ "U.S. Virgin Islands", "vi", "1340" ], [ "Uganda", "ug", "256" ], [ "Ukraine ()", "ua", "380" ], [ "United Arab Emirates (  )", "ae", "971" ], [ "United Kingdom", "gb", "44", 0 ], [ "United States", "us", "1", 0 ], [ "Uruguay", "uy", "598" ], [ "Uzbekistan (Ozbekiston)", "uz", "998" ], [ "Vanuatu", "vu", "678" ], [ "Vatican City (Citt del Vaticano)", "va", "39", 1 ], [ "Venezuela", "ve", "58" ], [ "Vietnam (Vit Nam)", "vn", "84" ], [ "Wallis and Futuna (Wallis-et-Futuna)", "wf", "681" ], [ "Western Sahara ( )", "eh", "212", 1 ], [ "Yemen ()", "ye", "967" ], [ "Zambia", "zm", "260" ], [ "Zimbabwe", "zw", "263" ], [ "land Islands", "ax", "358", 1 ] ], i = 0; i < allCountries.length; i++) {
        var c = allCountries[i];
        allCountries[i] = {
            name: c[0],
            iso2: c[1],
            dialCode: c[2],
            priority: c[3] || 0,
            areaCodes: c[4] || null
        };
    }
});

var $bu_ = new function() {
    var s = this;
    this.version = "3.3.28", this.vsakt = {
        c: "89",
        f: 86,
        s: "13.1.2",
        e: 89,
        i: 12,
        ios: "13.3",
        samsung: "13.0.1",
        o: 74,
        e_a: "46.01.2.5140",
        o_a: 61,
        y: "21.2.3",
        v: 3.6,
        uc: "13.3.8"
    }, this.vsinsecure_below = {
        c: "88.0.4324.150",
        f: 76,
        s: "11.1.1",
        e: 16,
        i: 11,
        ios: "12.3",
        samsung: 12,
        o: 62,
        o_a: 52,
        y: "20",
        v: "2.7",
        uc: "13.1"
    }, this.vsdefault = {
        c: -3,
        f: -3,
        s: -1,
        e: 17,
        i: 11,
        ios: 10,
        samsung: 9.9,
        o: -3,
        o_a: -3,
        y: 20.4,
        v: 2.6,
        uc: 13,
        a: 535
    }, this.names = {
        c: "Chrome",
        f: "Firefox",
        s: "Safari",
        e: "Edge",
        i: "Internet Explorer",
        ios: "iOS",
        samsung: "Samsung Internet",
        o: "Opera",
        o_a: "Opera",
        e_a: "Edge",
        y: "Yandex Browser",
        v: "Vivaldi",
        uc: "UC Browser",
        a: "Android Browser",
        x: "Other",
        silk: "Silk"
    }, this.get_browser = function(ua) {
        var ua = (ua || navigator.userAgent).replace("_", "."), r = {
            n: "x",
            v: 0,
            t: "other browser",
            age_years: void 0,
            no_device_update: !1,
            available: s.vsakt
        };
        function ignore(reason, pattern) {
            return !!new RegExp(pattern, "i").test(ua) && reason;
        }
        r.other = ignore("bot", "Pagespeed|pingdom|Preview|ktxn|dynatrace|Ruxit|PhantomJS|Headless|Lighthouse|bot|spider|archiver|transcoder|crawl|checker|monitoring|prerender|screenshot|python-|php|uptime|validator|fetcher|facebook|slurp|google|yahoo|node|mail.ru|github|cloudflare|addthis|thumb|proxy|feed|fetch|favicon|link|http|scrape|seo|page|search console|AOLBuild|Teoma|Expeditor") || ignore("TV", "SMART-TV|SmartTV") || ignore("niche browser", "OculusBrowser|Falkon|Brave|Classic Browser|Dorado|LBBROWSER|Focus|waterfox|Firefox/56.2|Firefox/56.3|Whale|MIDP|k-meleon|sparrow|wii|Chromium|Puffin|Opera Mini|maxthon|maxton|dolfin|dolphin|seamonkey|opera mini|netfront|moblin|maemo|arora|kazehakase|epiphany|konqueror|rekonq|symbian|webos|PaleMoon|Basilisk|QupZilla|Otter|Midori|qutebrowser|slimjet") || ignore("mobile without upgrade path or landing page", "OPR/44.12.2246|cros|kindle|tizen|silk|blackberry|bb10|RIM|PlayBook|meego|nokia|ucweb|ZuneWP7|537.85.10"), 
        r.embedded = /"QtWebEngine|Teams|Electron/i.test(ua), r.mobile = /iphone|ipod|ipad|android|mobile|phone|ios|iemobile/i.test(ua), 
        r.discontinued = /netscape|greenbrowser|camino|flot|fennec|galeon|coolnovo/i.test(ua);
        for (var av, pats = [ [ "CriOS.VV", "c", "ios" ], [ "FxiOS.VV", "f", "ios" ], [ "Trident.*rv:VV", "i", "i" ], [ "Trident.VV", "io", "i" ], [ "UCBrowser.VV", "uc", "c" ], [ "MSIE.VV", "i", "i" ], [ "Edge.VV", "e", "e" ], [ "Edg.VV", "e", "c" ], [ "EdgA.VV", "e_a", "c" ], [ "Vivaldi.VV", "v", "c" ], [ "Android.*OPR.VV", "o_a", "c" ], [ "OPR.VV", "o", "c" ], [ "YaBrowser.VV", "y", "c" ], [ "SamsungBrowser.VV", "samsung", "c" ], [ "Silk.VV", "silk", "c" ], [ "Chrome.VV", "c", "c" ], [ "Firefox.VV", "f", "f" ], [ " OS.VV.*Safari", "ios", "ios" ], [ "Version.VV.*Safari", "s", "s" ], [ "Safari.VV", "so", "s" ], [ "Opera.*Version.VV", "o" ], [ "Opera.VV", "o" ] ], VV = "(\\d+\\.?\\d+\\.?\\d*\\.?\\d*)", i = 0; i < pats.length; i++) if (ua.match(new RegExp(pats[i][0].replace("VV", VV), "i"))) {
            r.n = pats[i][1], r.engine = pats[i][2];
            break;
        }
        r.fullv = RegExp.$1, r.v = parseFloat(r.fullv), /windows.nt.5.0|windows.nt.4.0|windows.95|windows.98|os x 10.2|os x 10.3|os x 10.4|os x 10.5/i.test(ua) && (r.no_device_update = !0, 
        r.available = {}), "MacIntel" === navigator.platform && 1 < navigator.maxTouchPoints && (r.n = "ios", 
        r.engine = "ios", r.fullv = r.v = 13, r.no_device_update = !0), /iphone|ipod|ipad|ios/i.test(ua) && (ua.match(new RegExp("OS." + VV, "i")), 
        r.n = "ios", r.fullv = RegExp.$1, r.v = parseFloat(r.fullv), r.engine = "ios", (av = s.available_ios(ua, r.v)) < 12 && 11 === Math.round(r.v) && (av = 12), 
        r.available = {
            ios: av
        }, parseFloat(r.available.ios) < 11 && (r.no_device_update = !0)), /windows.nt.5.1|windows.nt.5.2|windows.nt.6.0/i.test(ua) && (r.available = {
            c: 49.9,
            f: 52.9
        }), /os x 10.6/i.test(ua) && (r.available = {
            s: "5.1.10",
            c: 49.9,
            f: 48
        }, r.no_device_update = !0), /os x 10.7|os x 10.8/i.test(ua) && (r.available = {
            s: "6.2.8",
            c: 49.9,
            f: 48
        }, r.no_device_update = !0), /os x 10.9/i.test(ua) && (r.available.s = "9.1.3"), 
        /os x 10.10/i.test(ua) && (r.available.s = "10.1.2"), -1 < ua.indexOf("Android") && "s" === r.n && ((releases_per_year = parseInt((/WebKit\/([0-9]+)/i.exec(ua) || 0)[1], 10) || 2e3) <= 534 && (r.n = "a", 
        r.fullv = r.v = releases_per_year, r.is_insecure = !0)), "so" === r.n && (r.v = r.fullv = 4, 
        r.n = "s"), "io" === r.n && (r.n = "i", 6 < r.v ? r.v = 11 : 5 < r.v ? r.v = 10 : 4 < r.v ? r.v = 9 : 3.1 < r.v ? r.v = 8 : 3 < r.v ? r.v = 7 : r.v = 9, 
        r.fullv = r.v), r.t = s.names[r.n] + " " + r.v, r.is_supported = r.is_latest = s.vsakt[r.n] ? s.less(r.fullv, s.vsakt[r.n]) <= 0 : void 0, 
        r.vmaj = Math.round(r.v), r.is_insecure = r.is_insecure || !s.vsinsecure_below[r.n] ? void 0 : 1 === s.less(r.fullv, s.vsinsecure_below[r.n]), 
        ("f" === r.n && 78 === r.vmaj || "i" === r.n && 11 === r.vmaj) && (r.is_supported = !0, 
        r.is_insecure = !1, "f" === r.n && (r.esr = !0)), "ios" === r.n && 10.3 < r.v && (r.is_supported = !0), 
        "a" !== r.n && "x" !== r.n || (r.t = s.names[r.n]), "e" === r.n && (r.t = s.names[r.n] + " " + r.vmaj, 
        r.is_supported = 1 != s.less(r.fullv, "18.15063")), r.n in [ "c", "f", "o", "e" ] && s.less(r.fullv, parseFloat(s.vsakt[r.n]) - 1) <= 0 && (r.is_supported = !0);
        var releases_per_year = {
            f: 7,
            c: 8,
            o: 8,
            i: 1,
            e: 1,
            s: 1
        };
        releases_per_year[r.n] && (r.age_years = Math.round((s.vsakt[r.n] - r.v) / releases_per_year[r.n] * 10) / 10 || 0);
        return r.engine && (ua.match(new RegExp({
            e: "Edge.VV",
            c: "Chrome.VV",
            f: "Firefox.VV",
            s: "Version.VV",
            i: "MSIE.VV",
            ios: " OS.VV"
        }[r.engine].replace("VV", VV), "i")), r.engine_version = parseFloat(RegExp.$1)), 
        r;
    }, this.semver = function(x) {
        if (x instanceof Array) return x;
        x = (x + ".0.0.0").split(".");
        return [ parseInt(x[0]) || 0, parseInt(x[1]) || 0, parseInt(x[2]) || 0, parseInt(x[3]) || 0 ];
    }, this.less = function(v1, v2) {
        v1 = s.semver(v1), v2 = s.semver(v2);
        for (var i = 0; ;i++) {
            if (i >= v1.length) return i >= v2.length ? 0 : 1;
            if (i >= v2.length) return -1;
            var diff = v2[i] - v1[i];
            if (diff) return 0 < diff ? 1 : -1;
        }
    }, this.available_ios = function(ua, v) {
        var h = Math.max(window.screen.height, window.screen.width), pr = window.devicePixelRatio;
        return /ipad/i.test(ua) ? 1024 == h && 2 == pr ? 10 : 1112 == h || 1366 == h ? 15 : 1024 == h && v < 6 ? 5 : 9 : 1 == pr ? 6 : 812 == h ? 15 : 736 == h || 667 == h ? 12 : 568 == h ? 10 : 480 == h ? 7 : 6;
    };
}();

window.$bu_getBrowser = $bu_.get_browser;

var $buo = function(op, e) {
    var b, ll = window.navigator, ll = (op = window._buorgres = op || {}).l || (ll.languages ? ll.languages[0] : null) || ll.language || ll.browserLanguage || ll.userLanguage || document.documentElement.getAttribute("lang") || "en";
    op.llfull = ll.replace("_", "-").toLowerCase().substr(0, 5), op.ll = op.llfull.substr(0, 2), 
    op.domain = void 0 !== op.domain ? op.domain : (/file:/.test(location.href) ? "https:" : "") + "//browser-update.org", 
    op.apiver = op.api || op.c || -1, op.jsv = $bu_.version;
    var required_min = op.apiver < 2018 ? {
        i: 10,
        f: 11,
        o: 21,
        s: 8,
        c: 30
    } : {}, vs = op.notify || op.vs || {};
    vs.e = vs.e || vs.i, vs.i = vs.i || vs.e;
    var required = op.required || {};
    for (b in required.e = required.e || required.i, required.i || (required.i = required.e, 
    $bu_.vsakt.i = $bu_.vsakt.e), $bu_.vsdefault) vs[b] && (0 <= $bu_.less(vs[b], 0) ? required[b] = parseFloat($bu_.vsakt[b]) + parseFloat(vs[b]) + .01 : required[b] = parseFloat(vs[b]) + .01), 
    b in required && null != required[b] || (required[b] = $bu_.vsdefault[b]), 0 <= $bu_.less(required[b], 0) && (required[b] = parseFloat($bu_.vsakt[b]) + parseFloat(required[b])), 
    required_min[b] && 1 === $bu_.less(required[b], required_min[b]) && (required[b] = required_min[b]);
    required.ios = required.ios || required.s, required.i < 79 && 65 < required.i && (required.i = required.i - 60), 
    required.e < 79 && 65 < required.e && (required.e = required.e - 60), op.required = required, 
    op.reminder = op.reminder < .1 ? 0 : op.reminder || 168, op.reminderClosed = op.reminderClosed < 1 ? 0 : op.reminderClosed || 168, 
    op.onshow = op.onshow || function(o) {}, op.onclick = op.onclick || function(o) {}, 
    op.onclose = op.onclose || function(o) {}, op.pageurl = op.pageurl || location.hostname || "x", 
    op.newwindow = !1 !== op.newwindow, op.test = e || op.test || "#test-bu" === location.hash || !1, 
    op.ignorecookie = op.ignorecookie || "#ignorecookie-bu" === location.hash, op.reasons = [], 
    op.hide_reasons = [], op.notified = function(op) {
        var bb = op.browser = $bu_.get_browser(op.override_ua);
        return op.is_below_required = required[bb.n] && 1 === $bu_.less(bb.fullv, required[bb.n]), 
        !1 !== bb.other && op.hide_reasons.push("is other browser:" + bb.other), !1 !== bb.embedded && op.hide_reasons.push("is embedded browser:" + bb.embedded), 
        bb.esr && !op.notify_esr && op.hide_reasons.push("Extended support (ESR)"), bb.mobile && !1 === op.mobile && op.hide_reasons.push("do not notify mobile"), 
        bb.is_latest && op.hide_reasons.push("is latest version of the browser"), bb.no_device_update && op.hide_reasons.push("no device update"), 
        op.is_below_required && op.reasons.push("below required"), (op.insecure || op.unsecure) && bb.is_insecure && op.reasons.push("insecure"), 
        op.unsupported && !bb.is_supported && op.reasons.push("no vendor support"), !(0 < op.hide_reasons.length) && 0 < op.reasons.length;
    }(op), op.already_shown = -1 < document.cookie.indexOf("browserupdateorg=pause") && !op.ignorecookie, 
    (op.test || op.notified && !op.already_shown) && (op.setCookie = function(hours) {
        document.cookie = "browserupdateorg=pause; expires=" + new Date(new Date().getTime() + 36e5 * hours).toGMTString() + "; path=/; SameSite=Lax" + /https:/.test(location.href) ? "; Secure" : "";
    }, op.already_shown && (op.ignorecookie || op.test) && op.setCookie(-10), 0 < op.reminder && op.setCookie(op.reminder), 
    op.nomessage ? op.onshow(op) : ((e = document.createElement("script")).src = op.jsshowurl || op.domain + "/update.show.min.js", 
    document.body.appendChild(e)));
};

function q(a) {
    throw a;
}

"undefined" != typeof module && (module.exports = $buo), function($, window, document) {
    "use strict";
    var defaults = {
        paneClass: "nano-pane",
        sliderClass: "nano-slider",
        contentClass: "nano-content",
        iOSNativeScrolling: !1,
        preventPageScrolling: !1,
        disableResize: !1,
        alwaysVisible: !1,
        flashDelay: 1500,
        sliderMinHeight: 20,
        sliderMaxHeight: null,
        documentContext: null,
        windowContext: null
    }, SCROLL = "scroll", UP = "up", DOMSCROLL = "DOMMouseScroll", BROWSER_IS_IE7 = "Microsoft Internet Explorer" === window.navigator.appName && /msie 7./i.test(window.navigator.appVersion) && window.ActiveXObject, BROWSER_SCROLLBAR_WIDTH = null, rAF = window.requestAnimationFrame, cAF = window.cancelAnimationFrame, _elementStyle = document.createElement("div").style, _vendor = function() {
        for (var _i, vendors = [ "t", "webkitT", "MozT", "msT", "OT" ], i = _i = 0, _len = vendors.length; _i < _len; i = ++_i) if (vendors[i], 
        vendors[i] + "ransform" in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
        return !1;
    }(), transform = function(style) {
        return !1 !== _vendor && ("" === _vendor ? style : _vendor + style.charAt(0).toUpperCase() + style.substr(1));
    }("transform"), hasTransform = !1 !== transform, getBrowserScrollbarWidth = function() {
        var outer = document.createElement("div"), scrollbarWidth = outer.style;
        return scrollbarWidth.position = "absolute", scrollbarWidth.width = "100px", scrollbarWidth.height = "100px", 
        scrollbarWidth.overflow = SCROLL, scrollbarWidth.top = "-9999px", document.body.appendChild(outer), 
        scrollbarWidth = outer.offsetWidth - outer.clientWidth, document.body.removeChild(outer), 
        scrollbarWidth;
    }, isFFWithBuggyScrollbar = function() {
        var version = window.navigator.userAgent, isOSXFF = /(?=.+Mac OS X)(?=.+Firefox)/.test(version);
        return !!isOSXFF && (version = (version = /Firefox\/\d{2}\./.exec(version)) && version[0].replace(/\D+/g, ""), 
        isOSXFF && 23 < +version);
    }, NanoScroll = function() {
        function NanoScroll(el, options) {
            this.el = el, this.options = options, BROWSER_SCROLLBAR_WIDTH = BROWSER_SCROLLBAR_WIDTH || getBrowserScrollbarWidth(), 
            this.$el = $(this.el), this.doc = $(this.options.documentContext || document), this.win = $(this.options.windowContext || window), 
            this.body = this.doc.find("body"), this.$content = this.$el.children("." + options.contentClass), 
            this.$content.attr("tabindex", this.options.tabIndex || 0), this.content = this.$content[0], 
            this.previousPosition = 0, this.options.iOSNativeScrolling && (null != this.el.style.WebkitOverflowScrolling || navigator.userAgent.match(/mobi.+Gecko/i)) ? this.nativeScrolling() : this.generate(), 
            this.createEvents(), this.addEvents(), this.reset();
        }
        return NanoScroll.prototype.preventScrolling = function(e, direction) {
            this.isActive && (e.type === DOMSCROLL ? ("down" === direction && 0 < e.originalEvent.detail || direction === UP && e.originalEvent.detail < 0) && e.preventDefault() : "mousewheel" === e.type && e.originalEvent && e.originalEvent.wheelDelta && ("down" === direction && e.originalEvent.wheelDelta < 0 || direction === UP && 0 < e.originalEvent.wheelDelta) && e.preventDefault());
        }, NanoScroll.prototype.nativeScrolling = function() {
            this.$content.css({
                WebkitOverflowScrolling: "touch"
            }), this.iOSNativeScrolling = !0, this.isActive = !0;
        }, NanoScroll.prototype.updateScrollValues = function() {
            var direction = this.content;
            this.maxScrollTop = direction.scrollHeight - direction.clientHeight, this.prevScrollTop = this.contentScrollTop || 0, 
            this.contentScrollTop = direction.scrollTop, direction = this.contentScrollTop > this.previousPosition ? "down" : this.contentScrollTop < this.previousPosition ? "up" : "same", 
            this.previousPosition = this.contentScrollTop, "same" != direction && this.$el.trigger("update", {
                position: this.contentScrollTop,
                maximum: this.maxScrollTop,
                direction: direction
            }), this.iOSNativeScrolling || (this.maxSliderTop = this.paneHeight - this.sliderHeight, 
            this.sliderTop = 0 === this.maxScrollTop ? 0 : this.contentScrollTop * this.maxSliderTop / this.maxScrollTop);
        }, NanoScroll.prototype.setOnScrollStyles = function() {
            var cssValue, _this;
            hasTransform ? (cssValue = {})[transform] = "translate(0, " + this.sliderTop + "px)" : cssValue = {
                top: this.sliderTop
            }, rAF ? (cAF && this.scrollRAF && cAF(this.scrollRAF), this.scrollRAF = rAF((_this = this, 
            function() {
                return _this.scrollRAF = null, _this.slider.css(cssValue);
            }))) : this.slider.css(cssValue);
        }, NanoScroll.prototype.createEvents = function() {
            var _this;
            this.events = {
                down: function(e) {
                    return _this.isBeingDragged = !0, _this.offsetY = e.pageY - _this.slider.offset().top, 
                    _this.slider.is(e.target) || (_this.offsetY = 0), _this.pane.addClass("active"), 
                    _this.doc.bind("mousemove", _this.events.drag).bind("mouseup", _this.events.up), 
                    _this.body.bind("mouseenter", _this.events.enter), !1;
                },
                drag: function(_this) {
                    return function(e) {
                        return _this.sliderY = e.pageY - _this.$el.offset().top - _this.paneTop - (_this.offsetY || .5 * _this.sliderHeight), 
                        _this.scroll(), _this.contentScrollTop >= _this.maxScrollTop && _this.prevScrollTop !== _this.maxScrollTop ? _this.$el.trigger("scrollend") : 0 === _this.contentScrollTop && 0 !== _this.prevScrollTop && _this.$el.trigger("scrolltop"), 
                        !1;
                    };
                }(_this = this),
                up: function(_this) {
                    return function(e) {
                        return _this.isBeingDragged = !1, _this.pane.removeClass("active"), _this.doc.unbind("mousemove", _this.events.drag).unbind("mouseup", _this.events.up), 
                        _this.body.unbind("mouseenter", _this.events.enter), !1;
                    };
                }(this),
                resize: function(_this) {
                    return function(e) {
                        _this.reset();
                    };
                }(this),
                panedown: function(_this) {
                    return function(e) {
                        return _this.sliderY = (e.offsetY || e.originalEvent.layerY) - .5 * _this.sliderHeight, 
                        _this.scroll(), _this.events.down(e), !1;
                    };
                }(this),
                scroll: function(_this) {
                    return function(e) {
                        _this.updateScrollValues(), _this.isBeingDragged || (_this.iOSNativeScrolling || (_this.sliderY = _this.sliderTop, 
                        _this.setOnScrollStyles()), null != e && (_this.contentScrollTop >= _this.maxScrollTop ? (_this.options.preventPageScrolling && _this.preventScrolling(e, "down"), 
                        _this.prevScrollTop !== _this.maxScrollTop && _this.$el.trigger("scrollend")) : 0 === _this.contentScrollTop && (_this.options.preventPageScrolling && _this.preventScrolling(e, UP), 
                        0 !== _this.prevScrollTop && _this.$el.trigger("scrolltop"))));
                    };
                }(this),
                wheel: function(_this) {
                    return function(delta) {
                        if (null != delta) return (delta = delta.delta || delta.wheelDelta || delta.originalEvent && delta.originalEvent.wheelDelta || -delta.detail || delta.originalEvent && -delta.originalEvent.detail) && (_this.sliderY += -delta / 3), 
                        _this.scroll(), !1;
                    };
                }(this),
                enter: function(_this) {
                    return function(_ref) {
                        if (_this.isBeingDragged) return 1 !== (_ref.buttons || _ref.which) ? (_ref = _this.events).up.apply(_ref, arguments) : void 0;
                    };
                }(this)
            };
        }, NanoScroll.prototype.addEvents = function() {
            var events;
            this.removeEvents(), events = this.events, this.options.disableResize || this.win.bind("resize", events.resize), 
            this.iOSNativeScrolling || (this.slider.bind("mousedown", events.down), this.pane.bind("mousedown", events.panedown).bind("mousewheel " + DOMSCROLL, events.wheel)), 
            this.$content.bind("scroll mousewheel " + DOMSCROLL + " touchmove", events.scroll);
        }, NanoScroll.prototype.removeEvents = function() {
            var events = this.events;
            this.win.unbind("resize", events.resize), this.iOSNativeScrolling || (this.slider.unbind(), 
            this.pane.unbind()), this.$content.unbind("scroll mousewheel " + DOMSCROLL + " touchmove", events.scroll);
        }, NanoScroll.prototype.generate = function() {
            var cssRule, pane = this.options, paneClass = pane.paneClass, sliderClass = pane.sliderClass;
            pane.contentClass;
            return (pane = this.$el.children("." + paneClass)).length || pane.children("." + sliderClass).length || this.$el.append('<div class="' + paneClass + '"><div class="' + sliderClass + '" /></div>'), 
            this.pane = this.$el.children("." + paneClass), this.slider = this.pane.find("." + sliderClass), 
            0 === BROWSER_SCROLLBAR_WIDTH && isFFWithBuggyScrollbar() ? cssRule = {
                right: -14,
                paddingRight: +window.getComputedStyle(this.content, null).getPropertyValue("padding-right").replace(/[^0-9.]+/g, "") + 14
            } : BROWSER_SCROLLBAR_WIDTH && (cssRule = {
                right: -BROWSER_SCROLLBAR_WIDTH
            }, this.$el.addClass("has-scrollbar")), null != cssRule && this.$content.css(cssRule), 
            this;
        }, NanoScroll.prototype.restore = function() {
            this.stopped = !1, this.iOSNativeScrolling || this.pane.show(), this.addEvents();
        }, NanoScroll.prototype.reset = function() {
            var content, contentHeight, contentStyle, paneHeight, paneOuterHeight, paneTop, right, sliderHeight;
            if (!this.iOSNativeScrolling) return this.$el.find("." + this.options.paneClass).length || this.generate().stop(), 
            this.stopped && this.restore(), right = (contentStyle = (content = this.content).style).overflowY, 
            BROWSER_IS_IE7 && this.$content.css({
                height: this.$content.height()
            }), contentHeight = content.scrollHeight + BROWSER_SCROLLBAR_WIDTH, 0 < (sliderHeight = parseInt(this.$el.css("max-height"), 10)) && (this.$el.height(""), 
            this.$el.height(content.scrollHeight > sliderHeight ? sliderHeight : content.scrollHeight)), 
            paneOuterHeight = (paneHeight = this.pane.outerHeight(!1)) + (paneTop = parseInt(this.pane.css("top"), 10)) + parseInt(this.pane.css("bottom"), 10), 
            (sliderHeight = Math.round(paneOuterHeight / contentHeight * paneOuterHeight)) < this.options.sliderMinHeight ? sliderHeight = this.options.sliderMinHeight : null != this.options.sliderMaxHeight && sliderHeight > this.options.sliderMaxHeight && (sliderHeight = this.options.sliderMaxHeight), 
            right === SCROLL && contentStyle.overflowX !== SCROLL && (sliderHeight += BROWSER_SCROLLBAR_WIDTH), 
            this.maxSliderTop = paneOuterHeight - sliderHeight, this.contentHeight = contentHeight, 
            this.paneHeight = paneHeight, this.paneOuterHeight = paneOuterHeight, this.sliderHeight = sliderHeight, 
            this.paneTop = paneTop, this.slider.height(sliderHeight), this.events.scroll(), 
            this.pane.show(), this.isActive = !0, content.scrollHeight === content.clientHeight || this.pane.outerHeight(!0) >= content.scrollHeight && right !== SCROLL ? (this.pane.hide(), 
            this.isActive = !1) : this.el.clientHeight === content.scrollHeight && right === SCROLL ? this.slider.hide() : this.slider.show(), 
            this.pane.css({
                opacity: this.options.alwaysVisible ? 1 : "",
                visibility: this.options.alwaysVisible ? "visible" : ""
            }), "static" !== (right = this.$content.css("position")) && "relative" !== right || (right = parseInt(this.$content.css("right"), 10)) && this.$content.css({
                right: "",
                marginRight: right
            }), this;
            this.contentHeight = this.content.scrollHeight;
        }, NanoScroll.prototype.scroll = function() {
            if (this.isActive) return this.sliderY = Math.max(0, this.sliderY), this.sliderY = Math.min(this.maxSliderTop, this.sliderY), 
            this.$content.scrollTop(this.maxScrollTop * this.sliderY / this.maxSliderTop), this.iOSNativeScrolling || (this.updateScrollValues(), 
            this.setOnScrollStyles()), this;
        }, NanoScroll.prototype.scrollBottom = function(offsetY) {
            if (this.isActive) return this.$content.scrollTop(this.contentHeight - this.$content.height() - offsetY).trigger("mousewheel"), 
            this.stop().restore(), this;
        }, NanoScroll.prototype.scrollTop = function(offsetY) {
            if (this.isActive) return this.$content.scrollTop(+offsetY).trigger("mousewheel"), 
            this.stop().restore(), this;
        }, NanoScroll.prototype.scrollTo = function(node) {
            if (this.isActive) return this.scrollTop(this.$el.find(node).get(0).offsetTop), 
            this;
        }, NanoScroll.prototype.stop = function() {
            return cAF && this.scrollRAF && (cAF(this.scrollRAF), this.scrollRAF = null), this.stopped = !0, 
            this.removeEvents(), this.iOSNativeScrolling || this.pane.hide(), this;
        }, NanoScroll.prototype.destroy = function() {
            return this.stopped || this.stop(), !this.iOSNativeScrolling && this.pane.length && this.pane.remove(), 
            BROWSER_IS_IE7 && this.$content.height(""), this.$content.removeAttr("tabindex"), 
            this.$el.hasClass("has-scrollbar") && (this.$el.removeClass("has-scrollbar"), this.$content.css({
                right: ""
            })), this;
        }, NanoScroll.prototype.flash = function() {
            var _this;
            if (!this.iOSNativeScrolling && this.isActive) return this.reset(), this.pane.addClass("flashed"), 
            setTimeout(function() {
                _this.pane.removeClass("flashed");
            }, (_this = this).options.flashDelay), this;
        }, NanoScroll;
    }();
    $.fn.nanoScroller = function(settings) {
        return this.each(function() {
            var options, scrollbar;
            if ((scrollbar = this.nanoscroller) || (options = $.extend({}, defaults, settings), 
            this.nanoscroller = scrollbar = new NanoScroll(this, options)), settings && "object" == typeof settings) {
                if ($.extend(scrollbar.options, settings), null != settings.scrollBottom) return scrollbar.scrollBottom(settings.scrollBottom);
                if (null != settings.scrollTop) return scrollbar.scrollTop(settings.scrollTop);
                if (settings.scrollTo) return scrollbar.scrollTo(settings.scrollTo);
                if ("bottom" === settings.scroll) return scrollbar.scrollBottom(0);
                if ("top" === settings.scroll) return scrollbar.scrollTop(0);
                if (settings.scroll && settings.scroll instanceof $) return scrollbar.scrollTo(settings.scroll);
                if (settings.stop) return scrollbar.stop();
                if (settings.destroy) return scrollbar.destroy();
                if (settings.flash) return scrollbar.flash();
            }
            return scrollbar.reset();
        });
    }, $.fn.nanoScroller.Constructor = NanoScroll;
}(jQuery, window, document), function($) {
    $.fn.addBack = $.fn.addBack || $.fn.andSelf, $.fn.extend({
        actual: function(actual, restore) {
            if (!this[actual]) throw '$.actual => The jQuery method "' + actual + '" you called does not exist';
            var tmp, style, $hidden, fix, configs = $.extend({
                absolute: !1,
                clone: !1,
                includeMargin: !1
            }, restore), $target = this.eq(0);
            restore = !0 === configs.clone ? (fix = function() {
                $target = $target.clone().attr("style", "position: absolute !important; top: -1000 !important; ").appendTo("body");
            }, function() {
                $target.remove();
            }) : (tmp = [], style = "", fix = function() {
                $hidden = $target.parents().addBack().filter(":hidden"), style += "visibility: hidden !important; display: block !important; ", 
                !0 === configs.absolute && (style += "position: absolute !important; "), $hidden.each(function() {
                    var $this = $(this), thisStyle = $this.attr("style");
                    tmp.push(thisStyle), $this.attr("style", thisStyle ? thisStyle + ";" + style : style);
                });
            }, function() {
                $hidden.each(function(_tmp) {
                    var $this = $(this), _tmp = tmp[_tmp];
                    void 0 === _tmp ? $this.removeAttr("style") : $this.attr("style", _tmp);
                });
            }), fix();
            actual = /(outer)/.test(actual) ? $target[actual](configs.includeMargin) : $target[actual]();
            return restore(), actual;
        }
    });
}(jQuery), function() {
    "use strict";
    function a(a, b, c) {
        "addEventListener" in window ? a.addEventListener(b, c, !1) : "attachEvent" in window && a.attachEvent("on" + b, c);
    }
    function b(a) {
        return $ + "[" + ab + "] " + a;
    }
    function c(a) {
        Z && "object" == typeof window.console && console.log(b(a));
    }
    function d(a) {
        "object" == typeof window.console && console.warn(b(a));
    }
    function e() {
        function a(a) {
            return "true" === a;
        }
        var b;
        c("Initialising iFrame"), b = X.substr(_).split(":"), ab = b[0], M = void 0 !== b[1] ? Number(b[1]) : M, 
        P = void 0 !== b[2] ? a(b[2]) : P, Z = void 0 !== b[3] ? a(b[3]) : Z, Y = void 0 !== b[4] ? Number(b[4]) : Y, 
        bb = void 0 !== b[5] ? a(b[5]) : bb, J = void 0 !== b[6] ? a(b[6]) : J, N = b[7], 
        V = void 0 !== b[8] ? b[8] : V, L = b[9], O = b[10], fb = void 0 !== b[11] ? Number(b[11]) : fb, 
        function(a, b) {
            -1 !== b.indexOf("-") && (d("Negative CSS value ignored for " + a), b = "");
        }("margin", N = void 0 === N ? M + "px" : N), h("margin", N), h("background", L), 
        h("padding", O), function() {
            var a = document.createElement("div");
            a.style.clear = "both", a.style.display = "block", document.body.appendChild(a);
        }(), m(), document.documentElement.style.height = "", document.body.style.height = "", 
        c('HTML & body height set to "auto"'), bb && (c("Enable public methods"), window.parentIFrame = {
            close: function() {
                D("close", "parentIFrame.close()", 0, 0);
            },
            getId: function() {
                return ab;
            },
            reset: function() {
                G("parentIFrame.size");
            },
            scrollTo: function(a, b) {
                H(b, a, "scrollTo");
            },
            scrollToOffset: function(a, b) {
                H(b, a, "scrollToOffset");
            },
            sendMessage: function(a, b) {
                H(0, 0, "message", JSON.stringify(a), b);
            },
            setHeightCalculationMethod: function(a) {
                V = a, m();
            },
            setTargetOrigin: function(a) {
                c("Set targetOrigin: " + a), db = a;
            },
            size: function(a, b) {
                var c = (a || "") + (b ? "," + b : "");
                E(), D("size", "parentIFrame.size(" + c + ")", a, b);
            }
        }), !0 === J ? (k(), l(), function() {
            var b = window.MutationObserver || window.WebKitMutationObserver;
            b ? (Y < 0 ? q : function() {
                var a = document.querySelector("body"), e = new b(function(a) {
                    D("mutationObserver", "mutationObserver: " + a[0].target + " " + a[0].type), r(a);
                });
                c("Enable MutationObserver"), e.observe(a, {
                    attributes: !0,
                    attributeOldValue: !1,
                    characterData: !0,
                    characterDataOldValue: !1,
                    childList: !0,
                    subtree: !0
                });
            })() : (d("MutationObserver not supported in this browser!"), q());
        }()) : c("Auto Resize disabled"), D("init", "Init message from host page");
    }
    function h(a, b) {
        void 0 !== b && "" !== b && "null" !== b && c("Body " + a + ' set to "' + (document.body.style[a] = b) + '"');
    }
    function k() {
        a(window, "resize", function() {
            D("resize", "Window resized");
        });
    }
    function l() {
        a(window, "click", function() {
            D("click", "Window clicked");
        });
    }
    function m() {
        U !== V && (V in jb || (d(V + " is not a valid option for heightCalculationMethod."), 
        V = "bodyScroll"), c('Height calculation method set to "' + V + '"'));
    }
    function q() {
        0 !== Y && (c("setInterval: " + Y + "ms"), setInterval(function() {
            D("interval", "setInterval: " + Y);
        }, Math.abs(Y)));
    }
    function r(b) {
        function d(b) {
            void 0 !== b.height && void 0 !== b.width && 0 !== b.height && 0 !== b.width || (c("Attach listerner to " + b.src), 
            a(b, "load", function() {
                D("imageLoad", "Image loaded");
            }));
        }
        b.forEach(function(b) {
            "attributes" === b.type && "src" === b.attributeName ? d(b.target) : "childList" === b.type && (b = b.target.querySelectorAll("img"), 
            Array.prototype.forEach.call(b, function(a) {
                d(a);
            }));
        });
    }
    function t() {
        function a(a) {
            var c = document.body, d = 0, d = "defaultView" in document && "getComputedStyle" in document.defaultView ? null !== (d = document.defaultView.getComputedStyle(c, null)) ? d[a] : 0 : function(a) {
                if (/^\d+(px)?$/i.test(a)) return parseInt(a, K);
                var d = c.style.left, e = c.runtimeStyle.left;
                return c.runtimeStyle.left = c.currentStyle.left, c.style.left = a || 0, a = c.style.pixelLeft, 
                c.style.left = d, c.runtimeStyle.left = e, a;
            }(c.currentStyle[a]);
            return parseInt(d, K);
        }
        return document.body.offsetHeight + a("marginTop") + a("marginBottom");
    }
    function u() {
        return document.body.scrollHeight;
    }
    function v() {
        return document.documentElement.offsetHeight;
    }
    function w() {
        return document.documentElement.scrollHeight;
    }
    function y() {
        return [ t(), u(), v(), w() ];
    }
    function z() {
        return Math.max.apply(null, y());
    }
    function C() {
        return Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);
    }
    function D(a, b, d, e) {
        function f() {
            a in {
                reset: 1,
                resetPage: 1,
                init: 1
            } || c("Trigger event: " + b);
        }
        var n, o;
        gb && a in Q ? c("Trigger event cancelled: " + a) : function() {
            function a(a, b) {
                return !(Math.abs(a - b) <= fb);
            }
            return n = void 0 !== d ? d : jb[V](), o = void 0 !== e ? e : C(), a(S, n) || P && a(ib, o);
        }() ? (f(), E(), H(S = n, ib = o, a)) : !(a in {
            init: 1,
            interval: 1,
            size: 1
        }) && V in cb ? G(b) : a in {
            interval: 1
        } || (f(), c("No change in size detected"));
    }
    function E() {
        gb || (gb = !0, c("Trigger event lock on")), clearTimeout(hb), hb = setTimeout(function() {
            gb = !1, c("Trigger event lock off"), c("--");
        }, R);
    }
    function F(a) {
        S = jb[V](), ib = C(), H(S, ib, a);
    }
    function G(a) {
        var b = V;
        V = U, c("Reset trigger event: " + a), E(), F("reset"), V = b;
    }
    function H(a, b, d, e, f) {
        void 0 === f ? f = db : c("Message targetOrigin: " + f), function() {
            var h = ab + ":" + (a + ":" + b) + ":" + d + (void 0 !== e ? ":" + e : "");
            c("Sending message to host page (" + h + ")"), eb.postMessage($ + h, f);
        }();
    }
    var J = !0, K = 10, L = "", M = 0, N = "", O = "", P = !1, Q = {
        resize: 1,
        click: 1
    }, R = 128, S = 1, T = !0, U = "offset", V = U, W = !0, X = "", Y = 32, Z = !1, $ = "[iFrameSizer]", _ = $.length, ab = "", bb = !1, cb = {
        max: 1,
        scroll: 1,
        bodyScroll: 1,
        documentElementScroll: 1
    }, db = "*", eb = window.parent, fb = 0, gb = !1, hb = null, ib = 1, jb = {
        offset: t,
        bodyOffset: t,
        bodyScroll: u,
        documentElementOffset: v,
        scroll: w,
        documentElementScroll: w,
        max: z,
        min: function() {
            return Math.min.apply(null, y());
        },
        grow: z,
        lowestElement: function() {
            return Math.max(t(), function() {
                for (var a = document.querySelectorAll("body *"), b = a.length, d = 0, e = new Date().getTime(), f = 0; f < b; f++) a[f].getBoundingClientRect().bottom > d && (d = a[f].getBoundingClientRect().bottom);
                return e = new Date().getTime() - e, c("Parsed " + b + " HTML elements"), c("LowestElement bottom position calculated in " + e + "ms"), 
                d;
            }());
        }
    };
    a(window, "message", function(a) {
        $ === ("" + a.data).substr(0, _) && (T && a.data.split(":")[2] in {
            true: 1,
            false: 1
        } ? (X = a.data, eb = a.source, e(), T = !1, setTimeout(function() {
            W = !1;
        }, R)) : "reset" === a.data.split("]")[1] ? W ? c("Page reset ignored by init") : (c("Page size reset by host page"), 
        F("resetPage")) : a.data === X || "iFrameResize" in window || d("Unexpected message (" + a.data + ")"));
    });
}();

var D, E, t = void 0, u = !1, sjcl = {
    cipher: {},
    hash: {},
    keyexchange: {},
    mode: {},
    misc: {},
    codec: {},
    exception: {
        corrupt: function(a) {
            this.toString = function() {
                return "CORRUPT: " + this.message;
            }, this.message = a;
        },
        invalid: function(a) {
            this.toString = function() {
                return "INVALID: " + this.message;
            }, this.message = a;
        },
        bug: function(a) {
            this.toString = function() {
                return "BUG: " + this.message;
            }, this.message = a;
        },
        notReady: function(a) {
            this.toString = function() {
                return "NOT READY: " + this.message;
            }, this.message = a;
        }
    }
};

function y(a, b, c) {
    4 !== b.length && q(new sjcl.exception.invalid("invalid aes block size"));
    var d = a.a[c], e = b[0] ^ d[0], f = b[c ? 3 : 1] ^ d[1], g = b[2] ^ d[2];
    b = b[c ? 1 : 3] ^ d[3];
    var l, k, n = d.length / 4 - 2, p = 4, s = [ 0, 0, 0, 0 ], h = a.j[c];
    a = h[0];
    for (var r = h[1], v = h[2], w = h[3], x = h[4], m = 0; m < n; m++) h = a[e >>> 24] ^ r[f >> 16 & 255] ^ v[g >> 8 & 255] ^ w[255 & b] ^ d[p], 
    l = a[f >>> 24] ^ r[g >> 16 & 255] ^ v[b >> 8 & 255] ^ w[255 & e] ^ d[p + 1], k = a[g >>> 24] ^ r[b >> 16 & 255] ^ v[e >> 8 & 255] ^ w[255 & f] ^ d[p + 2], 
    b = a[b >>> 24] ^ r[e >> 16 & 255] ^ v[f >> 8 & 255] ^ w[255 & g] ^ d[p + 3], p += 4, 
    e = h, f = l, g = k;
    for (m = 0; m < 4; m++) s[c ? 3 & -m : m] = x[e >>> 24] << 24 ^ x[f >> 16 & 255] << 16 ^ x[g >> 8 & 255] << 8 ^ x[255 & b] ^ d[p++], 
    h = e, e = f, f = g, g = b, b = h;
    return s;
}

function z(a, g) {
    for (var d, e, f = g.slice(0), g = a.q, h = a.a, l = g[0], k = g[1], n = g[2], m = g[3], p = g[4], s = g[5], r = g[6], v = g[7], c = 0; c < 64; c++) d = (d = c < 16 ? f[c] : (d = f[c + 1 & 15], 
    e = f[c + 14 & 15], f[15 & c] = (d >>> 7 ^ d >>> 18 ^ d >>> 3 ^ d << 25 ^ d << 14) + (e >>> 17 ^ e >>> 19 ^ e >>> 10 ^ e << 15 ^ e << 13) + f[15 & c] + f[c + 9 & 15] | 0)) + v + (p >>> 6 ^ p >>> 11 ^ p >>> 25 ^ p << 26 ^ p << 21 ^ p << 7) + (r ^ p & (s ^ r)) + h[c], 
    v = r, r = s, s = p, p = m + d | 0, m = n, n = k, l = d + ((k = l) & n ^ m & (k ^ n)) + (k >>> 2 ^ k >>> 13 ^ k >>> 22 ^ k << 30 ^ k << 19 ^ k << 10) | 0;
    g[0] = g[0] + l | 0, g[1] = g[1] + k | 0, g[2] = g[2] + n | 0, g[3] = g[3] + m | 0, 
    g[4] = g[4] + p | 0, g[5] = g[5] + s | 0, g[6] = g[6] + r | 0, g[7] = g[7] + v | 0;
}

function C(a, b) {
    var c, d = sjcl.random.z[a], e = [];
    for (c in d) d.hasOwnProperty(c) && e.push(d[c]);
    for (c = 0; c < e.length; c++) e[c](b);
}

function A(a) {
    a.a = B(a).concat(B(a)), a.A = new sjcl.cipher.aes(a.a);
}

function B(a) {
    for (var b = 0; b < 4 && (a.e[b] = a.e[b] + 1 | 0, !a.e[b]); b++) ;
    return a.A.encrypt(a.e);
}

"undefined" != typeof module && module.exports && (module.exports = sjcl), sjcl.cipher.aes = function(a) {
    this.j[0][0][0] || this.D();
    var c, d, e, f = this.j[0][4], g = this.j[1], b = a.length, h = 1;
    for (4 !== b && 6 !== b && 8 !== b && q(new sjcl.exception.invalid("invalid aes key size")), 
    this.a = [ d = a.slice(0), e = [] ], a = b; a < 4 * b + 28; a++) c = d[a - 1], (0 == a % b || 8 === b && 4 == a % b) && (c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[255 & c], 
    0 == a % b && (c = c << 8 ^ c >>> 24 ^ h << 24, h = h << 1 ^ 283 * (h >> 7))), d[a] = d[a - b] ^ c;
    for (b = 0; a; b++, a--) c = d[3 & b ? a : a - 4], e[b] = a <= 4 || b < 4 ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[255 & c]];
}, sjcl.cipher.aes.prototype = {
    encrypt: function(a) {
        return y(this, a, 0);
    },
    decrypt: function(a) {
        return y(this, a, 1);
    },
    j: [ [ [], [], [], [], [] ], [ [], [], [], [], [] ] ],
    D: function() {
        for (var f, g, k, n, m, p, a = this.j[0], b = this.j[1], c = a[4], d = b[4], h = [], l = [], e = 0; e < 256; e++) l[(h[e] = e << 1 ^ 283 * (e >> 7)) ^ e] = e;
        for (f = g = 0; !c[f]; f ^= k || 1, g = l[g] || 1) for (m = (m = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4) >> 8 ^ 255 & m ^ 99, 
        p = 16843009 * (n = h[e = h[k = h[d[c[f] = m] = f]]]) ^ 65537 * e ^ 257 * k ^ 16843008 * f, 
        n = 257 * h[m] ^ 16843008 * m, e = 0; e < 4; e++) a[e][f] = n = n << 24 ^ n >>> 8, 
        b[e][m] = p = p << 24 ^ p >>> 8;
        for (e = 0; e < 5; e++) a[e] = a[e].slice(0), b[e] = b[e].slice(0);
    }
}, sjcl.bitArray = {
    bitSlice: function(a, b, c) {
        return a = sjcl.bitArray.P(a.slice(b / 32), 32 - (31 & b)).slice(1), c === t ? a : sjcl.bitArray.clamp(a, c - b);
    },
    extract: function(a, b, c) {
        var d = Math.floor(-b - c & 31);
        return (-32 & (b + c - 1 ^ b) ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1;
    },
    concat: function(a, b) {
        if (0 === a.length || 0 === b.length) return a.concat(b);
        var c = a[a.length - 1], d = sjcl.bitArray.getPartial(c);
        return 32 === d ? a.concat(b) : sjcl.bitArray.P(b, d, 0 | c, a.slice(0, a.length - 1));
    },
    bitLength: function(a) {
        var b = a.length;
        return 0 === b ? 0 : 32 * (b - 1) + sjcl.bitArray.getPartial(a[b - 1]);
    },
    clamp: function(a, b) {
        if (32 * a.length < b) return a;
        var c = (a = a.slice(0, Math.ceil(b / 32))).length;
        return b &= 31, 0 < c && b && (a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1)), 
        a;
    },
    partial: function(a, b, c) {
        return 32 === a ? b : (c ? 0 | b : b << 32 - a) + 1099511627776 * a;
    },
    getPartial: function(a) {
        return Math.round(a / 1099511627776) || 32;
    },
    equal: function(a, b) {
        if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) return u;
        for (var c = 0, d = 0; d < a.length; d++) c |= a[d] ^ b[d];
        return 0 === c;
    },
    P: function(a, b, c, d) {
        var e = 0;
        for (d === t && (d = []); 32 <= b; b -= 32) d.push(c), c = 0;
        if (0 === b) return d.concat(a);
        for (e = 0; e < a.length; e++) d.push(c | a[e] >>> b), c = a[e] << 32 - b;
        return e = a.length ? a[a.length - 1] : 0, a = sjcl.bitArray.getPartial(e), d.push(sjcl.bitArray.partial(b + a & 31, 32 < b + a ? c : d.pop(), 1)), 
        d;
    },
    k: function(a, b) {
        return [ a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3] ];
    }
}, sjcl.codec.utf8String = {
    fromBits: function(a) {
        for (var e, b = "", c = sjcl.bitArray.bitLength(a), d = 0; d < c / 8; d++) 0 == (3 & d) && (e = a[d / 4]), 
        b += String.fromCharCode(e >>> 24), e <<= 8;
        return decodeURIComponent(escape(b));
    },
    toBits: function(a) {
        a = unescape(encodeURIComponent(a));
        for (var b = [], d = 0, c = 0; c < a.length; c++) d = d << 8 | a.charCodeAt(c), 
        3 == (3 & c) && (b.push(d), d = 0);
        return 3 & c && b.push(sjcl.bitArray.partial(8 * (3 & c), d)), b;
    }
}, sjcl.codec.hex = {
    fromBits: function(a) {
        for (var b = "", c = 0; c < a.length; c++) b += (0xf00000000000 + (0 | a[c])).toString(16).substr(4);
        return b.substr(0, sjcl.bitArray.bitLength(a) / 4);
    },
    toBits: function(a) {
        var b, c = [], d = (a = a.replace(/\s|0x/g, "")).length;
        for (a += "00000000", b = 0; b < a.length; b += 8) c.push(0 ^ parseInt(a.substr(b, 8), 16));
        return sjcl.bitArray.clamp(c, 4 * d);
    }
}, sjcl.codec.base64 = {
    J: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    fromBits: function(a, b, c) {
        var d = "", e = 0, f = sjcl.codec.base64.J, g = 0, h = sjcl.bitArray.bitLength(a);
        for (c && (f = f.substr(0, 62) + "-_"), c = 0; 6 * d.length < h; ) d += f.charAt((g ^ a[c] >>> e) >>> 26), 
        e < 6 ? (g = a[c] << 6 - e, e += 26, c++) : (g <<= 6, e -= 6);
        for (;3 & d.length && !b; ) d += "=";
        return d;
    },
    toBits: function(a, b) {
        a = a.replace(/\s|=/g, "");
        var d, h, c = [], e = 0, f = sjcl.codec.base64.J, g = 0;
        for (b && (f = f.substr(0, 62) + "-_"), d = 0; d < a.length; d++) (h = f.indexOf(a.charAt(d))) < 0 && q(new sjcl.exception.invalid("this isn't base64!")), 
        26 < e ? (e -= 26, c.push(g ^ h >>> e), g = h << 32 - e) : g ^= h << 32 - (e += 6);
        return 56 & e && c.push(sjcl.bitArray.partial(56 & e, g, 1)), c;
    }
}, sjcl.codec.base64url = {
    fromBits: function(a) {
        return sjcl.codec.base64.fromBits(a, 1, 1);
    },
    toBits: function(a) {
        return sjcl.codec.base64.toBits(a, 1);
    }
}, sjcl.hash.sha256 = function(a) {
    this.a[0] || this.D(), a ? (this.q = a.q.slice(0), this.n = a.n.slice(0), this.g = a.g) : this.reset();
}, sjcl.hash.sha256.hash = function(a) {
    return new sjcl.hash.sha256().update(a).finalize();
}, sjcl.hash.sha256.prototype = {
    blockSize: 512,
    reset: function() {
        return this.q = this.N.slice(0), this.n = [], this.g = 0, this;
    },
    update: function(a) {
        "string" == typeof a && (a = sjcl.codec.utf8String.toBits(a));
        var c = this.n = sjcl.bitArray.concat(this.n, a), b = this.g;
        for (a = this.g = b + sjcl.bitArray.bitLength(a), b = 512 + b & -512; b <= a; b += 512) z(this, c.splice(0, 16));
        return this;
    },
    finalize: function() {
        for (var b = this.n, c = this.q, a = (b = sjcl.bitArray.concat(b, [ sjcl.bitArray.partial(1, 1) ])).length + 2; 15 & a; a++) b.push(0);
        for (b.push(Math.floor(this.g / 4294967296)), b.push(0 | this.g); b.length; ) z(this, b.splice(0, 16));
        return this.reset(), c;
    },
    N: [],
    a: [],
    D: function() {
        function a(a) {
            return 4294967296 * (a - Math.floor(a)) | 0;
        }
        var d, b = 0, c = 2;
        a: for (;b < 64; c++) {
            for (d = 2; d * d <= c; d++) if (0 == c % d) continue a;
            b < 8 && (this.N[b] = a(Math.pow(c, .5))), this.a[b] = a(Math.pow(c, 1 / 3)), b++;
        }
    }
}, sjcl.mode.ccm = {
    name: "ccm",
    encrypt: function(a, b, c, d, e) {
        var f, g = b.slice(0), h = sjcl.bitArray, l = h.bitLength(c) / 8, k = h.bitLength(g) / 8;
        for (e = e || 64, d = d || [], l < 7 && q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes")), 
        f = 2; f < 4 && k >>> 8 * f; f++) ;
        return f < 15 - l && (f = 15 - l), c = h.clamp(c, 8 * (15 - f)), b = sjcl.mode.ccm.L(a, b, c, d, e, f), 
        g = sjcl.mode.ccm.o(a, g, c, b, e, f), h.concat(g.data, g.tag);
    },
    decrypt: function(a, b, c, d, e) {
        e = e || 64, d = d || [];
        var f = sjcl.bitArray, g = f.bitLength(c) / 8, h = f.bitLength(b), l = f.clamp(b, h - e), k = f.bitSlice(b, h - e), h = (h - e) / 8;
        for (g < 7 && q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes")), 
        b = 2; b < 4 && h >>> 8 * b; b++) ;
        return b < 15 - g && (b = 15 - g), c = f.clamp(c, 8 * (15 - b)), l = sjcl.mode.ccm.o(a, l, c, k, e, b), 
        a = sjcl.mode.ccm.L(a, l.data, c, d, e, b), f.equal(l.tag, a) || q(new sjcl.exception.corrupt("ccm: tag doesn't match")), 
        l.data;
    },
    L: function(a, b, c, d, e, f) {
        var g = [], h = sjcl.bitArray, l = h.k;
        if (((e /= 8) % 2 || e < 4 || 16 < e) && q(new sjcl.exception.invalid("ccm: invalid tag length")), 
        (4294967295 < d.length || 4294967295 < b.length) && q(new sjcl.exception.bug("ccm: can't deal with 4GiB or more data")), 
        f = [ h.partial(8, (d.length ? 64 : 0) | e - 2 << 2 | f - 1) ], (f = h.concat(f, c))[3] |= h.bitLength(b) / 8, 
        f = a.encrypt(f), d.length) for ((c = h.bitLength(d) / 8) <= 65279 ? g = [ h.partial(16, c) ] : c <= 4294967295 && (g = h.concat([ h.partial(16, 65534) ], [ c ])), 
        g = h.concat(g, d), d = 0; d < g.length; d += 4) f = a.encrypt(l(f, g.slice(d, d + 4).concat([ 0, 0, 0 ])));
        for (d = 0; d < b.length; d += 4) f = a.encrypt(l(f, b.slice(d, d + 4).concat([ 0, 0, 0 ])));
        return h.clamp(f, 8 * e);
    },
    o: function(a, b, c, d, e, f) {
        var h = sjcl.bitArray, g = h.k, l = b.length, k = h.bitLength(b);
        if (c = h.concat([ h.partial(8, f - 1) ], c).concat([ 0, 0, 0 ]).slice(0, 4), d = h.bitSlice(g(d, a.encrypt(c)), 0, e), 
        !l) return {
            tag: d,
            data: []
        };
        for (g = 0; g < l; g += 4) c[3]++, e = a.encrypt(c), b[g] ^= e[0], b[g + 1] ^= e[1], 
        b[g + 2] ^= e[2], b[g + 3] ^= e[3];
        return {
            tag: d,
            data: h.clamp(b, k)
        };
    }
}, sjcl.mode.ocb2 = {
    name: "ocb2",
    encrypt: function(a, b, c, d, e, f) {
        128 !== sjcl.bitArray.bitLength(c) && q(new sjcl.exception.invalid("ocb iv must be 128 bits"));
        var g, h = sjcl.mode.ocb2.H, l = sjcl.bitArray, k = l.k, n = [ 0, 0, 0, 0 ];
        c = h(a.encrypt(c));
        var m, p = [];
        for (d = d || [], e = e || 64, g = 0; g + 4 < b.length; g += 4) n = k(n, m = b.slice(g, g + 4)), 
        p = p.concat(k(c, a.encrypt(k(c, m)))), c = h(c);
        return m = b.slice(g), b = l.bitLength(m), g = a.encrypt(k(c, [ 0, 0, 0, b ])), 
        m = l.clamp(k(m.concat([ 0, 0, 0 ]), g), b), n = k(n, k(m.concat([ 0, 0, 0 ]), g)), 
        n = a.encrypt(k(n, k(c, h(c)))), d.length && (n = k(n, f ? d : sjcl.mode.ocb2.pmac(a, d))), 
        p.concat(l.concat(m, l.clamp(n, e)));
    },
    decrypt: function(a, b, c, d, e, f) {
        128 !== sjcl.bitArray.bitLength(c) && q(new sjcl.exception.invalid("ocb iv must be 128 bits")), 
        e = e || 64;
        var m, p, g = sjcl.mode.ocb2.H, h = sjcl.bitArray, l = h.k, k = [ 0, 0, 0, 0 ], n = g(a.encrypt(c)), s = sjcl.bitArray.bitLength(b) - e, r = [];
        for (d = d || [], c = 0; c + 4 < s / 32; c += 4) m = l(n, a.decrypt(l(n, b.slice(c, c + 4)))), 
        k = l(k, m), r = r.concat(m), n = g(n);
        return p = s - 32 * c, m = a.encrypt(l(n, [ 0, 0, 0, p ])), m = l(m, h.clamp(b.slice(c), p).concat([ 0, 0, 0 ])), 
        k = l(k, m), k = a.encrypt(l(k, l(n, g(n)))), d.length && (k = l(k, f ? d : sjcl.mode.ocb2.pmac(a, d))), 
        h.equal(h.clamp(k, e), h.bitSlice(b, s)) || q(new sjcl.exception.corrupt("ocb: tag doesn't match")), 
        r.concat(h.clamp(m, p));
    },
    pmac: function(a, b) {
        for (var d = sjcl.mode.ocb2.H, e = sjcl.bitArray, f = e.k, g = [ 0, 0, 0, 0 ], h = f(h = a.encrypt([ 0, 0, 0, 0 ]), d(d(h))), c = 0; c + 4 < b.length; c += 4) h = d(h), 
        g = f(g, a.encrypt(f(h, b.slice(c, c + 4))));
        return c = b.slice(c), e.bitLength(c) < 128 && (h = f(h, d(h)), c = e.concat(c, [ -2147483648, 0, 0, 0 ])), 
        g = f(g, c), a.encrypt(f(d(f(h, d(h))), g));
    },
    H: function(a) {
        return [ a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ 135 * (a[0] >>> 31) ];
    }
}, sjcl.mode.gcm = {
    name: "gcm",
    encrypt: function(a, b, c, d, e) {
        var f = b.slice(0);
        return b = sjcl.bitArray, d = d || [], a = sjcl.mode.gcm.o(!0, a, f, d, c, e || 128), 
        b.concat(a.data, a.tag);
    },
    decrypt: function(a, b, c, d, e) {
        var f = b.slice(0), g = sjcl.bitArray, h = g.bitLength(f);
        return d = d || [], f = (e = e || 128) <= h ? (b = g.bitSlice(f, h - e), g.bitSlice(f, 0, h - e)) : (b = f, 
        []), a = sjcl.mode.gcm.o(u, a, f, d, c, e), g.equal(a.tag, b) || q(new sjcl.exception.corrupt("gcm: tag doesn't match")), 
        a.data;
    },
    W: function(a, b) {
        for (var d, g, h = sjcl.bitArray.k, e = [ 0, 0, 0, 0 ], f = b.slice(0), c = 0; c < 128; c++) {
            for ((d = 0 != (a[Math.floor(c / 32)] & 1 << 31 - c % 32)) && (e = h(e, f)), g = 0 != (1 & f[3]), 
            d = 3; 0 < d; d--) f[d] = f[d] >>> 1 | (1 & f[d - 1]) << 31;
            f[0] >>>= 1, g && (f[0] ^= -520093696);
        }
        return e;
    },
    f: function(a, b, c) {
        var d, e = c.length;
        for (b = b.slice(0), d = 0; d < e; d += 4) b[0] ^= 4294967295 & c[d], b[1] ^= 4294967295 & c[d + 1], 
        b[2] ^= 4294967295 & c[d + 2], b[3] ^= 4294967295 & c[d + 3], b = sjcl.mode.gcm.W(b, a);
        return b;
    },
    o: function(a, b, c, d, e, f) {
        var l, k, n, r = sjcl.bitArray, m = c.length, p = r.bitLength(c), s = r.bitLength(d), h = r.bitLength(e), g = b.encrypt([ 0, 0, 0, 0 ]);
        for (e = 96 === h ? (e = e.slice(0), r.concat(e, [ 1 ])) : (e = sjcl.mode.gcm.f(g, [ 0, 0, 0, 0 ], e), 
        sjcl.mode.gcm.f(g, e, [ 0, 0, Math.floor(h / 4294967296), 4294967295 & h ])), h = sjcl.mode.gcm.f(g, [ 0, 0, 0, 0 ], d), 
        n = e.slice(0), d = h.slice(0), a || (d = sjcl.mode.gcm.f(g, h, c)), k = 0; k < m; k += 4) n[3]++, 
        l = b.encrypt(n), c[k] ^= l[0], c[k + 1] ^= l[1], c[k + 2] ^= l[2], c[k + 3] ^= l[3];
        return c = r.clamp(c, p), a && (d = sjcl.mode.gcm.f(g, h, c)), a = [ Math.floor(s / 4294967296), 4294967295 & s, Math.floor(p / 4294967296), 4294967295 & p ], 
        d = sjcl.mode.gcm.f(g, d, a), l = b.encrypt(e), d[0] ^= l[0], d[1] ^= l[1], d[2] ^= l[2], 
        d[3] ^= l[3], {
            tag: r.bitSlice(d, 0, f),
            data: c
        };
    }
}, sjcl.misc.hmac = function(a, b) {
    this.M = b = b || sjcl.hash.sha256;
    var d, c = [ [], [] ], e = b.prototype.blockSize / 32;
    for (this.m = [ new b(), new b() ], a.length > e && (a = b.hash(a)), d = 0; d < e; d++) c[0][d] = 909522486 ^ a[d], 
    c[1][d] = 1549556828 ^ a[d];
    this.m[0].update(c[0]), this.m[1].update(c[1]), this.G = new b(this.m[0]);
}, sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function(a) {
    return this.Q && q(new sjcl.exception.invalid("encrypt on already updated hmac called!")), 
    this.update(a), this.digest(a);
}, sjcl.misc.hmac.prototype.reset = function() {
    this.G = new this.M(this.m[0]), this.Q = u;
}, sjcl.misc.hmac.prototype.update = function(a) {
    this.Q = !0, this.G.update(a);
}, sjcl.misc.hmac.prototype.digest = function() {
    var a = this.G.finalize(), a = new this.M(this.m[1]).update(a).finalize();
    return this.reset(), a;
}, sjcl.misc.pbkdf2 = function(a, b, c, d, e) {
    c = c || 1e3, (d < 0 || c < 0) && q(sjcl.exception.invalid("invalid params to pbkdf2")), 
    "string" == typeof a && (a = sjcl.codec.utf8String.toBits(a)), "string" == typeof b && (b = sjcl.codec.utf8String.toBits(b)), 
    a = new (e = e || sjcl.misc.hmac)(a);
    for (var f, g, h, k = [], n = sjcl.bitArray, l = 1; 32 * k.length < (d || 1); l++) {
        for (e = f = a.encrypt(n.concat(b, [ l ])), g = 1; g < c; g++) for (f = a.encrypt(f), 
        h = 0; h < f.length; h++) e[h] ^= f[h];
        k = k.concat(e);
    }
    return k = d ? n.clamp(k, d) : k;
}, sjcl.prng = function(a) {
    this.b = [ new sjcl.hash.sha256() ], this.h = [ 0 ], this.F = 0, this.t = {}, this.C = 0, 
    this.K = {}, this.O = this.c = this.i = this.V = 0, this.a = [ 0, 0, 0, 0, 0, 0, 0, 0 ], 
    this.e = [ 0, 0, 0, 0 ], this.A = t, this.B = a, this.p = u, this.z = {
        progress: {},
        seeded: {}
    }, this.l = this.U = 0, this.u = 1, this.w = 2, this.S = 65536, this.I = [ 0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024 ], 
    this.T = 3e4, this.R = 80;
}, sjcl.prng.prototype = {
    randomWords: function(a, b) {
        var e, c = [], d = this.isReady(b);
        if (d === this.l && q(new sjcl.exception.notReady("generator isn't seeded")), d & this.w) {
            d = !(d & this.u), e = [];
            var g, f = 0;
            for (this.O = e[0] = new Date().valueOf() + this.T, g = 0; g < 16; g++) e.push(4294967296 * Math.random() | 0);
            for (g = 0; g < this.b.length && (e = e.concat(this.b[g].finalize()), f += this.h[g], 
            this.h[g] = 0, d || !(this.F & 1 << g)); g++) ;
            for (this.F >= 1 << this.b.length && (this.b.push(new sjcl.hash.sha256()), this.h.push(0)), 
            this.c -= f, f > this.i && (this.i = f), this.F++, this.a = sjcl.hash.sha256.hash(this.a.concat(e)), 
            this.A = new sjcl.cipher.aes(this.a), d = 0; d < 4 && (this.e[d] = this.e[d] + 1 | 0, 
            !this.e[d]); d++) ;
        }
        for (d = 0; d < a; d += 4) 0 == (d + 1) % this.S && A(this), e = B(this), c.push(e[0], e[1], e[2], e[3]);
        return A(this), c.slice(0, a);
    },
    setDefaultParanoia: function(a) {
        this.B = a;
    },
    addEntropy: function(a, b, c) {
        c = c || "user";
        var e, f = new Date().valueOf(), g = this.t[c], h = this.isReady(), l = 0, d = this.K[c];
        switch (d === t && (d = this.K[c] = this.V++), g === t && (g = this.t[c] = 0), this.t[c] = (this.t[c] + 1) % this.b.length, 
        typeof a) {
          case "number":
            b === t && (b = 1), this.b[g].update([ d, this.C++, 1, b, f, 1, 0 | a ]);
            break;

          case "object":
            if ("[object Uint32Array]" === (c = Object.prototype.toString.call(a))) {
                for (e = [], c = 0; c < a.length; c++) e.push(a[c]);
                a = e;
            } else for ("[object Array]" !== c && (l = 1), c = 0; c < a.length && !l; c++) "number" != typeof a[c] && (l = 1);
            if (!l) {
                if (b === t) for (c = b = 0; c < a.length; c++) for (e = a[c]; 0 < e; ) b++, e >>>= 1;
                this.b[g].update([ d, this.C++, 2, b, f, a.length ].concat(a));
            }
            break;

          case "string":
            b === t && (b = a.length), this.b[g].update([ d, this.C++, 3, b, f, a.length ]), 
            this.b[g].update(a);
            break;

          default:
            l = 1;
        }
        l && q(new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string")), 
        this.h[g] += b, this.c += b, h === this.l && (this.isReady() !== this.l && C("seeded", Math.max(this.i, this.c)), 
        C("progress", this.getProgress()));
    },
    isReady: function(a) {
        return a = this.I[a !== t ? a : this.B], this.i && this.i >= a ? this.h[0] > this.R && new Date().valueOf() > this.O ? this.w | this.u : this.u : this.c >= a ? this.w | this.l : this.l;
    },
    getProgress: function(a) {
        return a = this.I[a || this.B], this.i >= a || this.c > a ? 1 : this.c / a;
    },
    startCollectors: function() {
        this.p || (window.addEventListener ? (window.addEventListener("load", this.r, u), 
        window.addEventListener("mousemove", this.s, u)) : document.attachEvent ? (document.attachEvent("onload", this.r), 
        document.attachEvent("onmousemove", this.s)) : q(new sjcl.exception.bug("can't attach event")), 
        this.p = !0);
    },
    stopCollectors: function() {
        this.p && (window.removeEventListener ? (window.removeEventListener("load", this.r, u), 
        window.removeEventListener("mousemove", this.s, u)) : window.detachEvent && (window.detachEvent("onload", this.r), 
        window.detachEvent("onmousemove", this.s)), this.p = u);
    },
    addEventListener: function(a, b) {
        this.z[a][this.U++] = b;
    },
    removeEventListener: function(a, b) {
        var c, d, e = this.z[a], f = [];
        for (d in e) e.hasOwnProperty(d) && e[d] === b && f.push(d);
        for (c = 0; c < f.length; c++) delete e[d = f[c]];
    },
    s: function(a) {
        sjcl.random.addEntropy([ a.x || a.clientX || a.offsetX || 0, a.y || a.clientY || a.offsetY || 0 ], 2, "mouse");
    },
    r: function() {
        sjcl.random.addEntropy(new Date().valueOf(), 2, "loadtime");
    }
}, sjcl.random = new sjcl.prng(6);

try {
    "undefined" != typeof module && module.exports ? (D = require("crypto").randomBytes(128), 
    sjcl.random.addEntropy(D, 1024, "crypto['randomBytes']")) : window && window.crypto && window.crypto.getRandomValues && (E = new Uint32Array(32), 
    window.crypto.getRandomValues(E), sjcl.random.addEntropy(E, 1024, "crypto['getRandomValues']"));
} catch (F) {}

sjcl.json = {
    defaults: {
        v: 1,
        iter: 1e3,
        ks: 128,
        ts: 64,
        mode: "ccm",
        adata: "",
        cipher: "aes"
    },
    encrypt: function(a, b, c, d) {
        c = c || {}, d = d || {};
        var g, e = sjcl.json, f = e.d({
            iv: sjcl.random.randomWords(4, 0)
        }, e.defaults);
        return e.d(f, c), c = f.adata, "string" == typeof f.salt && (f.salt = sjcl.codec.base64.toBits(f.salt)), 
        "string" == typeof f.iv && (f.iv = sjcl.codec.base64.toBits(f.iv)), (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || "string" == typeof a && f.iter <= 100 || 64 !== f.ts && 96 !== f.ts && 128 !== f.ts || 128 !== f.ks && 192 !== f.ks && 256 !== f.ks || f.iv.length < 2 || 4 < f.iv.length) && q(new sjcl.exception.invalid("json encrypt: invalid parameters")), 
        "string" == typeof a ? (a = (g = sjcl.misc.cachedPbkdf2(a, f)).key.slice(0, f.ks / 32), 
        f.salt = g.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.publicKey && (g = a.kem(), 
        f.kemtag = g.tag, a = g.key.slice(0, f.ks / 32)), "string" == typeof b && (b = sjcl.codec.utf8String.toBits(b)), 
        "string" == typeof c && (c = sjcl.codec.utf8String.toBits(c)), g = new sjcl.cipher[f.cipher](a), 
        e.d(d, f), d.key = a, f.ct = sjcl.mode[f.mode].encrypt(g, b, f.iv, c, f.ts), e.encode(f);
    },
    decrypt: function(a, b, c, d) {
        c = c || {}, d = d || {};
        var f, e = sjcl.json;
        return c = (b = e.d(e.d(e.d({}, e.defaults), e.decode(b)), c, !0)).adata, "string" == typeof b.salt && (b.salt = sjcl.codec.base64.toBits(b.salt)), 
        "string" == typeof b.iv && (b.iv = sjcl.codec.base64.toBits(b.iv)), (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || "string" == typeof a && b.iter <= 100 || 64 !== b.ts && 96 !== b.ts && 128 !== b.ts || 128 !== b.ks && 192 !== b.ks && 256 !== b.ks || !b.iv || b.iv.length < 2 || 4 < b.iv.length) && q(new sjcl.exception.invalid("json decrypt: invalid parameters")), 
        "string" == typeof a ? (a = (f = sjcl.misc.cachedPbkdf2(a, b)).key.slice(0, b.ks / 32), 
        b.salt = f.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.secretKey && (a = a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0, b.ks / 32)), 
        "string" == typeof c && (c = sjcl.codec.utf8String.toBits(c)), f = new sjcl.cipher[b.cipher](a), 
        c = sjcl.mode[b.mode].decrypt(f, b.ct, b.iv, c, b.ts), e.d(d, b), d.key = a, sjcl.codec.utf8String.fromBits(c);
    },
    encode: function(a) {
        var b, c = "{", d = "";
        for (b in a) if (a.hasOwnProperty(b)) switch (b.match(/^[a-z0-9]+$/i) || q(new sjcl.exception.invalid("json encode: invalid property name")), 
        c += d + '"' + b + '":', d = ",", typeof a[b]) {
          case "number":
          case "boolean":
            c += a[b];
            break;

          case "string":
            c += '"' + escape(a[b]) + '"';
            break;

          case "object":
            c += '"' + sjcl.codec.base64.fromBits(a[b], 0) + '"';
            break;

          default:
            q(new sjcl.exception.bug("json encode: unsupported type"));
        }
        return c + "}";
    },
    decode: function(a) {
        (a = a.replace(/\s/g, "")).match(/^\{.*\}$/) || q(new sjcl.exception.invalid("json decode: this isn't json!")), 
        a = a.replace(/^\{|\}$/g, "").split(/,/);
        for (var d, b = {}, c = 0; c < a.length; c++) (d = a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i)) || q(new sjcl.exception.invalid("json decode: this isn't json!")), 
        b[d[2]] = d[3] ? parseInt(d[3], 10) : d[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(d[4]) : unescape(d[4]);
        return b;
    },
    d: function(a, b, c) {
        if (a === t && (a = {}), b === t) return a;
        for (var d in b) b.hasOwnProperty(d) && (c && a[d] !== t && a[d] !== b[d] && q(new sjcl.exception.invalid("required parameter overridden")), 
        a[d] = b[d]);
        return a;
    },
    Z: function(a, b) {
        var d, c = {};
        for (d in a) a.hasOwnProperty(d) && a[d] !== b[d] && (c[d] = a[d]);
        return c;
    },
    Y: function(a, b) {
        for (var c = {}, d = 0; d < b.length; d++) a[b[d]] !== t && (c[b[d]] = a[b[d]]);
        return c;
    }
}, sjcl.encrypt = sjcl.json.encrypt, sjcl.decrypt = sjcl.json.decrypt, sjcl.misc.X = {}, 
sjcl.misc.cachedPbkdf2 = function(a, b) {
    var c = sjcl.misc.X, d = (b = b || {}).iter || 1e3;
    return (d = (c = c[a] = c[a] || {})[d] = c[d] || {
        firstSalt: b.salt && b.salt.length ? b.salt.slice(0) : sjcl.random.randomWords(2, 0)
    })[c = b.salt === t ? d.firstSalt : b.salt] = d[c] || sjcl.misc.pbkdf2(a, c, b.iter), 
    {
        key: d[c].slice(0),
        salt: c.slice(0)
    };
}, Random = {
    getRandomInteger: function(max) {
        var random = max.bitLength(), random = sjcl.random.randomWords(random / 32, 0);
        return new BigInt(sjcl.codec.hex.fromBits(random), 16).mod(max);
    }
};